<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>fucking-leetcode/递归</title>
      <link href="/2020/04/07/fucking-leetcode/%E9%80%92%E5%BD%92/"/>
      <url>/2020/04/07/fucking-leetcode/%E9%80%92%E5%BD%92/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><h1 id="我与递归的故事"><a class="markdownIt-Anchor" href="#我与递归的故事"></a> 我与递归的故事</h1><p>为什么我要直接从递归开始介绍我的刷题之旅呢？因为当我刷过了一些题目之后，我慢慢的发现递归真的是解题的一个大杀器。使用递归不仅可以解决有关树、图等题目，还可以解决链表、字符串、排列组合、动态规划等题目，甚至有很多问题只能通过递归进行求解。虽然递归思想很有用也很好用，但是如何编写出正确的递归代码却是一个痛苦的过程。</p><p>其实对于递归一开始我是拒绝的，一见到别人的递归代码就直接跳过反而看迭代的代码，但该来的总会来，所以那就做真的勇士，敢于面对惨淡的人生。</p><img src="/" style="zoom:50%;" / class="lazyload" data-src="https://cdn.jsdelivr.net/gh/jackymxp/image-bed/leetcode/20200416184418.png"><p>慢慢的，我开始看并且尝试去理解别人的递归代码，然后我开始编写递归代码；在经过编写了大量的递归代码后，最后我总结出编写递归代码的套路。</p><p>在学习递归的这条路上，用电影《肖申克的救赎》中的一段话形容我的心路历程很合适。</p><blockquote><p>These walls are kind of funny like that. First you hate them, then you get used to them. Enough time passed， get so you depend on them. That’s institution alized.</p><p>这些高墙真的很有趣，一开始你憎恨他们；然后你慢慢的习惯他们；最后你不得不依赖他们而生存，这就是体制化。</p></blockquote><p>不过用中文描述我的心路历程就很简单了。</p><p><img src="/" alt="" / class="lazyload" data-src="https://cdn.jsdelivr.net/gh/jackymxp/image-bed/design-pattern/u=1882634846,423550706&amp;fm=26&amp;gp=0.jpg"></p><p>理解了递归，才会发现递归真香，接下来结合我自己的经验，说一下如何理解和使用递归？</p><p><strong>理解递归最重要的一点就是放弃，放弃刨根问底的精神，不要深究在递归函数内部是怎么运行的，而是信任递归能够解决问题</strong>，这就是如何理解递归的核心。<mark>信任的基础在于数学。</mark></p><p><img src="/" alt="" / class="lazyload" data-src="https://tva1.sinaimg.cn/large/007S8ZIlly1gdvuk5zq5kj30cf089aak.jpg"></p><p>当我慢慢的理解了递归，我发现递归解决问题的这种感觉似曾相识，什么时候有过这种感觉呢？在初恋的年纪学习<strong>数学归纳法</strong>的时候，曾经有过这种不需要刨根问题的精神。所以为了理解递归，先来回顾一下用数学归纳法解题的步骤：</p><blockquote><ol><li>当<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>n</mi><mo>=</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">n=1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">n</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span>时，显然成立。</li><li>假设当<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>n</mi><mo>=</mo><mi>k</mi></mrow><annotation encoding="application/x-tex">n=k</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">n</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span></span></span></span>时，依然成立。</li><li>证明当<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>n</mi><mo>=</mo><mi>k</mi><mo>+</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">n=k+1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">n</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.77777em;vertical-align:-0.08333em;"></span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span>时，等式是成立的，这一步比较困难。</li></ol></blockquote><p>数学归纳法的<strong>核心就是在<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>f</mi><mo stretchy="false">(</mo><mi>n</mi><mo>−</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">f(n-1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span>的基础上，找出<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>f</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">f(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mclose">)</span></span></span></span>和<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>f</mi><mo stretchy="false">(</mo><mi>n</mi><mo>−</mo><mn>1</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">f(n-1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mclose">)</span></span></span></span>之间的关系</strong>。</p><p>其实编写递归的套路和数学归纳法如出一辙。按照数学归纳法的三个步骤，给出编写递归的四点，这里先说三点，最后一点放在文章的最后。</p><blockquote><ol><li>**明确编写的递归函数功能、递归函数参数以及返回值。**对应数学归纳法中的第二条。当给递归函数传入不同参数时，根据定义的递归函数的功能，函数应该返回什么结果，这一点是一直都要明确的。</li><li><strong>明确递归函数的退出条件</strong>。对应数学归纳法中的第一条。如果没有退出条件，就一直递归下去，结果就是爆栈。一般来说，这点相对来讲比较简单。这一点</li><li><strong>如何把分割数据为多层，并梳理清楚层与层之间的关系</strong>。对应数学归纳法中的第三条。在数学归纳法中，我们要找出<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>f</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">f(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mclose">)</span></span></span></span>和<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>f</mi><mo stretchy="false">(</mo><mi>n</mi><mo>−</mo><mn>1</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">f(n-1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mclose">)</span></span></span></span>之间的关系，其实就是层与层之间的关系。在递归中，一般是将一个规模为<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">n</span></span></span></span>的数据拆分成两个或者多个规模更小的数据，假设拆分成规模为<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>n</mi><mo>−</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">n-1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.66666em;vertical-align:-0.08333em;"></span><span class="mord mathdefault">n</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span>和<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>1</mn></mrow><annotation encoding="application/x-tex">1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span>的两部分。其中将<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>n</mi><mo>−</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">n-1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.66666em;vertical-align:-0.08333em;"></span><span class="mord mathdefault">n</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span>部分仍然作为递归的参数，根据定义的递归函数的功能，<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>n</mi><mo>−</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">n-1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.66666em;vertical-align:-0.08333em;"></span><span class="mord mathdefault">n</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span>部分就得到了期望的答案。这里切记千万不要深究递归函数是怎么把<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>n</mi><mo>−</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">n-1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.66666em;vertical-align:-0.08333em;"></span><span class="mord mathdefault">n</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span>部分变成期望的答案的，只要知道递归函数可以达到我们期望的目的就行了。前面说的放弃，就是在这里放弃思考如何实现<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>n</mi><mo>−</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">n-1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.66666em;vertical-align:-0.08333em;"></span><span class="mord mathdefault">n</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span>部分的。接下来的工作就是在已经得到期望答案的规模为<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>n</mi><mo>−</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">n-1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.66666em;vertical-align:-0.08333em;"></span><span class="mord mathdefault">n</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span>数据的基础上，与规模为<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>1</mn></mrow><annotation encoding="application/x-tex">1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span>的数据进行适当的融合，使整体变成期望的答案。当然我们也可以将规模为<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">n</span></span></span></span>的数据拆分成规模为<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>n</mi><mo>−</mo><mn>2</mn></mrow><annotation encoding="application/x-tex">n-2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.66666em;vertical-align:-0.08333em;"></span><span class="mord mathdefault">n</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">2</span></span></span></span>和<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>2</mn></mrow><annotation encoding="application/x-tex">2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">2</span></span></span></span>两个部分，甚至是规模为<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>n</mi><mi mathvariant="normal">/</mi><mn>2</mn></mrow><annotation encoding="application/x-tex">n/2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">n</span><span class="mord">/</span><span class="mord">2</span></span></span></span>和<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>n</mi><mi mathvariant="normal">/</mi><mn>2</mn></mrow><annotation encoding="application/x-tex">n/2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">n</span><span class="mord">/</span><span class="mord">2</span></span></span></span>两个部分，比如归并排序。那么在快排中，把数据分成了<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>n</mi><mo>−</mo><mi>k</mi></mrow><annotation encoding="application/x-tex">n-k</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.66666em;vertical-align:-0.08333em;"></span><span class="mord mathdefault">n</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span></span></span></span>和<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>k</mi></mrow><annotation encoding="application/x-tex">k</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span></span></span></span>两个部分，其中<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>k</mi></mrow><annotation encoding="application/x-tex">k</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span></span></span></span>是每次<code>partition</code>后的索引值。但是具体问题还应具体分析。我们把我们期望的答案或者结构看成是一层，将数据规模更小的那部分用递归函数作用后的结果看作一层，其实还是寻找层与层之间的关系。</li></ol></blockquote><p>写了这么多苍白无力的文字和解释，还是用一个小例子解释一下数学归纳法和递归更为清楚。</p><h1 id="递归函数核心层与层之间的关系"><a class="markdownIt-Anchor" href="#递归函数核心层与层之间的关系"></a> 递归函数核心：层与层之间的关系</h1><h2 id="阶乘问题"><a class="markdownIt-Anchor" href="#阶乘问题"></a> 阶乘问题</h2><blockquote><p>使用递归的方法求<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">n</span></span></span></span>的阶乘。</p></blockquote><p>按照前面给出的递归的三个步骤，盘这个题。</p><p><strong>1. 定义递归函数<code>int factorial(int n)</code>功能以及返回值</strong>：</p><p>定义递归函数功能是计算<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">n</span></span></span></span>的阶乘。也就是说，当传入<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">n</span></span></span></span>的时候，就计算<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">n</span></span></span></span>的阶乘；当传入<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>n</mi><mo>−</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">n-1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.66666em;vertical-align:-0.08333em;"></span><span class="mord mathdefault">n</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span>的时候，就计算<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>n</mi><mo>−</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">n-1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.66666em;vertical-align:-0.08333em;"></span><span class="mord mathdefault">n</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span>的阶乘。这样说是不是很简单。</p><p><strong>2. 寻找递归函数退出条件和返回值</strong></p><p>因为要将<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">n</span></span></span></span>拆成两个部分，所以递归退出的条件就是<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">n</span></span></span></span>不能分成两个部分的时候，也就是<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>n</mi><mo>=</mo><mn>0</mn></mrow><annotation encoding="application/x-tex">n=0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">n</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">0</span></span></span></span>时，就是递归退出条件，数学知识我们都知道，<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>0</mn><mo stretchy="false">!</mo><mo>=</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">0!=1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord">0</span><span class="mclose">!</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span>，写成代码。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(n == <span class="number">0</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br></pre></td></tr></table></figure><p><strong>3. 如何把分割数据为多层，并梳理清楚层与层之间的关系</strong></p><p>想一下，这里如何递减数据规模呢，或者把数据分为多层呢？</p><p>想要计算<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">n</span></span></span></span>的阶乘，那么如果知道了<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>n</mi><mo>−</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">n-1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.66666em;vertical-align:-0.08333em;"></span><span class="mord mathdefault">n</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span>的阶乘，怎么计算<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">n</span></span></span></span>的阶乘呢？当然这是一个so easy的数学问题，不管你知不知道，反正我是知道，<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>n</mi><mo stretchy="false">!</mo><mo>=</mo><mo stretchy="false">(</mo><mi>n</mi><mo>−</mo><mn>1</mn><mo stretchy="false">)</mo><mo stretchy="false">!</mo><mo>∗</mo><mi>n</mi></mrow><annotation encoding="application/x-tex">n! = (n-1)! * n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault">n</span><span class="mclose">!</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mclose">)</span><span class="mclose">!</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">n</span></span></span></span>。那么问题来了，如何计算<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>n</mi><mo>−</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">n-1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.66666em;vertical-align:-0.08333em;"></span><span class="mord mathdefault">n</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span>的阶乘呢？额，如果你从头看到了这里还不知道怎么计算<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>n</mi><mo>−</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">n-1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.66666em;vertical-align:-0.08333em;"></span><span class="mord mathdefault">n</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span>的阶乘，那你从头再看一遍吧。这不是定义的递归函数功能嘛，调用<code>factorial(n-1)</code>就完成了<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>n</mi><mo>−</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">n-1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.66666em;vertical-align:-0.08333em;"></span><span class="mord mathdefault">n</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span>阶乘的计算。在这里请放弃思考为什么调用<code>factorial(n-1)</code>就完成了<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>n</mi><mo>−</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">n-1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.66666em;vertical-align:-0.08333em;"></span><span class="mord mathdefault">n</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span>阶乘的计算。对应的完成代码。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">factorial</span><span class="params">(<span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(n == <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line"><span class="keyword">return</span> n * factorial(n<span class="number">-1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>4. 思考</strong></p><p>我们只有这样一种方式去递减数据规模吗？其实肯定不是。要计算<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>n</mi><mo stretchy="false">!</mo></mrow><annotation encoding="application/x-tex">n!</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault">n</span><span class="mclose">!</span></span></span></span>，如果我们知道了<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo stretchy="false">(</mo><mi>n</mi><mo>−</mo><mn>2</mn><mo stretchy="false">)</mo><mo stretchy="false">!</mo></mrow><annotation encoding="application/x-tex">(n-2)!</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">2</span><span class="mclose">)</span><span class="mclose">!</span></span></span></span>行不行，其实真的行，因为<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>n</mi><mo stretchy="false">!</mo><mo>=</mo><mo stretchy="false">(</mo><mi>n</mi><mo>−</mo><mn>2</mn><mo stretchy="false">)</mo><mo stretchy="false">!</mo><mo>∗</mo><mo stretchy="false">(</mo><mi>n</mi><mo>−</mo><mn>1</mn><mo stretchy="false">)</mo><mo>∗</mo><mi>n</mi></mrow><annotation encoding="application/x-tex">n! = (n-2)! * (n-1) * n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault">n</span><span class="mclose">!</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">2</span><span class="mclose">)</span><span class="mclose">!</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">n</span></span></span></span>。那么问题来了，如何计算<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>n</mi><mo>−</mo><mn>2</mn></mrow><annotation encoding="application/x-tex">n-2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.66666em;vertical-align:-0.08333em;"></span><span class="mord mathdefault">n</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">2</span></span></span></span>的阶乘呢？其实还是调用<code>factorial(n-2)</code>就完事了。这里我又要说出递归的精髓，放弃思考。此时的代码应该如下。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">factorial</span><span class="params">(<span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(n == <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line"><span class="keyword">return</span> n * (n<span class="number">-1</span>) * factorial(n<span class="number">-2</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果按照这种递减策略的话，想一下递归退出的条件是不是应该改变。如果不变的话，当<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>n</mi><mo>=</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">n=1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">n</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span>时，就要调用到<code>factorial(-1)</code>，这样就不会跳出递归函数了。所以就要修改递归函数退出条件。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">factorial</span><span class="params">(<span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(n == <span class="number">0</span> || n == <span class="number">1</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line"><span class="keyword">return</span> n * (n<span class="number">-1</span>) * factorial(n<span class="number">-2</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>按照这种递减策略下去，当把阶乘公式写成<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>n</mi><mo stretchy="false">!</mo><mo>=</mo><mi>n</mi><mo>∗</mo><mo stretchy="false">(</mo><mi>n</mi><mo>−</mo><mn>1</mn><mo stretchy="false">)</mo><mo>∗</mo><mo stretchy="false">(</mo><mi>n</mi><mo>−</mo><mn>2</mn><mo stretchy="false">)</mo><mo>∗</mo><mi>f</mi><mi>a</mi><mi>c</mi><mi>t</mi><mi>o</mi><mi>r</mi><mi>i</mi><mi>a</mi><mi>l</mi><mo stretchy="false">(</mo><mi>n</mi><mo>−</mo><mn>3</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">n! = n * (n-1) * (n-2) * factorial(n-3)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault">n</span><span class="mclose">!</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.46528em;vertical-align:0em;"></span><span class="mord mathdefault">n</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">2</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="mord mathdefault">a</span><span class="mord mathdefault">c</span><span class="mord mathdefault">t</span><span class="mord mathdefault">o</span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mord mathdefault">i</span><span class="mord mathdefault">a</span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">3</span><span class="mclose">)</span></span></span></span>这种形式，递归的规模又减少了。如此递推下去，<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>n</mi><mo stretchy="false">!</mo><mo>=</mo><mi>n</mi><mo>∗</mo><mo stretchy="false">(</mo><mi>n</mi><mo>−</mo><mn>1</mn><mo stretchy="false">)</mo><mo>∗</mo><mo stretchy="false">(</mo><mi>n</mi><mo>−</mo><mn>2</mn><mo stretchy="false">)</mo><mo>∗</mo><mo stretchy="false">(</mo><mi>n</mi><mo>−</mo><mn>3</mn><mo stretchy="false">)</mo><mo>∗</mo><mo>…</mo><mo>∗</mo><mo stretchy="false">(</mo><mi>n</mi><mo>−</mo><mo stretchy="false">(</mo><mi>n</mi><mo>−</mo><mn>1</mn><mo stretchy="false">)</mo><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">n!=n*(n-1)*(n-2)*(n-3)*…*(n-(n-1))</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault">n</span><span class="mclose">!</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.46528em;vertical-align:0em;"></span><span class="mord mathdefault">n</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">2</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">3</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.46528em;vertical-align:0em;"></span><span class="minner">…</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mclose">)</span><span class="mclose">)</span></span></span></span>，咦，仔细看看，这不就是阶乘的迭代写法嘛，所以阶乘的迭代写法如下。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">factorial</span><span class="params">(<span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> res = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = n; i &gt;= <span class="number">1</span>; i--)</span><br><span class="line">        res *= i;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>虽然上面这个例子及其简单，但是我们还是要回顾一下。编写递归函数中的关键在于如何恰当的分割数据，因为不同分割数据的方法，不仅会影响到层与层之间的关系，还影响到递归退出的条件。</p><p>当把规模为<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">n</span></span></span></span>的分割成<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>1</mn></mrow><annotation encoding="application/x-tex">1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span>和<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>n</mi><mo>−</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">n-1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.66666em;vertical-align:-0.08333em;"></span><span class="mord mathdefault">n</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span>时，<code>factorial(n)</code>层与<code>factorial(n-1)</code>之间的关系相差一个<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">n</span></span></span></span>。这个<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">n</span></span></span></span>就是两层之间的一个桥梁。递归函数的退出条件是<code>n=0</code></p><p>当把规模为<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">n</span></span></span></span>的分割成<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>2</mn></mrow><annotation encoding="application/x-tex">2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">2</span></span></span></span>和<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>n</mi><mo>−</mo><mn>2</mn></mrow><annotation encoding="application/x-tex">n-2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.66666em;vertical-align:-0.08333em;"></span><span class="mord mathdefault">n</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">2</span></span></span></span>时，<code>factorial(n)</code>层与<code>factorial(n-2)</code>之间的关系相差一个<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>n</mi><mo>∗</mo><mo stretchy="false">(</mo><mi>n</mi><mo>−</mo><mn>1</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">n*(n-1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.46528em;vertical-align:0em;"></span><span class="mord mathdefault">n</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mclose">)</span></span></span></span>。这个<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>n</mi><mo>∗</mo><mo stretchy="false">(</mo><mi>n</mi><mo>−</mo><mn>1</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">n*(n-1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.46528em;vertical-align:0em;"></span><span class="mord mathdefault">n</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mclose">)</span></span></span></span>就是两层之间的一个桥梁。递归函数的退出条件是<code>n=0</code>或者<code>n=1</code>。</p><p>从上面的总结中我们可以看到，递归的核心就是<strong>如何分割数据，以及找到层与层之间的关系。</strong></p><h2 id="链表翻转"><a class="markdownIt-Anchor" href="#链表翻转"></a> 链表翻转</h2><p>但凡是讲到递归，和链表相关的，有一个经典的题就是链表翻转。但是这个题，一开始我是不理解如何使用递归去翻转链表的，但是当我慢慢熟悉了递归，我发现，用递归解决链表翻转，都能玩出花样。</p><p>比如有如下这个链表，经翻转后应该变成如下的样子</p><p><img src="/" alt="" / class="lazyload" data-src="https://cdn.jsdelivr.net/gh/jackymxp/image-bed/leetcode/20200410203127.png"></p><p>当然，由于这个第二个，就比较难了，所以还是按照写递归的三个步骤来解决这个问题。</p><h3 id="递归解法1"><a class="markdownIt-Anchor" href="#递归解法1"></a> 递归解法1</h3><p><strong>1. 定义递归函数<code>ListNode* reverseList(ListNode* head)</code>功能以及返回值</strong>：</p><p>翻转以<code>head</code>为头节点的链表，并返回翻转后的链表的头节点。记住这个功能是我们自己定义的，是我们赋予它具有什么功能他就具有什么功能，随后我们就按照这个功能为前提，进行编写递归函数。</p><p><strong>2. 寻找递归函数的退出条件</strong></p><p>当链表中只有一个节点或者没有节点的时候，就不用翻转了，所以直接退出。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(head == <span class="literal">nullptr</span> || head-&gt;next == <span class="literal">nullptr</span>)</span><br><span class="line">    <span class="keyword">return</span> head;</span><br></pre></td></tr></table></figure><p><strong>3. 拆分原数据，寻找层与层之间的关系</strong></p><p>假设我们要翻转的链表的长度是<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">n</span></span></span></span>，在这里，我们要怎么拆分数据呢？其实，只要按照上面的套路，我们想怎么拆就怎么拆。假设在这里，我们将其拆成<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>n</mi><mo>−</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">n-1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.66666em;vertical-align:-0.08333em;"></span><span class="mord mathdefault">n</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span>和<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>1</mn></mrow><annotation encoding="application/x-tex">1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span>两个部分。拆分数据的代码。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ListNode* newHead = head-&gt;next;</span><br><span class="line">head-&gt;next = <span class="literal">nullptr</span>;</span><br></pre></td></tr></table></figure><p><img src="/" alt="" / class="lazyload" data-src="https://tva1.sinaimg.cn/large/007S8ZIlly1ge09f7zmtuj30q605kjrn.jpg"></p><p>按照上面的套路，对于<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>n</mi><mo>−</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">n-1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.66666em;vertical-align:-0.08333em;"></span><span class="mord mathdefault">n</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span>部分，仍然作为递归函数的参数。这时候<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>n</mi><mo>−</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">n-1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.66666em;vertical-align:-0.08333em;"></span><span class="mord mathdefault">n</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span>部分就已经完成了翻转，得到了我们期望的结构。记住那句话了没，这里千万不要想着为啥使用递归函数作用后就完成了<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>n</mi><mo>−</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">n-1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.66666em;vertical-align:-0.08333em;"></span><span class="mord mathdefault">n</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span>部分的翻转呢？而是直接用这个结论，和剩下没有参与递归的部分进行融合，使链表整体变成我们期望的答案。此时链表变成了如下图的样子。</p><p><img src="/" alt="" / class="lazyload" data-src="https://tva1.sinaimg.cn/large/007S8ZIlly1ge09l2uo2mj30ru05wgm1.jpg"></p><p>为了得到我们期望的样子，我们只需要将<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>n</mi><mo>−</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">n-1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.66666em;vertical-align:-0.08333em;"></span><span class="mord mathdefault">n</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span>部分和<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>1</mn></mrow><annotation encoding="application/x-tex">1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span>的部分做一个简单的指针指向的改变，就完成了链表的翻转。</p><p><img src="/" alt="" / class="lazyload" data-src="https://tva1.sinaimg.cn/large/007S8ZIlly1ge09pzvegjj30s005g74o.jpg"></p><p>所以将核心部分写成代码</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">ListNode* retHead = reverseList(newHead);</span><br><span class="line">newHead-&gt;next = head;</span><br><span class="line">head-&gt;next = <span class="literal">nullptr</span>;</span><br><span class="line"><span class="keyword">return</span> retHead;</span><br></pre></td></tr></table></figure><p>所以说，只要我们放弃了对于为啥<code>reverseList(newHead)</code>就可以完成链表的翻转，我们就可以顺利写出递归的代码了。</p><p>当然，还有更多的骚操作吗？其实当然可以有更骚的操作。</p><ul><li>完整代码</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">ListNode* <span class="title">reverseList</span><span class="params">(ListNode* head)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//当链表中只有一个节点或者没有节点的时候，直接退出</span></span><br><span class="line">    <span class="keyword">if</span>(!head || !head-&gt;next)</span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line">    <span class="comment">//分成两个部分</span></span><br><span class="line">    ListNode* newHead = head-&gt;next;</span><br><span class="line">    head-&gt;next = <span class="literal">nullptr</span>;</span><br><span class="line">    <span class="comment">//完成 k - 1 部分的翻转</span></span><br><span class="line">    ListNode* retHead = reverseList(newHead);</span><br><span class="line">    <span class="comment">//修改指针，是最后一部分完成翻转</span></span><br><span class="line">    newHead-&gt;next = head;</span><br><span class="line">    head-&gt;next = <span class="literal">nullptr</span>;</span><br><span class="line">    <span class="keyword">return</span> retHead;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="递归解法2"><a class="markdownIt-Anchor" href="#递归解法2"></a> 递归解法2</h3><p>上面我们将原来的数据规模<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">n</span></span></span></span>拆分成<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>n</mi><mo>−</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">n-1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.66666em;vertical-align:-0.08333em;"></span><span class="mord mathdefault">n</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span>和<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>1</mn></mrow><annotation encoding="application/x-tex">1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span>两个部分，现在换种解法，将<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">n</span></span></span></span>拆分成<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>n</mi><mi mathvariant="normal">/</mi><mn>2</mn></mrow><annotation encoding="application/x-tex">n/2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">n</span><span class="mord">/</span><span class="mord">2</span></span></span></span>和<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>n</mi><mi mathvariant="normal">/</mi><mn>2</mn></mrow><annotation encoding="application/x-tex">n/2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">n</span><span class="mord">/</span><span class="mord">2</span></span></span></span>两个部分，看下和上面解法的不同。</p><p>对于编写递归的第一步和第二步，</p><p>想要拆分成<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>n</mi><mi mathvariant="normal">/</mi><mn>2</mn></mrow><annotation encoding="application/x-tex">n/2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">n</span><span class="mord">/</span><span class="mord">2</span></span></span></span>和<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>n</mi><mi mathvariant="normal">/</mi><mn>2</mn></mrow><annotation encoding="application/x-tex">n/2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">n</span><span class="mord">/</span><span class="mord">2</span></span></span></span>，第一个问题就是如何定位到链表的中点。坐下，这当然都是常规操作了，当然是使用快慢指针了，快指针一次走两步，慢指针一次走一步。当快指针到达链表终点时，慢指针就走到了中点，此中点非彼终点。虽然使用快慢指针原理很简单，但是还是要注意下细节的。把它写成代码。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">ListNode* fast = head;</span><br><span class="line">ListNode* slow = head;</span><br><span class="line">ListNode* mid = <span class="literal">NULL</span>;</span><br><span class="line"><span class="keyword">while</span>(fast &amp;&amp; fast-&gt;next) <span class="comment">//访问fast-&gt;next之前要保证fast本身不为空</span></span><br><span class="line">&#123;</span><br><span class="line">    fast = fast-&gt;next-&gt;next;</span><br><span class="line">    mid = slow;</span><br><span class="line">    slow = slow-&gt;next;</span><br><span class="line">&#125;</span><br><span class="line">mid-&gt;next = <span class="literal">NULL</span>;</span><br></pre></td></tr></table></figure><p>其中<code>head</code>、<code>mid</code>、<code>slow</code>三个指针的指向如下所示。</p><p><img src="/" alt="" / class="lazyload" data-src="https://tva1.sinaimg.cn/large/007S8ZIlly1ge0b2lfyhaj30ps05maac.jpg"></p><p>接下来的步骤还用我说嘛，当然是使用<code>head</code>和<code>slow</code>分别作为递归函数的参数，就分别完成了链表两个部分的翻转。大声告诉我，这里的台词是什么？请放弃思考为什么递归函数就可以完成<code>head</code>和<code>slow</code>两个部分的翻转。而是在完成了翻转的基础上，再进行数据的融合。</p><p><img src="/" alt="" / class="lazyload" data-src="https://tva1.sinaimg.cn/large/007S8ZIlly1ge0bebexxxj30qk05smxi.jpg"></p><p>写成代码，并更改<code>slow-&gt;next</code>的指针指向<code>ret1</code>即可。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">ListNode* ret1 = reverseList(head);</span><br><span class="line">ListNode* ret2 = reverseList(slow);</span><br><span class="line">slow-&gt;next = ret1;</span><br><span class="line"><span class="keyword">return</span> ret2;</span><br></pre></td></tr></table></figure><p>这样是不是就大功告成了。</p><p>当然还有不止这两种数据拆分的方式，还有更多的精彩拆分方式，我们再来看一种。</p><ul><li>完成代码</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">ListNode* <span class="title">reverseList</span><span class="params">(ListNode* head)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!head || !head-&gt;next)</span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line"></span><br><span class="line">    ListNode* fast = head;</span><br><span class="line">    ListNode* slow = head;</span><br><span class="line">    ListNode* mid = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">while</span>(fast &amp;&amp; fast-&gt;next)</span><br><span class="line">    &#123;</span><br><span class="line">        fast = fast-&gt;next-&gt;next;</span><br><span class="line">        mid = slow;</span><br><span class="line">        slow = slow-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    mid-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">    ListNode* ret1 = reverseList(head);</span><br><span class="line">    ListNode* ret2 = reverseList(slow);</span><br><span class="line">    slow-&gt;next = ret1;</span><br><span class="line">    <span class="keyword">return</span> ret2;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="递归解法3"><a class="markdownIt-Anchor" href="#递归解法3"></a> 递归解法3</h3><p>既然我们知道了递归的套路，干脆再换种拆分数据的方式，这次我们将数据规模为<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">n</span></span></span></span>拆分成<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>n</mi><mo>−</mo><mn>2</mn></mrow><annotation encoding="application/x-tex">n-2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.66666em;vertical-align:-0.08333em;"></span><span class="mord mathdefault">n</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">2</span></span></span></span>和<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>2</mn></mrow><annotation encoding="application/x-tex">2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">2</span></span></span></span>这两个部分。我们来看下，这种拆分方式，和前面的解法有什么不同。</p><p><strong>递归函数的退出条件</strong></p><p>首先我们定义的递归函数的功能是不变的，但是对于递归的退出条件是应该改变的，应该变成什么呢？</p><blockquote><p>如果只有一个节点或者没有节点的时候，就应该直接退出。</p><p>如果只有两个节点的时候，就翻转这两个节点。</p></blockquote><p>所以写成代码</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(head == <span class="literal">nullptr</span> || head-&gt;next = <span class="literal">nullptr</span>)</span><br><span class="line">    <span class="keyword">return</span> head;</span><br><span class="line"><span class="keyword">if</span>(head-&gt;next-&gt;next == <span class="literal">nullptr</span>)</span><br><span class="line">&#123;</span><br><span class="line">    ListNode* retNode = head-&gt;next;</span><br><span class="line">   retNode-&gt;next = head;</span><br><span class="line">    head-&gt;next = <span class="literal">nullptr</span>;</span><br><span class="line">    <span class="keyword">return</span> retNode;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>分割数据，寻求层与层之间的关系</strong></p><p>对于数据规模大于<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>2</mn></mrow><annotation encoding="application/x-tex">2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">2</span></span></span></span>的时候，就应该进入到递归中了，所以首先我们将链表分为<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>n</mi><mo>−</mo><mn>2</mn></mrow><annotation encoding="application/x-tex">n-2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.66666em;vertical-align:-0.08333em;"></span><span class="mord mathdefault">n</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">2</span></span></span></span>和<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>2</mn></mrow><annotation encoding="application/x-tex">2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">2</span></span></span></span>两个部分。分割代码</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ListNode* node2 = head-&gt;next-&gt;next;</span><br><span class="line">head-&gt;next-&gt;next = <span class="literal">nullptr</span>;</span><br></pre></td></tr></table></figure><p><img src="/" alt="" / class="lazyload" data-src="https://tva1.sinaimg.cn/large/007S8ZIlly1ge0hj0qa4tj30s405e0sz.jpg"></p><p>接下来数据规模为<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>n</mi><mo>−</mo><mn>2</mn></mrow><annotation encoding="application/x-tex">n-2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.66666em;vertical-align:-0.08333em;"></span><span class="mord mathdefault">n</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">2</span></span></span></span>的数据作为递归函数的参数，当递归函数作用后，<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>n</mi><mo>−</mo><mn>2</mn></mrow><annotation encoding="application/x-tex">n-2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.66666em;vertical-align:-0.08333em;"></span><span class="mord mathdefault">n</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">2</span></span></span></span>部分就完成了链表的翻转。这时候大声告诉我，此时应该做什么。此时应该做的是，放弃思考为什么递归函数就可以完成链表的翻转，而是再翻转的基础上，和没有参与递归的部分进行融合。</p><p><img src="/" alt="" / class="lazyload" data-src="https://tva1.sinaimg.cn/large/007S8ZIlly1ge0ho865f4j30sa05oweu.jpg"></p><p>此时只要改变指针的指向就可以了。写成代码如下。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">ListNode* retHead = reverseList(node2);</span><br><span class="line">ListNode* node1 = head-&gt;next;</span><br><span class="line">node2-&gt;next = node1;</span><br><span class="line">node1-&gt;next = head;</span><br><span class="line">head-&gt;next = <span class="literal">nullptr</span>;</span><br><span class="line"><span class="keyword">return</span> retHead;</span><br></pre></td></tr></table></figure><ul><li>完整代码</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">ListNode* <span class="title">reverseList</span><span class="params">(ListNode* head)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(head == <span class="literal">nullptr</span> || head-&gt;next == <span class="literal">nullptr</span>)</span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line">    <span class="keyword">if</span>(head-&gt;next-&gt;next == <span class="literal">nullptr</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        ListNode* retHead = head-&gt;next;</span><br><span class="line">        retHead-&gt;next = head;</span><br><span class="line">        head-&gt;next = <span class="literal">nullptr</span>;</span><br><span class="line">        <span class="keyword">return</span> retHead;</span><br><span class="line">    &#125;</span><br><span class="line">    ListNode* node2 = head-&gt;next-&gt;next;</span><br><span class="line">    head-&gt;next-&gt;next = <span class="literal">nullptr</span>;</span><br><span class="line">    ListNode* retHead = reverseList(node2);</span><br><span class="line">    ListNode* node1 = head-&gt;next;</span><br><span class="line">    node2-&gt;next = node1;</span><br><span class="line">    node1-&gt;next = head;</span><br><span class="line">    head-&gt;next = <span class="literal">nullptr</span>;</span><br><span class="line">    <span class="keyword">return</span> retHead;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="思考"><a class="markdownIt-Anchor" href="#思考"></a> 思考</h3><p>当我们总结一下当把递归的规模分为<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>n</mi><mo>−</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">n-1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.66666em;vertical-align:-0.08333em;"></span><span class="mord mathdefault">n</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span>和<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>n</mi><mo>−</mo><mn>2</mn></mrow><annotation encoding="application/x-tex">n-2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.66666em;vertical-align:-0.08333em;"></span><span class="mord mathdefault">n</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">2</span></span></span></span>部分时，在编写代码的时候，几乎可以看到有重复的操作，比如让<code>newHead-&gt;next = head</code>和<code>head-&gt;next = nullptr</code>。我们可以看到，链表的翻转就是将，此节点的<code>next</code>指针指向上一个节点，但是再改变之前要保存此节点的下一个节点，如此循环到最后一个节点。这就是链表翻转的核心。所以写成迭代代码如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">ListNode* <span class="title">reverseList</span><span class="params">(ListNode* head)</span></span>&#123;</span><br><span class="line">    ListNode* pre = <span class="literal">nullptr</span>;</span><br><span class="line">    ListNode* cur = head;</span><br><span class="line">    <span class="keyword">while</span>(cur)&#123;</span><br><span class="line">        <span class="comment">//先保存下一个节点</span></span><br><span class="line">        ListNode* next = cur-&gt;next;</span><br><span class="line">        <span class="comment">//更改指针</span></span><br><span class="line">        cur-&gt;next = pre; </span><br><span class="line">        <span class="comment">//同时向后一位</span></span><br><span class="line">        pre = cur;</span><br><span class="line">        cur = next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> pre;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>由于链表的天然特性，对于链表的很多问题其实都是可以用递归解决的。比如要改变链表的结构、在链表中删除元素、甚至是链表的合并和排序问题。但是用递归解决链表的核心问题就是如何划分链表为两个部分或者更多部分，以及处理层与层之间的关系。当然在编写链表有关问题的时候，要仔细处理指针问题，尤其是访问某个节点的值时，要确定此节点不为空。这点尤其容易出错。</p><p>有关使用递归解决链表的问题，请看我的解题。</p><h2 id="汉诺塔"><a class="markdownIt-Anchor" href="#汉诺塔"></a> 汉诺塔</h2><p>有关汉诺塔的问题，我真的不想介绍太多了。想必知道递归的应该都应该有过被汉诺塔支配的恐惧吧。</p><p>汉诺塔真的是童年的一个经典的小游戏，我记得当时在某一款学习机上就有这个益智游戏，不过当时我还是凭借自己出色的智商把游戏玩到了第四关，并且那时候我就知道，如果想要移动四层，只要把前三层的都移动另外一个柱子上就行了，剩下的就和两个盘子的是一个道理。</p><p>那时候，我就有一种强烈的想法就是，这个东西一定是有一定的步骤的和规律的，但是这个步骤我要怎么才能生成呢？</p><p>这个问题直到我大学一年级学了C语言并且知道了递归之后，才知道这个要用递归解决，但是无论如何，我都不知道为啥要这么写递归。直到现在，我放弃了理解递归，才真正的能够编写出汉诺塔的代码。</p><p><img src="/" alt="img" / class="lazyload" data-src="/Users/mengxiangpeng/Desktop/%E9%80%92%E5%BD%92.assets/1026866-20161016022859889-2055402664.jpg"></p><p>假设我们要编写一个函数<code>TowersOfHanoi(int n, char A, char B, char C)</code>实现借助B柱将n个汉诺塔从A移动到C。我们还是按照编写递归的三个步骤：</p><ol><li><p>定义递归函数<code>TowersOfHanoi(int n, char A, char B, char C)</code>功能：借助B柱，将n个汉诺塔从A移动到C上。也就是说，第一个变量是柱子的起点，中点的变量是枢纽站，最后一个变量才是终点。</p></li><li><p>递归函数的退出条件：</p><p>当只有一个盘子的时候，直接从A移动到C就行了。写成代码</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(n == <span class="number">1</span>)</span><br><span class="line">&#123;</span><br><span class="line">    move(<span class="number">1</span>, A, C);</span><br><span class="line">    <span class="keyword">return</span> ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>分割数据，找到层与层之间的联系。</p><p>想一下，如果我们只想移动最后一个盘子，就是说将第<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">n</span></span></span></span>个盘子看成一个，其余的<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>n</mi><mo>−</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">n-1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.66666em;vertical-align:-0.08333em;"></span><span class="mord mathdefault">n</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span>个盘子看成一个，就相当于有两个盘子。我们的步骤应该是这样。</p><blockquote><ol><li><p>借助C盘，把A柱子上的<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>n</mi><mo>−</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">n-1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.66666em;vertical-align:-0.08333em;"></span><span class="mord mathdefault">n</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span>个盘子全部移动到B盘。</p></li><li><p>将A柱子上第<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">n</span></span></span></span>个盘子，直接移动到C盘。</p></li><li><p>借助A盘，把在B柱子上的<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>n</mi><mo>−</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">n-1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.66666em;vertical-align:-0.08333em;"></span><span class="mord mathdefault">n</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span>个盘子移动到C盘。</p></li></ol></blockquote><p>仔细分析一下上面的三步，是不是有借助某柱把多少个盘子从某柱移动到某柱上，这是啥，这不就是递归函数的定义嘛。所以按照我们定义的功能，将上面三句话写成代码。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//明确函数的定义，第一个变量是盘子的起点，中间的变量是盘子的枢纽站，最后一个变量表示的是盘子的终点</span></span><br><span class="line">TowersOfHanoi(n<span class="number">-1</span>, A, C, B);  </span><br><span class="line">move(n, A, C);</span><br><span class="line">TowersOfHanoi(n<span class="number">-1</span>, B, A, C);</span><br></pre></td></tr></table></figure><p>接下来分析，为什么调用<code>TowersOfHanoi(n-1, A, C, B)</code>就完成了借助C将<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>n</mi><mo>−</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">n-1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.66666em;vertical-align:-0.08333em;"></span><span class="mord mathdefault">n</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span>个盘子从A移动到B了呢？这里的台词是，我们定义的递归函数功能就是这么定义的，不要去想这个具体是怎么实现的，而是直接使用这个结论就行了，此乃编写递归函数的精髓。放弃思考。</p><p>至于<code>move(int n, char from, char to)</code>函数的实现：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">move</span><span class="params">(<span class="keyword">int</span> n, <span class="keyword">char</span> from, <span class="keyword">char</span> to)</span></span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d  %c --&gt;&gt; %c"</span>, n, from, to);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><ul><li><p>完整代码</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">move</span><span class="params">(<span class="keyword">int</span> n, <span class="keyword">char</span> from, <span class="keyword">char</span> to)</span></span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d  %c --&gt;&gt; %c\n"</span>, n, from, to);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//明确函数的定义，第一个变量是盘子的起点，中间的变量是盘子的枢纽站，最后一个变量表示的是盘子的终点</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">TowersOfHanoi</span><span class="params">(<span class="keyword">int</span> n, <span class="keyword">char</span> A, <span class="keyword">char</span> B, <span class="keyword">char</span> C)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(n == <span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        move(<span class="number">1</span>, A, C);</span><br><span class="line">        <span class="keyword">return</span> ;</span><br><span class="line">    &#125;</span><br><span class="line">    TowersOfHanoi(n<span class="number">-1</span>, A, C, B);</span><br><span class="line">    move(n, A, C);</span><br><span class="line">    TowersOfHanoi(n<span class="number">-1</span>, B, A, C);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当<code>n=3</code>时，执行的结果如下：</p><figure class="highlight tex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">1  A --&gt;&gt; C</span><br><span class="line">2  A --&gt;&gt; B</span><br><span class="line">1  C --&gt;&gt; B</span><br><span class="line">3  A --&gt;&gt; C</span><br><span class="line">1  B --&gt;&gt; A</span><br><span class="line">2  B --&gt;&gt; C</span><br><span class="line">1  A --&gt;&gt; C</span><br></pre></td></tr></table></figure></li></ul><h3 id="思考-2"><a class="markdownIt-Anchor" href="#思考-2"></a> 思考</h3><p>对于上面的移动过程，只要我们明确了递归函数的功能，就可以写出更加复杂的代码，比如我们定义移动盘子的流程是这样的。</p><blockquote><ol><li><p>借助C盘，把A柱子上的<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>n</mi><mo>−</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">n-1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.66666em;vertical-align:-0.08333em;"></span><span class="mord mathdefault">n</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span>个盘子全部移动到B盘。</p></li><li><p>将A柱子上第<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">n</span></span></span></span>个盘子，直接移动到C盘。</p></li><li><p>借助C盘，把在B柱子上的<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>n</mi><mo>−</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">n-1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.66666em;vertical-align:-0.08333em;"></span><span class="mord mathdefault">n</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span>个盘子重新移动回到A盘。此时有n-1个盘子在A柱子上，1个盘子在C柱子上。</p></li><li><p>重新借助B，将A柱子上的<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>n</mi><mo>−</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">n-1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.66666em;vertical-align:-0.08333em;"></span><span class="mord mathdefault">n</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span>个盘子移动到C盘。</p></li></ol></blockquote><p>写成代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">TowersOfHanoi(n<span class="number">-1</span>, A, C, B);</span><br><span class="line">move(n, A, C);</span><br><span class="line">TowersOfHanoi(n<span class="number">-1</span>, B, C, A);</span><br><span class="line">TowersOfHanoi(n<span class="number">-1</span>, A, B, C);</span><br></pre></td></tr></table></figure><p>这样的做法虽然移动的步骤增加了，但是还是可以实现功能的，只不过在这里为了让大家体会编写递归函数的功能，就增加了这样一个重复的做法。</p><p>当<code>n=3</code>时，执行的记过如下：</p><figure class="highlight tex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">1  A --&gt;&gt; C</span><br><span class="line">2  A --&gt;&gt; B</span><br><span class="line">1  C --&gt;&gt; A</span><br><span class="line">1  A --&gt;&gt; B</span><br><span class="line">3  A --&gt;&gt; C</span><br><span class="line">1  B --&gt;&gt; C</span><br><span class="line">2  B --&gt;&gt; A</span><br><span class="line">1  C --&gt;&gt; B</span><br><span class="line">1  B --&gt;&gt; A</span><br><span class="line">1  A --&gt;&gt; B</span><br><span class="line">2  A --&gt;&gt; C</span><br><span class="line">1  B --&gt;&gt; A</span><br><span class="line">1  A --&gt;&gt; C</span><br></pre></td></tr></table></figure><p>从执行的结果可以看出，有很多步骤是多余的，但是为了让大家更好的理解递归函数执行的过程，就增加了这个画蛇添足的过程。</p><p>上面的是将<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">n</span></span></span></span>个盘子拆分成<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>n</mi><mo>−</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">n-1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.66666em;vertical-align:-0.08333em;"></span><span class="mord mathdefault">n</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span>和<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>1</mn></mrow><annotation encoding="application/x-tex">1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span>两个部分，如果我们再换一种拆分数据的方式，我们将<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">n</span></span></span></span>个盘子拆分成<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>n</mi><mo>−</mo><mn>2</mn></mrow><annotation encoding="application/x-tex">n-2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.66666em;vertical-align:-0.08333em;"></span><span class="mord mathdefault">n</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">2</span></span></span></span>和<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>2</mn></mrow><annotation encoding="application/x-tex">2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">2</span></span></span></span>，那么递归的过程又是怎么样的呢？这个过程其实还是蛮复杂的，到现在为止，我都没有想到怎么移动才比较好，所以我就把<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">n</span></span></span></span>个汉诺塔拆分成<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>1</mn></mrow><annotation encoding="application/x-tex">1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span>和<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>n</mi><mo>−</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">n-1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.66666em;vertical-align:-0.08333em;"></span><span class="mord mathdefault">n</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span>两个部分，至于其余的拆分方式，我暂时还没想出来。</p><p>至于前面的两道题，我都一步一步改变拆分数据的方式，进而引出迭代的写法，不过至于汉诺塔迭代的写法，我还没有搞清楚<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>n</mi><mo>−</mo><mn>2</mn></mrow><annotation encoding="application/x-tex">n-2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.66666em;vertical-align:-0.08333em;"></span><span class="mord mathdefault">n</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">2</span></span></span></span>和<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>2</mn></mrow><annotation encoding="application/x-tex">2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">2</span></span></span></span>怎么用低柜编写，所以对于迭代写法，我自然写不出来。不过随着深入，我相信我可以把这里补充起来。</p><h1 id="递归函数的退出条件不容小觑"><a class="markdownIt-Anchor" href="#递归函数的退出条件不容小觑"></a> 递归函数的退出条件不容小觑</h1><p>经过了上面一节的训练，我认为你已经搞定了递归三个步骤中的两个步骤，并且掌握了要点，分割数据并且找到层与层之间的关系，却忽略了另外一个问题。函数的递归退出条件，因为一般情况下，这点一般都是很容易看出来。所以这里找两个例题，感受下递归函数的退出条件依然不容小觑。</p><h3 id="104-二叉树的最大深度"><a class="markdownIt-Anchor" href="#104-二叉树的最大深度"></a> <a href="https://leetcode-cn.com/problems/maximum-depth-of-binary-tree/" target="_blank" rel="noopener">104. 二叉树的最大深度</a></h3><p>给定一个二叉树，找出其最大深度。</p><p>二叉树的深度为根节点到最远叶子节点的最长路径上的节点数。</p><p><strong>说明:</strong> 叶子节点是指没有子节点的节点。</p><p><strong>示例：</strong><br />给定二叉树 <code>[3,9,20,null,null,15,7]</code>，</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">  3</span><br><span class="line"> &#x2F; \</span><br><span class="line">9  20</span><br><span class="line">  &#x2F;  \</span><br><span class="line"> 15   7</span><br></pre></td></tr></table></figure><p>返回它的最大深度 3 。</p><p>这是一个树的问题，所以我们采用递归的方式进行求解。</p><ol><li><p>定义递归函数<code>int maxDepth(TreeNode* root)</code>的功能和返回值：计算以<code>root</code>为根的二叉树的高度，并返回。</p></li><li><p>递归函数的退出条件。当<code>root</code>为空的时候，高度为0，写成代码。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(root == <span class="literal">nullptr</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br></pre></td></tr></table></figure></li><li><p>分割数据，找到层与层之间的关系</p><p>想一下，我们拿到一个树的某一个节点的时候，我们能干嘛，无非就是四件事。</p><blockquote><ol><li>啥也不干</li><li>访问左子树</li><li>访问右子树</li><li>取出或者设置该节点的值</li></ol></blockquote><p>所以在这里我们分层的依据很简单，就是访问左子树或者访问右子树。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> left = maxDepth(root-&gt;left);</span><br><span class="line"><span class="keyword">int</span> right = maxDepth(root-&gt;right);</span><br></pre></td></tr></table></figure><p>用递归函数重新作用了左子树和右子树，这个函数的返回结果就是左子树的告诉或者是右子树的高度，因为我们定义的函数的功能就是计算以<code>root</code>为根的树的高度，至于为什么这个函数可以计算，请放弃。我们要在的到了左子树和右子树高度的基础上，计算<code>root</code>节点的高度，所以以<code>root</code>为根的树的高度为<code>1+ max(left, right)</code>。</p><p>写成代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">maxDepth</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!root)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>+max(maxDepth(root-&gt;left), maxDepth(root-&gt;right));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个问题很很简单的，我们来看下另外一个问题。</p></li></ol><h3 id="111-二叉树的最小深度"><a class="markdownIt-Anchor" href="#111-二叉树的最小深度"></a> <a href="https://leetcode-cn.com/problems/minimum-depth-of-binary-tree/" target="_blank" rel="noopener">111. 二叉树的最小深度</a></h3><p>给定一个二叉树，找出其最小深度。</p><p>最小深度是从根节点到最近叶子节点的最短路径上的节点数量。</p><p>说明: 叶子节点是指没有子节点的节点。</p><p>示例:</p><p>给定二叉树 [3,9,20,null,null,15,7],</p><pre><code>    3   / \  9  20    /  \   15   7</code></pre><p>返回它的最小深度  2.</p><p>这题一看，还是递归求解，按照递归的三个步骤：</p><ol><li><p>定义函数<code>int minDepth(TreeNode* root)</code>为计算以<code>root</code>为根的二叉树的最小深度。</p></li><li><p>递归函数的返回值，如果没有节点，返回0。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(root == <span class="literal">nullptr</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br></pre></td></tr></table></figure></li><li><p>分割数据，并且找到层与层之间的关系</p><p>这个很简单啊，还是仿照上题的做法，写下了如下的代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> left = minDepth(root-&gt;left);</span><br><span class="line"><span class="keyword">int</span> right = minDepth(root-&gt;right);</span><br><span class="line"><span class="keyword">return</span> <span class="number">1</span> + min(left, right);</span><br></pre></td></tr></table></figure><p>至于其中的道理我就不解释了，准备提交，一个错误就返回。</p><p>当测试用例为如下结构时，应该返回2</p><p><img src="/" alt="" / class="lazyload" data-src="https://cdn.jsdelivr.net/gh/jackymxp/image-bed/leetcode/20200421100756.png"></p><p>这时候不得不让我头皮发麻，这个错在了哪里呢，我们回头再看下题目。我们突然发现了这样一句话，从根节点到最近的叶子节点的路径。而在我们的代码中，根本就没有体现出叶子节点这一概念。问题就出在了当右子树或者左子树为空的情况下，所以我们再次思考递归的退出条件是什么？</p><p>当左子树为空的时候，应该返回的是右子树的最小高度加1</p><p>当右子树为空的时候，应该返回的是左子树的最小高度加1</p><p>当左右子树都不为空的时候，应当返回左右子树最小高度的最小值。</p><p>所以，将上述递归退出条件写成代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(root-&gt;right == <span class="literal">nullptr</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span> + minDepth(root-&gt;left);</span><br><span class="line"><span class="keyword">if</span>(root-&gt;left == <span class="literal">nullptr</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span> + minDepth(root-&gt;right);</span><br></pre></td></tr></table></figure></li></ol><ul><li><p>完成代码</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">minDepth</span><span class="params">(TreeNode* root)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(root == <span class="literal">nullptr</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="comment">//叶子节点</span></span><br><span class="line">    <span class="keyword">if</span>(root-&gt;left == <span class="literal">nullptr</span> &amp;&amp; root-&gt;rigth == <span class="literal">nullptr</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span>(root-&gt;left == <span class="literal">nullptr</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span> + minDepth(root-&gt;right);</span><br><span class="line">    <span class="keyword">if</span>(root-&gt;right == <span class="literal">nullptr</span>)</span><br><span class="line">        <span class="keyword">return</span>  <span class="number">1</span> + minDepth(root-&gt;left);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>+min(minDepth(root-&gt;left), minDepth(root-&gt;right));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h4 id="思考-3"><a class="markdownIt-Anchor" href="#思考-3"></a> 思考</h4><p>上面的两个题，其核心代码都是相同的结构，但是不同的地方在于其函数的退出条件。通过这两个例子，想说明的是，有时候递归函数的退出条件并不是我们想象的那样简单，还需要仔细的加以思考，这样才能写出完整的代码。</p><h1 id="总结"><a class="markdownIt-Anchor" href="#总结"></a> 总结</h1><p>磨磨唧唧写了这么多，也不知道我自己写没写清楚关于如何编写递归函数。在这里重新温习一下递归的要点，如何将数据分层，并找到层与层之间的关系。在缩放函数规模的时候，千万不要陷入到递归函数内部去，及时止损，及时放弃，才能清醒的写出递归的代码。最后想起苏轼的一句诗，我觉得形容递归也很对。</p><blockquote><p>不识庐山真面目</p><p>只缘身在此山中</p></blockquote><p>对于如何分割数据，其实没有固定的套路，但是不同的分割数据的方式，对应的函数的退出条件也是不同的，这一点要考虑清楚。</p><p>当然对于低柜函数的退出条件也是不能小看的，在特殊情况下，一定要好好斟酌。</p><p>最后，上面写了三点，如何编写递归函数的核心，还有最后一点没有交代清楚。那么在这里放出最重要的一点，如果你看懂了如何编写递归，那么请关注我的公众号，以满足我的虚荣心，鼓励我做出更多作品。</p><p>如果你没有看懂递归，在我的公众号中，还有更多和递归相关的话题，包括专门使用递归解决<code>leetcode</code>上的有关链表的专题，树的专题，甚至是从递归到动态规划的专题。让你一次，弄懂递归。</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>test</title>
      <link href="/2020/03/21/test/"/>
      <url>/2020/03/21/test/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><h2 id="测试标题"><a class="markdownIt-Anchor" href="#测试标题"></a> 测试标题</h2><h2 id="测试代码段"><a class="markdownIt-Anchor" href="#测试代码段"></a> 测试代码段</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"hello world new theme !"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="测试引用"><a class="markdownIt-Anchor" href="#测试引用"></a> 测试引用</h2><blockquote><p>fdifhdfd<br />dfdfdf</p></blockquote><h2 id="测试数学公式"><a class="markdownIt-Anchor" href="#测试数学公式"></a> 测试数学公式</h2><p>爱因斯坦的质能方程： <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>E</mi><mo>=</mo><mi>m</mi><msup><mi>c</mi><mn>2</mn></msup></mrow><annotation encoding="application/x-tex">E=mc^2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.05764em;">E</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.8141079999999999em;vertical-align:0em;"></span><span class="mord mathdefault">m</span><span class="mord"><span class="mord mathdefault">c</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span></span></span></span></p><p><span class="katex"><span class="katex-mathml"><math><semantics><mtable rowspacing="0.24999999999999992em" columnalign="center" columnspacing="1em"><mtr><mtd><mstyle scriptlevel="0" displaystyle="true"><mrow><mi>a</mi><mo>=</mo><mi>b</mi><mi mathvariant="normal">∣</mi><mi mathvariant="normal">∣</mi><mi>e</mi><mo>=</mo><mi>b</mi><mo>+</mo><mi>c</mi></mrow></mstyle></mtd></mtr></mtable><annotation encoding="application/x-tex">\begin{gathered} a=b || e=b+c \end{gathered}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.5000000000000002em;vertical-align:-0.5000000000000002em;"></span><span class="mord"><span class="mtable"><span class="col-align-c"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1em;"><span style="top:-3.16em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathdefault">a</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mord mathdefault">b</span><span class="mord">∣</span><span class="mord">∣</span><span class="mord mathdefault">e</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mord mathdefault">b</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mord mathdefault">c</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.5000000000000002em;"><span></span></span></span></span></span></span></span></span></span></span></p><h2 id="测试note"><a class="markdownIt-Anchor" href="#测试note"></a> 测试note</h2><div class="note success">            <h4 id="success-header"><a class="markdownIt-Anchor" href="#success-header"></a> Success Header</h4><p><strong>Welcome</strong> to <a href="https://hexo.io" target="_blank" rel="noopener">Hexo!</a></p>          </div><p><a href="https://theme-next.org/docs/tag-plugins/note" target="_blank" rel="noopener">具体用法</a></p><h2 id="流程图测试"><a class="markdownIt-Anchor" href="#流程图测试"></a> 流程图测试</h2><div class="mermaid">           pie     title Key elements in Product X     "Calcium" : 42.96     "Potassium" : 50.05     "Magnesium" : 10.01     "Iron" : 5           </div><p><a href="https://mermaid-js.github.io/mermaid/#/" target="_blank" rel="noopener">具体文档</a></p>]]></content>
      
      
      <categories>
          
          <category> 测试 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 测试博客 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>一网打尽树专题</title>
      <link href="/2020/03/15/fucking-leetcode/02-%E6%A0%91%E4%B8%93%E9%A2%98/"/>
      <url>/2020/03/15/fucking-leetcode/02-%E6%A0%91%E4%B8%93%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><p>上一篇博客中，使用了递归解答了链表的相关问题。</p><p><img src="/" alt="" / class="lazyload" data-src="https://cdn.jsdelivr.net/gh/jackymxp/image-bed/leetcode/00831rSTly1gcvfra4larj30u017de1t-20200322192003869.jpg"></p><h1 id="解决链表问题的一般技巧"><a class="markdownIt-Anchor" href="#解决链表问题的一般技巧"></a> 解决链表问题的一般技巧</h1><p>链表是通过带有指针域的节点相互连接成的一种线性结构，由于链表的这种天然的特性，一般都是通过修改链表中节点的指向完成链表的<strong>增删改查</strong>问题。修改链表节点的指针指向一般有非递归方法和递归法。</p><h2 id="1-非递归法"><a class="markdownIt-Anchor" href="#1-非递归法"></a> 1. 非递归法</h2><p><strong>通过修改指针的方式一般有以下几种技巧</strong>：</p><ul><li><p>设置虚拟头节点，但在函数最后返回之前，记得释放内存。</p></li><li><p>使用快慢指针，一般用于定位到中间节点或者判断链表是否有环问题。</p></li></ul><h2 id="2-递归法"><a class="markdownIt-Anchor" href="#2-递归法"></a> 2. 递归法</h2><ul><li><p><strong>递归法的原理</strong></p><p>由于链表是通过指针域连接的线性结构，所以可以把一个完整的链表看成若干个结构相同但是长更短的链表构成，这就相当于在递归函数中缩减了函数的规模。</p><p>当链表的长度短到一定的程度，就相当于递归函数的退出条件。</p><p>当对更短的节点修改了指针后，链表的局部达到了期望的结构。其余的链表也使用同样的方法即调用同一个函数来修改节点的指向，这样就完成了整体链表结构的修改。</p><p>这就是通过递归修改链表的原理，通过这个原理总结了编写递归函数的</p></li><li><p><strong>编写递归函数的三个步骤：</strong></p><ol><li>定义了一个递归函数<code>fun(ListNode*)</code>，一定要<strong>明确递归函数的功能，以及递归函数的返回值</strong>。这样是当传入头节点<code>head</code>并且执行完<code>fun(head)</code>函数后，链表的结构就应该改变成希望的样子。这个就是递归的功能。</li><li><strong>明确递归函数的退出条件</strong>。否则递归函数找不到出口，就一直递归下去，爆栈。</li><li>将链表拆成若干部分，一部分的头节点是<code>head</code>，另外一部分的头节点是<code>newHead</code>，<strong>根据定义的函数的功能，推理当执行完<code>fun(newHead)</code>的时候，链表变成了什么样子，这时<code>newHead</code>部分已经变成我们期望的链表结构。接下来就是应该如何修改<code>head</code>为头节点的链表的的指针，使得整个链表的结构和期望的结构相同</strong>。</li></ol><p><strong>切记千万不要进入递归函数中探索太多的细节</strong>，人脑的栈太小，探索不了太多细节就乱了。实在想探索递归函数运行的细节，就在纸上画图，画出每层递归函数的入口参数及返回值。</p></li></ul><p>好了，给出我的心得之后，但是这些就像是数学公式一样，如果不通过例题是很难知道怎么用这些公式一样。所以接下来就通过一些例题来体会一下如何写好递归函数。</p><h1 id="翻转链表题"><a class="markdownIt-Anchor" href="#翻转链表题"></a> 翻转链表题</h1><h2 id="206-反转链表"><a class="markdownIt-Anchor" href="#206-反转链表"></a> <a href="https://leetcode-cn.com/problems/reverse-linked-list/" target="_blank" rel="noopener">206. 反转链表</a></h2><ol><li><p><strong>定义递归函数<code>ListNode* reverseList(ListNode* head)</code>功能以及返回值</strong>：</p><p>定义功能为：翻转以<code>head</code>为头节点的链表，并返回翻转后的链表的头节点。</p><p>根据定义的递归函数功能，首先将<code>reverseList</code>的作用范围放在整个链表，图中有绿色的阴影部分代表递归函数<code>reverseList</code>的作用范围，也就是将<code>head</code>作为参数传递给<code>reverseList(head)</code>作用的范围。</p><p><img src="/" alt="" / class="lazyload" data-src="https://tva1.sinaimg.cn/large/00831rSTly1gd2x4tff4nj318e0620u7.jpg"></p><p>当把<code>head</code>作为参数传递给递归函数<code>reverseList</code>作用后，根据定义的递归函数功能，这个函数就完成了整个链表的翻转，也就是期望的最终答案。</p><p><img src="/" alt="" / class="lazyload" data-src="https://tva1.sinaimg.cn/large/00831rSTly1gd2x4twjlmj315604kmxx.jpg"></p></li><li><p><strong>寻找递归函数退出条件和返回值</strong></p><p>当链表中只有一个节点或者没有节点的时候，不需要任何反转，就可以直接返回。</p> <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(!head || !head-&gt;next)</span><br><span class="line">    <span class="keyword">return</span> head;</span><br></pre></td></tr></table></figure></li><li><p><strong>缩小递归函数的规模，寻求层与层之间的关系</strong></p><p>为了缩小递归函数的规模，所以要将链表分成了两个部分，由于是每一个节点都要进行反转，所以要将链表分成长度分别为<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>1</mn></mrow><annotation encoding="application/x-tex">1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span>和<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>k</mi><mo>−</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">k-1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.77777em;vertical-align:-0.08333em;"></span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span>的两个链表，其中<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>k</mi></mrow><annotation encoding="application/x-tex">k</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span></span></span></span>是原链表的长度。两部分链表的头节点分别为<code>head</code>和<code>newHead</code>。当缩小递归函数的范围的时候，即将<code>newHead</code>作为参数传入到<code>reverseList</code>函数中，其中递归函数的作用范围表示成图。</p><p><img src="/" alt="" / class="lazyload" data-src="https://cdn.jsdelivr.net/gh/jackymxp/image-bed/leetcode/20200322101626.png"></p><p>当递归函数<code>reverseList(newHead)</code>执行完成后，根据递归函数的功能，这样就完成了长度为<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>k</mi><mo>−</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">k-1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.77777em;vertical-align:-0.08333em;"></span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span>部分链表的反转，除头节点外的其余节点都符合期望的结构。整个链表变成如下这个样子。</p><p><img src="/" alt="" / class="lazyload" data-src="https://cdn.jsdelivr.net/gh/jackymxp/image-bed/leetcode/20200322102043.png"></p><p>写成代码的形式：</p> <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ListNode* newHead = next-&gt;next;</span><br><span class="line">head-&gt;next = <span class="literal">nullptr</span>; <span class="comment">//将链表分成两个部分</span></span><br><span class="line">ListNode* retHead = reverseList(newHead);</span><br></pre></td></tr></table></figure><p>通过观察发现，只要在修改<code>head</code>和<code>newHead</code>的指针就完成了这个链表的反转。</p><p><strong>最后不要忘记让头节点<code>head-&gt;next</code>指向<code>nullptr</code>，否则递归函数找不到空节点，递归超时。这样就完成了翻转</strong>。写成代码如下：</p> <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">newHead-&gt;next = head;</span><br><span class="line">head-&gt;next = <span class="literal">nullptr</span>;</span><br></pre></td></tr></table></figure><p>当然除了上面一个一个减少递归的规模的话，我们还可以一半一半的减少，比如，我们每次翻转链表的一半，最后再将两部分合并起来。</p><p>问题的关键，我们如何把一个链表拆成两部分，上面的策略是将链表拆成了长度为<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>1</mn></mrow><annotation encoding="application/x-tex">1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span>和长度为<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>k</mi><mo>−</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">k-1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.77777em;vertical-align:-0.08333em;"></span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span>两个部分，现在将链表拆成长度相等的两个部分，所以问题是，如何定位到链表的中间节点，这里使用快慢指针定位到链表的中间节点。</p> <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">ListNode* fast = head;</span><br><span class="line">ListNode* slow = head;</span><br><span class="line">ListNode* mid = <span class="literal">NULL</span>;</span><br><span class="line"><span class="keyword">while</span>(fast &amp;&amp; fast-&gt;next)</span><br><span class="line">&#123;</span><br><span class="line">    fast = fast-&gt;next-&gt;next;</span><br><span class="line">    mid = slow;</span><br><span class="line">    slow = slow-&gt;next;</span><br><span class="line">&#125;</span><br><span class="line">mid-&gt;next = <span class="literal">NULL</span>;</span><br></pre></td></tr></table></figure><p>当定位到中间节点后，我们对每一部分都进行翻转</p><p><img src="/" alt="" / class="lazyload" data-src="https://cdn.jsdelivr.net/gh/jackymxp/image-bed/leetcode/20200403182532.png"></p><p>根据递归函数的功能，当执行完<code>reverseList(head)</code>和<code>reverseList(slow)</code>之后，每一部分都进行了翻转。</p><p><img src="/" alt="" / class="lazyload" data-src="https://cdn.jsdelivr.net/gh/jackymxp/image-bed/leetcode/20200403183121.png"></p><p>这时候后只要改变<code>slow-&gt;next = tmp</code>就可以。最后返回<code>tmp2</code>。</p> <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ListNode* tmp = reverseList(head);</span><br><span class="line">ListNode* retNode = reverseList(slow);</span><br><span class="line">slow-&gt;next = tmp;</span><br></pre></td></tr></table></figure></li><li><p><strong>递归代码</strong></p> <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">reverseList</span><span class="params">(ListNode* head)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//当链表中只有一个节点或者没有节点的时候，直接退出</span></span><br><span class="line">        <span class="keyword">if</span>(!head || !head-&gt;next)</span><br><span class="line">            <span class="keyword">return</span> head;</span><br><span class="line">        <span class="comment">//分成两个部分</span></span><br><span class="line">        ListNode* newHead = head-&gt;next;</span><br><span class="line">        head-&gt;next = <span class="literal">nullptr</span>;</span><br><span class="line">        <span class="comment">//完成 k - 1 部分的翻转</span></span><br><span class="line">        ListNode* retHead = reverseList(newHead);</span><br><span class="line">        <span class="comment">//修改指针，是最后一部分完成翻转</span></span><br><span class="line">        newHead-&gt;next = head;</span><br><span class="line">        head-&gt;next = <span class="literal">nullptr</span>;</span><br><span class="line">        <span class="keyword">return</span> retHead;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li><li><p><strong>迭代代码</strong></p> <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">reverseList</span><span class="params">(ListNode* head)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!head || !head-&gt;next)</span><br><span class="line">            <span class="keyword">return</span> head;</span><br><span class="line">        ListNode* pre = <span class="literal">nullptr</span>;</span><br><span class="line">        ListNode* cur = head;  <span class="comment">//pre -&gt; cur -&gt; next   ===&gt;&gt;&gt;   pre &lt;- cur &lt;- next</span></span><br><span class="line">        <span class="keyword">while</span>(cur)</span><br><span class="line">        &#123;</span><br><span class="line">            ListNode* next = cur-&gt;next; <span class="comment">//保存下一个节点</span></span><br><span class="line">            cur-&gt;next = pre; <span class="comment">//修改next指针是其指向 pre</span></span><br><span class="line">            <span class="comment">//pre和next都向后移动一位</span></span><br><span class="line">            pre = cur;  </span><br><span class="line">            cur = next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> pre;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ol><hr /><h2 id="24-两两交换链表中的节点"><a class="markdownIt-Anchor" href="#24-两两交换链表中的节点"></a> <a href="https://leetcode-cn.com/problems/swap-nodes-in-pairs/" target="_blank" rel="noopener">24. 两两交换链表中的节点</a></h2><p>还是按照递归的套路，分三步。</p><ol><li><p><strong>定义递归函数<code>ListNode* swapPairs(ListNode* head)</code>功能以及返回值</strong></p><p>定义递归函数功能：每两个翻转链表中的节点，并将翻转后新的链表节点作为返回值。</p><p>根据定义的递归函数功能，首先将<code>swapPairs</code>的作用范围放在整个链表，图中有绿色的阴影部分代表递归函数<code>swapPairs</code>的作用范围，也就是将就是将<code>head</code>作为参数传递给<code>swapPairs(head)</code>作用的范围。</p><p><img src="/" alt="" / class="lazyload" data-src="https://tva1.sinaimg.cn/large/00831rSTly1gcvk3rsggjj318e06imxj.jpg"></p><p>当把<code>head</code>作为参数传递给递归函数<code>swapPairs</code>作用后，根据定义的递归函数功能，这个函数就完成<strong>两两交换其中相邻的节点</strong>，并返回了交换后的链表的头节点<code>retHead</code>。</p><p><img src="/" alt="" / class="lazyload" data-src="https://cdn.jsdelivr.net/gh/jackymxp/image-bed/leetcode/20200322105029.png"></p></li><li><p><strong>寻找递归函数退出条件和返回值</strong></p><p>当链表中只有一个节点或者没有节点的时候，不需要任何反转，就可以直接返回。</p> <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(head == <span class="literal">nullptr</span> || head-&gt;next == <span class="literal">nullptr</span>)</span><br><span class="line">    <span class="keyword">return</span> head;</span><br></pre></td></tr></table></figure></li><li><p><strong>缩小递归函数的规模，寻求层与层之间的关系</strong></p><p>为了缩小递归函数的规模，所以要将链表分成了两个部分，由于是每一个节点都要进行反转，所以要将链表分成长度分别为<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>2</mn></mrow><annotation encoding="application/x-tex">2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">2</span></span></span></span>和<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>k</mi><mo>−</mo><mn>2</mn></mrow><annotation encoding="application/x-tex">k-2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.77777em;vertical-align:-0.08333em;"></span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">2</span></span></span></span>的两个链表，其中<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>k</mi></mrow><annotation encoding="application/x-tex">k</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span></span></span></span>是原链表的长度。两部分链表的头节点分别为<code>head</code>和<code>newHead</code>。当缩小递归函数的范围的时候，即将<code>newHead</code>作为参数传入到<code>swapPairs</code>函数中，其中递归函数的作用范围表示成图。</p><p><img src="/" alt="" / class="lazyload" data-src="https://cdn.jsdelivr.net/gh/jackymxp/image-bed/leetcode/20200322105844.png"></p><p>当递归函数<code>swapPairs(newHead)</code>执行完成后，根据递归函数的功能，除第一个和第二个节点没有符合期望的结构，其余节点都符合期望的结构。整个链表变成如下这个样子。</p><p><img src="/" alt="image-20200322110545833" / class="lazyload" data-src="https://tva1.sinaimg.cn/large/00831rSTly1gd2kg8bafij31100803za.jpg"></p><p>写成代码的形式：</p> <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//将链表分为两个部分</span></span><br><span class="line">ListNode* newHead = head-&gt;next-&gt;next;</span><br><span class="line">head-&gt;next-&gt;next = <span class="literal">nullptr</span>;</span><br><span class="line"><span class="comment">//递归反转长度为 k - 2 的链表部分</span></span><br><span class="line">ListNode* retNode = swapPairs(newHead);</span><br></pre></td></tr></table></figure><p>最后和预期的结构相对比，只要修改<code>head</code>、<code>newHead</code>的指针域，即可完成整个链表的两两节点的交换，写成代码：</p> <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//对照图片，完成长度为 2 的链表的节点交换</span></span><br><span class="line">ListNode* retHead = head-&gt;next;</span><br><span class="line">retHead-&gt;next = head;</span><br><span class="line">head-&gt;next = retNode;</span><br><span class="line"><span class="keyword">return</span> retHead;</span><br></pre></td></tr></table></figure></li><li><p><strong>递归代码</strong></p> <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">swapPairs</span><span class="params">(ListNode* head)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//递归退出条件，只有一个节点，或者没有节点的时候</span></span><br><span class="line">        <span class="keyword">if</span>(!head || !head-&gt;next)</span><br><span class="line">            <span class="keyword">return</span> head;</span><br><span class="line">        <span class="comment">//将链表分为两个部分</span></span><br><span class="line">        ListNode* newHead = head-&gt;next-&gt;next;</span><br><span class="line">        head-&gt;next-&gt;next = <span class="literal">nullptr</span>;</span><br><span class="line">        <span class="comment">//递归反转长度为 k - 2 的链表部分</span></span><br><span class="line">        ListNode* retNode = swapPairs(newHead);</span><br><span class="line">        <span class="comment">//通过修改长度为2部分链表的指针，完成这个链表的翻转</span></span><br><span class="line">        ListNode* retHead = head-&gt;next;</span><br><span class="line">        retHead-&gt;next = head;</span><br><span class="line">        head-&gt;next = retNode;</span><br><span class="line">        <span class="keyword">return</span> retHead;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li><li><p><strong>迭代代码</strong></p> <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">swapPairs</span><span class="params">(ListNode* head)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!head || !head-&gt;next)</span><br><span class="line">            <span class="keyword">return</span> head;</span><br><span class="line">        ListNode *first = head;</span><br><span class="line">        ListNode *second = head-&gt;next;</span><br><span class="line">        <span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">            ListNode *third = second-&gt;next;</span><br><span class="line">            <span class="comment">//交换</span></span><br><span class="line">            swap(second-&gt;val,first-&gt;val);</span><br><span class="line">            <span class="keyword">if</span>(!third || !third-&gt;next)<span class="keyword">return</span> head;</span><br><span class="line">            <span class="comment">//向前前进两步</span></span><br><span class="line">            first = third;</span><br><span class="line">            second = third-&gt;next;</span><br><span class="line">            third = third-&gt;next-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ol><hr /><h2 id="25-k-个一组翻转链表"><a class="markdownIt-Anchor" href="#25-k-个一组翻转链表"></a> <a href="https://leetcode-cn.com/problems/reverse-nodes-in-k-group/" target="_blank" rel="noopener">25. K 个一组翻转链表</a></h2><p>这道题在<code>leetcode</code>中被定义为难题，但是有前面的基础，当<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>k</mi><mo>=</mo><mn>2</mn></mrow><annotation encoding="application/x-tex">k=2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">2</span></span></span></span>的时候，就是<a href="https://leetcode-cn.com/problems/swap-nodes-in-pairs/" target="_blank" rel="noopener">两两交换链表中的节点</a>题；当<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>k</mi></mrow><annotation encoding="application/x-tex">k</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span></span></span></span>等于链表长度时，就是<a href="https://leetcode-cn.com/problems/reverse-linked-list/" target="_blank" rel="noopener">反转链表</a>题，所以做这个题就不是很难了，只需要做一小部分的改动就可以。下面根据递归套路的三个步骤，完成这个题。</p><ol><li><p><strong>定义递归函数<code>ListNode* reverseKGroup(ListNode* head, int k)</code>功能以及返回值</strong></p><p>定义递归函数功能：在链表中，每<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>k</mi></mrow><annotation encoding="application/x-tex">k</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span></span></span></span>个节点翻转一次，并将新的链表节点作为返回值。</p><p>根据定义的递归函数功能，首先将<code>reverseKGroup</code>的作用范围放在整个链表，图中有绿色的阴影部分代表递归函数<code>reverseKGroup</code>的作用范围，也就是将<code>head</code>作为参数传递给<code>reverseKGroup(head)</code>作用的范围。</p><p><img src="/" alt="" / class="lazyload" data-src="https://cdn.jsdelivr.net/gh/jackymxp/image-bed/leetcode/20200322120919.png"></p><p>当把<code>head</code>作为参数传递给递归函数<code>reverseKGroup</code>作用后，根据定义的递归函数功能，这个函数就完成以<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>k</mi></mrow><annotation encoding="application/x-tex">k</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span></span></span></span>个为一组进行翻转链表，并返回翻转后的链表头节点。假设这里<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>k</mi><mo>=</mo><mn>3</mn></mrow><annotation encoding="application/x-tex">k = 3</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">3</span></span></span></span>。</p><p><img src="/" alt="" / class="lazyload" data-src="https://cdn.jsdelivr.net/gh/jackymxp/image-bed/leetcode/20200322120958.png"></p></li><li><p><strong>寻找递归函数退出条件和返回值</strong></p><p>当链表中的节点的个数小于<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>k</mi></mrow><annotation encoding="application/x-tex">k</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span></span></span></span>的时候，不够一组，可以不需要做任何的翻转操作直接返回。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(NodeNumLessK(head, k) == <span class="literal">true</span>)</span><br><span class="line">    <span class="keyword">return</span> head;</span><br></pre></td></tr></table></figure></li><li><p><strong>缩小递归函数的规模，寻求层与层之间的关系</strong></p><p>为了缩小递归函数的规模，所以要将链表分成了两个部分，由于是每<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>k</mi></mrow><annotation encoding="application/x-tex">k</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span></span></span></span>节点反转，所以将链表分成长度分别为<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>k</mi></mrow><annotation encoding="application/x-tex">k</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span></span></span></span>和<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>n</mi><mo>−</mo><mi>k</mi></mrow><annotation encoding="application/x-tex">n-k</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.66666em;vertical-align:-0.08333em;"></span><span class="mord mathdefault">n</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span></span></span></span>的两个链表，其中<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">n</span></span></span></span>是原链表的长度。两部分链表的头节点分别为<code>head</code>和<code>newHead</code>。当缩小递归函数的范围的时候，即将<code>newHead</code>作为参数传入到<code>reverseKGroup</code>函数中，其中递归函数的作用范围表示成图。</p><p><img src="/" alt="" / class="lazyload" data-src="https://cdn.jsdelivr.net/gh/jackymxp/image-bed/leetcode/20200322121211.png"></p><p>当递归函数<code>reverseKGroup(newHead)</code>执行完成后，根据递归函数的功能，除前<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>k</mi></mrow><annotation encoding="application/x-tex">k</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span></span></span></span>个链表没有符合期望的结构，其余节点都符合期望的结构。整个链表变成如下这个样子。</p><p><img src="/" alt="image-20200322121314111" / class="lazyload" data-src="https://tva1.sinaimg.cn/large/00831rSTly1gd2x4ueqt7j31cm07o75j.jpg"></p><p>写成代码的形式：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//定位到第 k 个节点</span></span><br><span class="line">ListNode* newHead = head;</span><br><span class="line">ListNode* retNode;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; k; i++)&#123;</span><br><span class="line">    retNode = newHead;</span><br><span class="line">    newHead = newHead-&gt;next;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//将链表分成两个部分</span></span><br><span class="line">retNode-&gt;next = <span class="literal">nullptr</span>;</span><br><span class="line"><span class="comment">//递归反转长度为 n - k 的链表部分</span></span><br><span class="line">ListNode* retHead = reverseKGroup(newHead, k);</span><br></pre></td></tr></table></figure><p>最后和预期的结构相对比，只要翻转前<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>k</mi></mrow><annotation encoding="application/x-tex">k</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span></span></span></span>个链表的节点，再改变指针的指向就完成了所有节点按照<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>k</mi></mrow><annotation encoding="application/x-tex">k</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span></span></span></span>个一组翻转链表。写成代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">reverseList(head);</span><br><span class="line">    <span class="comment">//将第一部分和第二部分连接起来</span></span><br><span class="line">    head-&gt;next = retHead;</span><br><span class="line">    <span class="keyword">return</span> retNode;</span><br></pre></td></tr></table></figure></li><li><p><strong>递归代码</strong></p><p><strong>PS:</strong> 这段代码虽然有近<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>50</mn></mrow><annotation encoding="application/x-tex">50</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">5</span><span class="mord">0</span></span></span></span>行，但是抛出递归退出条件的判断和前面遇到的翻转链表的代码，当然还有很多注释之外，核心的代码不到<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>10</mn></mrow><annotation encoding="application/x-tex">10</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span><span class="mord">0</span></span></span></span>行，所以结合前面的图和注释很容易理解。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">NodeNumLessK</span><span class="params">(ListNode* p, <span class="keyword">int</span> k)</span></span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; k; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(p == <span class="literal">nullptr</span>)</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            p = p-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">ListNode* <span class="title">reverseList</span><span class="params">(ListNode* head)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//当只有一个节点或者没有节点，递归退出条件</span></span><br><span class="line">        <span class="keyword">if</span>(!head || !head-&gt;next)</span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line">        <span class="comment">//缩小递归规模</span></span><br><span class="line">        ListNode* newHead = reverseList(head-&gt;next);</span><br><span class="line">        <span class="comment">//改变层与层之间的关系</span></span><br><span class="line">        <span class="comment">//当head-&gt;next部分完成反转后，改变指针指向，完成整个链表的翻转</span></span><br><span class="line">        head-&gt;next-&gt;next = head;</span><br><span class="line">        <span class="comment">//将head-&gt;next置空，否则找不到空节点，递归超时</span></span><br><span class="line">        head-&gt;next = <span class="literal">nullptr</span>;</span><br><span class="line">        <span class="keyword">return</span> newHead;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">ListNode* <span class="title">reverseKGroup</span><span class="params">(ListNode* head, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//当链表节点小于k的时候，直接退出</span></span><br><span class="line">        <span class="keyword">if</span>(NodeNumLessK(head, k))</span><br><span class="line">            <span class="keyword">return</span> head;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//定位到第 k 个节点</span></span><br><span class="line">        ListNode* newHead = head;</span><br><span class="line">        ListNode* retNode;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; k; i++)&#123;</span><br><span class="line">            retNode = newHead;</span><br><span class="line">            newHead = newHead-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//将链表分成两个部分</span></span><br><span class="line">        retNode-&gt;next = <span class="literal">nullptr</span>;</span><br><span class="line">        <span class="comment">//递归反转长度为 n - k 的链表部分</span></span><br><span class="line">        ListNode* retHead = reverseKGroup(newHead, k);</span><br><span class="line"></span><br><span class="line">        reverseList(head);</span><br><span class="line">        <span class="comment">//将第一部分和第二部分连接起来</span></span><br><span class="line">        head-&gt;next = retHead;</span><br><span class="line">        <span class="keyword">return</span> retNode;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ol><hr /><h1 id="合并链表题"><a class="markdownIt-Anchor" href="#合并链表题"></a> 合并链表题</h1><p>翻转链表类型的题目，涉及的都是直接修改链表的指针指向，在合并链表的过程中，涉及的还是修改指针的指向，唯一不同的是，链表翻转是一个链表的，而合并链表的题可能涉及到多个链表，但是也只是单纯的改变指针指。</p><h2 id="21-合并两个有序链表"><a class="markdownIt-Anchor" href="#21-合并两个有序链表"></a> <a href="https://leetcode-cn.com/problems/merge-two-sorted-lists/" target="_blank" rel="noopener">21. 合并两个有序链表</a></h2><p>还是按照递归的三个步骤</p><ol><li><p><strong>定义递归函数<code>ListNode* mergeTwoLists(ListNode* l1, ListNode* l2)</code>功能以及返回值</strong></p><p>合并两个已经排序的链表，并且返回排序后链表的头节点。</p><p>根据这个定义，当传入两个如下所示的链表，应该返回的是这样的链表。</p><p><img src="/" alt="" / class="lazyload" data-src="https://tva1.sinaimg.cn/large/00831rSTly1gcwo90kk3fj31ly0pqmz2.jpg"></p></li><li><p><strong>寻找递归函数退出条件和返回值</strong></p><p>当两个链表中有一个链表为空的时候，不管另外一个链表是否为空，都直接返回另外一个链表。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(!l1 || !l2)</span><br><span class="line">    <span class="keyword">return</span> l1 ? l1 : l2;</span><br></pre></td></tr></table></figure></li><li><p><strong>缩小递归函数的规模，寻求层与层之间的关系</strong></p><p>为了缩小递归函数的规模，所以要将链表分成了两个部分，由于是合并链表，所以将链表分成已排序的和未排序的链表两个部分。合并的过程从两个链表的头节点开始，<code>p1</code>的头节点值小于<code>p2</code>的值，所以<code>p1</code>的头节点就是合并后的链表的头节点。 将<code>p1</code>节点单独拿出来，并且保存<code>p1</code>节点的下一个节点为<code>pn</code>。此时<code>p1</code>节点已经是有序的。</p><p>继续合并链表中的剩余节点，发现<code>pn</code>和<code>p2</code>依然是一个合并有序链表的过程，还是依然比较两个头节点的值，所以这个过程依然可以调用<code>mergeTwoLists(pn, p2)</code>完成链表剩余部分的排序。</p><p><img src="/" alt="" / class="lazyload" data-src="https://tva1.sinaimg.cn/large/00831rSTly1gcwoqo4jfvj312u0k0my8.jpg"></p><p>当递归函数 <code>mergeTwoLists(pn, p2)</code> 执行完成后，根据递归函数的功能，<code>pn</code>和<code>p2</code>链表已经形成一个有序的链表，所以整个链表变成如下这个样子。</p><p>将链表的两部分连接起来，所以将<code>p1-&gt;next</code>指向<code>retNode</code>。</p><p><img src="/" alt="" / class="lazyload" data-src="https://cdn.jsdelivr.net/gh/jackymxp/image-bed/leetcode/20200322203408.png"></p><p>将上述过程写成代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(p1-&gt;val &lt; p2-&gt;val)</span><br><span class="line">&#123;</span><br><span class="line">    ListNode* pn = l1-&gt;next;</span><br><span class="line">    l1-&gt;next = <span class="literal">nullptr</span>;</span><br><span class="line">    ListNode* retNode = mergeTwoLists(pn, p2);</span><br><span class="line">    p1-&gt;next = retNode;</span><br><span class="line">    <span class="keyword">return</span> p1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当<code>p2</code>的值小于<code>p1</code>的值时，合并的过程还是这个样子的。</p><p><img src="/" alt="" / class="lazyload" data-src="https://cdn.jsdelivr.net/gh/jackymxp/image-bed/leetcode/20200322205036.png"></p></li><li><p><strong>完整代码</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">mergeTwoLists</span><span class="params">(ListNode* l1, ListNode* l2)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//当有一个链表为空的时候，直接返回另外一个链表，不管另外一个是否为空</span></span><br><span class="line">        <span class="keyword">if</span>(!l1 || !l2)</span><br><span class="line">            <span class="keyword">return</span> l1 ? l1 : l2;</span><br><span class="line">        <span class="comment">//当l1-&gt;val 小于l2-&gt;val, 直接将l1-&gt;next指向递归的下一层</span></span><br><span class="line">        <span class="keyword">if</span>(l1-&gt;val &lt; l2-&gt;val)</span><br><span class="line">        &#123;</span><br><span class="line">            l1-&gt;next = mergeTwoLists(l1-&gt;next, l2);</span><br><span class="line">            <span class="keyword">return</span> l1;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            l2-&gt;next = mergeTwoLists(l1, l2-&gt;next);</span><br><span class="line">            <span class="keyword">return</span> l2;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ol><h2 id="23-合并k个排序链表"><a class="markdownIt-Anchor" href="#23-合并k个排序链表"></a> <a href="https://leetcode-cn.com/problems/merge-k-sorted-lists/" target="_blank" rel="noopener">23. 合并K个排序链表</a></h2><p>有了<a href="https://leetcode-cn.com/problems/merge-two-sorted-lists/" target="_blank" rel="noopener">合并两个有序链表</a>基础，解决这道题的基本思路还是一样，这次不画图，只是根据定义的递归函数<code>ListNode* mergeKLists(vector&lt;ListNode*&gt;&amp; lists)</code>和上一题的<code>ListNode* mergeTwoLists(ListNode* l1, ListNode* l2)</code>的函数基础，单纯的推导出如何合并<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>k</mi></mrow><annotation encoding="application/x-tex">k</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span></span></span></span>个链表。</p><p>还是按照递归的三个步骤继续走起。</p><ol><li><p><strong>定义递归函数<code>ListNode* mergeKLists(vector&lt;ListNode*&gt;&amp; lists)</code>功能以及返回值</strong></p><p>定义递归函数功能：按照从小达到的顺序合并<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>k</mi></mrow><annotation encoding="application/x-tex">k</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span></span></span></span>个有序链表，并返回排序后链表的头节点。</p></li><li><p><strong>寻找递归函数退出条件和返回值</strong></p><p>想一下，这时候的递归的退出条件是什么？很简单，无非就是讨论<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>k</mi></mrow><annotation encoding="application/x-tex">k</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span></span></span></span>的值。</p><ul><li>当<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>k</mi><mo>=</mo><mn>0</mn></mrow><annotation encoding="application/x-tex">k = 0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">0</span></span></span></span>时，不需要返回任何链表，所以直接返回<code>nullptr</code>。</li><li>当<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>k</mi><mo>=</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">k = 1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span>时，只有一个链表，不需要合并操作，直接返回<code>lists[0]</code>。</li><li>当<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>k</mi><mo>=</mo><mn>2</mn></mrow><annotation encoding="application/x-tex">k = 2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">2</span></span></span></span>时，这个就是合并两个有序链表，直接调用<code>ListNode* mergeTwoLists(lists[0], lists[1])</code>完成合并。</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(k == <span class="number">0</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(k == <span class="number">1</span>)</span><br><span class="line">    <span class="keyword">return</span> lists[<span class="number">0</span>];</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(k == <span class="number">2</span>)</span><br><span class="line">    <span class="keyword">return</span> mergeTwoLists(lists[<span class="number">0</span>], lists[<span class="number">1</span>]);</span><br></pre></td></tr></table></figure></li><li><p><strong>缩小递归函数的规模，寻求层与层之间的关系</strong></p><p>为了缩小递归函数的规模，所以要将<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>k</mi></mrow><annotation encoding="application/x-tex">k</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span></span></span></span>个链表分成了两个部分，但是每个部分有多少个链表，这里可以有不同的分配策略。</p><p><strong>策略1：</strong></p><p>将<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>k</mi></mrow><annotation encoding="application/x-tex">k</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span></span></span></span>个链表拆分成两部分，其中一部分的链表规模是<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>1</mn></mrow><annotation encoding="application/x-tex">1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span>，另外一部分链表的规模时<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>k</mi><mo>−</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">k-1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.77777em;vertical-align:-0.08333em;"></span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span>。当有<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>k</mi></mrow><annotation encoding="application/x-tex">k</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span></span></span></span>个链表的时候，调用的是<code>mergeKLists</code>函数，那么当<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>k</mi><mo>=</mo><mi>k</mi><mo>−</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">k = k-1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.77777em;vertical-align:-0.08333em;"></span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span>时并且<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>k</mi><mo>−</mo><mn>1</mn><mo>&gt;</mo><mn>2</mn></mrow><annotation encoding="application/x-tex">k-1 &gt; 2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.77777em;vertical-align:-0.08333em;"></span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.68354em;vertical-align:-0.0391em;"></span><span class="mord">1</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">&gt;</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">2</span></span></span></span>时，依然可以调用<code>mergeKLists(lists[0...k-2])</code>函数合并<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>k</mi><mo>−</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">k-1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.77777em;vertical-align:-0.08333em;"></span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span>个链表，并返回一个排序的链表头节点<code>node</code>，再和规模为<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>1</mn></mrow><annotation encoding="application/x-tex">1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span>的第<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>k</mi></mrow><annotation encoding="application/x-tex">k</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span></span></span></span>个链表做合并两个排序链表的过程，即调用<code>mergeTwoLists(node, lists[k-1])</code>，再返回。</p><p>对应的代码</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ListNode* node = mergeKLists(<span class="built_in">vector</span>&lt;ListNode*&gt;(lists.begin(), lists.end()<span class="number">-1</span>));</span><br><span class="line"><span class="keyword">return</span> mergeTwoLists(node, lists[lists.size()<span class="number">-1</span>]);</span><br></pre></td></tr></table></figure><p>这样的合并策略由于每次只能合并一条链表，所以递归深度比较深，所以性能开销比较大。</p><p><strong>策略2:</strong></p><p>仿照归并排序，将<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>k</mi></mrow><annotation encoding="application/x-tex">k</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span></span></span></span>个链表分成<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>2</mn></mrow><annotation encoding="application/x-tex">2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">2</span></span></span></span>个部分，每部分有<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>k</mi><mi mathvariant="normal">/</mi><mn>2</mn></mrow><annotation encoding="application/x-tex">k/2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span><span class="mord">/</span><span class="mord">2</span></span></span></span>个链表。当<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>k</mi><mo>=</mo><mi>k</mi><mi mathvariant="normal">/</mi><mn>2</mn></mrow><annotation encoding="application/x-tex">k = k/2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span><span class="mord">/</span><span class="mord">2</span></span></span></span>时并且<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>k</mi><mi mathvariant="normal">/</mi><mn>2</mn><mo>&gt;</mo><mn>2</mn></mrow><annotation encoding="application/x-tex">k/2 &gt; 2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span><span class="mord">/</span><span class="mord">2</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">&gt;</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">2</span></span></span></span>时，依然可以调用<code>mergeKLists(lists[0...k/2))</code>和<code>mergeKLists(lists[k/2...k))</code>函数合并<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>k</mi><mi mathvariant="normal">/</mi><mn>2</mn></mrow><annotation encoding="application/x-tex">k/2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span><span class="mord">/</span><span class="mord">2</span></span></span></span>个链表，每部分都会返回排序<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>k</mi><mi mathvariant="normal">/</mi><mn>2</mn></mrow><annotation encoding="application/x-tex">k/2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span><span class="mord">/</span><span class="mord">2</span></span></span></span>个链表的头节点<code>node1</code>和<code>node2</code>，这时候再调用<code>mergeTwoLists(node1, node2)</code>，再返回。</p><p>对应的代码</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="built_in">vector</span>&lt;ListNode*&gt; <span class="title">front</span><span class="params">(lists.begin(), lists.begin()+len/<span class="number">2</span>)</span></span>;</span><br><span class="line"><span class="function"><span class="built_in">vector</span>&lt;ListNode*&gt; <span class="title">back</span><span class="params">(lists.begin()+len/<span class="number">2</span>, lists.end())</span></span>;</span><br><span class="line"><span class="comment">//合并前k/2个链表</span></span><br><span class="line">ListNode* node1 = mergeKLists(front);</span><br><span class="line"><span class="comment">//合并后k/2个链表</span></span><br><span class="line">ListNode* node2 = mergeKLists(back);</span><br><span class="line"><span class="comment">//将两个链表合并的结果使用合并两个链表函数合并</span></span><br><span class="line"><span class="keyword">return</span> mergeTwoLists(node1, node2);</span><br></pre></td></tr></table></figure></li><li><p><strong>完整代码</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line">    <span class="function">ListNode* <span class="title">mergeTwoLists</span><span class="params">(ListNode* l1, ListNode* l2)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//当有一个链表为空的时候，直接返回另外一个链表，不管另外一个是否为空</span></span><br><span class="line">        <span class="keyword">if</span>(!l1 || !l2)</span><br><span class="line">            <span class="keyword">return</span> l1 ? l1 : l2;</span><br><span class="line">        <span class="comment">//当l1-&gt;val 小于l2-&gt;val, 直接将l1-&gt;next指向递归的下一层</span></span><br><span class="line">        <span class="keyword">if</span>(l1-&gt;val &lt; l2-&gt;val)</span><br><span class="line">        &#123;</span><br><span class="line">            l1-&gt;next = mergeTwoLists(l1-&gt;next, l2);</span><br><span class="line">            <span class="keyword">return</span> l1;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            l2-&gt;next = mergeTwoLists(l1, l2-&gt;next);</span><br><span class="line">            <span class="keyword">return</span> l2;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">mergeKLists</span><span class="params">(<span class="built_in">vector</span>&lt;ListNode*&gt;&amp; lists)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> len = lists.size();</span><br><span class="line">        <span class="keyword">if</span>(len == <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(len == <span class="number">1</span>)</span><br><span class="line">            <span class="keyword">return</span> lists[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(len == <span class="number">2</span>)</span><br><span class="line">            <span class="keyword">return</span> mergeTwoLists(lists[<span class="number">0</span>], lists[<span class="number">1</span>]);</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">vector</span>&lt;ListNode*&gt; front(lists.begin(), lists.begin()+len/<span class="number">2</span>);</span><br><span class="line">            <span class="function"><span class="built_in">vector</span>&lt;ListNode*&gt; <span class="title">back</span><span class="params">(lists.begin()+len/<span class="number">2</span>, lists.end())</span></span>;</span><br><span class="line">            ListNode* node1 = mergeKLists(front);</span><br><span class="line">            ListNode* node2 = mergeKLists(back);</span><br><span class="line">            <span class="keyword">return</span> mergeTwoLists(node1, node2);</span><br><span class="line">        &#125;         </span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ol><h2 id="148-排序链表"><a class="markdownIt-Anchor" href="#148-排序链表"></a> <a href="https://leetcode-cn.com/problems/sort-list/" target="_blank" rel="noopener">148. 排序链表</a></h2><p>这个题要求使用<code>O(nlogn)</code>的时间复杂度，只有快速排序、堆排序、归并排序符合这个时间的复杂度为了复用上面实现的合并两个有序链表的代码， 采用<strong>归并排序</strong>。</p><p>还是原来的套路，分三步继续走。Let’s go。</p><ol><li><p><strong>定义递归函数<code>ListNode* sortList(ListNode* head)</code>功能以及返回值</strong>：</p><p>根据定义的递归函数功能，首先将<code>sortList</code>的作用范围放在整个链表，图中有绿色的阴影部分代表递归函数<code>sortList</code>的作用范围，也就是将<code>head</code>作为参数传递给<code>sortList(head)</code>作用的范围。</p><p><img src="/" alt="" / class="lazyload" data-src="https://cdn.jsdelivr.net/gh/jackymxp/image-bed/leetcode/20200322222549.png"></p><p>当把<code>head</code>作为参数传递给递归函数<code>sortList</code>作用后，根据定义的递归函数功能，这个函数就完成了整个链表的排序，也就是期望的最终答案。</p><p><img src="/" alt="" / class="lazyload" data-src="https://cdn.jsdelivr.net/gh/jackymxp/image-bed/leetcode/20200322222859.png"></p></li><li><p><strong>寻找递归函数退出条件和返回值</strong></p><p>当链表长度为<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>1</mn></mrow><annotation encoding="application/x-tex">1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span>或者<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>0</mn></mrow><annotation encoding="application/x-tex">0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">0</span></span></span></span>时，就不用排序，直接返回就可以。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(!head || !head-&gt;next)</span><br><span class="line">    <span class="keyword">return</span> head;</span><br></pre></td></tr></table></figure></li><li><p><strong>缩小递归函数的规模，寻求层与层之间的关系</strong></p><p>在这里思考，如何缩小递归的规模，也就是让<code>sortList</code>中传入的链表长度减少，那就是将链表分为两个部分，分别对链表的每一个部分进行排序。具体怎么分有不同的策略，也可以仿照上题的策略，但是比较高效的方法是每部分链表长度分别为原来的<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>1</mn><mi mathvariant="normal">/</mi><mn>2</mn></mrow><annotation encoding="application/x-tex">1/2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mord">/</span><span class="mord">2</span></span></span></span>。也就是从中间断开链表。所以涉及到的问题是，如何寻找一个链表的中点？</p><p>这里使用快慢指针，快指针一次走两步，慢指针一次走一步，当快指针到尾部的时候，慢指针刚好走到链表的中点。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">ListNode* fast = head;</span><br><span class="line">ListNode* slow = head;</span><br><span class="line">ListNode* mid = <span class="literal">nullptr</span>;</span><br><span class="line"><span class="keyword">while</span>(fast &amp;&amp; fast-&gt;next)</span><br><span class="line">&#123;</span><br><span class="line">    fast = fast-&gt;next-&gt;next;</span><br><span class="line">    mid = slow;</span><br><span class="line">    slow = slow-&gt;next;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//为了使的链表成为两个独立的部分，将slow的next置空</span></span><br><span class="line">slow-&gt;next = <span class="literal">nullptr</span>;</span><br><span class="line"><span class="comment">//此时[head, slow] 是链表的前一个部分</span></span><br><span class="line"><span class="comment">//[mid, end)是链表的后一个部分。</span></span><br></pre></td></tr></table></figure><p>找到中点后，可以调用<code>p1 = sortList(head)</code> 和<code>p2 = sortList(mid)</code>分别对原链表的两部分进行了排序。</p><p><img src="/" alt="" / class="lazyload" data-src="https://cdn.jsdelivr.net/gh/jackymxp/image-bed/leetcode/20200322223155.png"></p><p>根据定义递归函数的功能，就是排序一个链表，所以当<code>p1 = sortList(head)</code> 和<code>p2 = sortList(mid)</code>执行之后，整个链表变成如下这个样子。</p><p><img src="/" alt="" / class="lazyload" data-src="https://cdn.jsdelivr.net/gh/jackymxp/image-bed/leetcode/20200322223416.png"></p><p>那么接下来的问题时，就是如何合并两个已经排序的链表呢？咦，这不是<a href="https://leetcode-cn.com/problems/merge-two-sorted-lists/" target="_blank" rel="noopener"> 合并两个有序链表</a>这个题嘛。所以直接调用<code>mergeTwoLists(node1, node2)</code>合并两个排序链表。</p><p>最后上一张图来表示一下这一个过程。其中绿色的阴影部分表示的是使用<code>sortList</code>函数，粉色的阴影表示的是<code>mergeTwoLists</code>作用范围。</p><p><img src="/" alt="" / class="lazyload" data-src="https://tva1.sinaimg.cn/large/00831rSTly1gcx9ggnj0dj31r70u07bp.jpg"></p></li><li><p><strong>完整代码</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line">    <span class="function">ListNode* <span class="title">merge</span><span class="params">(ListNode* p1, ListNode* p2)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!p1 || !p2)</span><br><span class="line">            <span class="keyword">return</span> p1 ? p1 : p2;</span><br><span class="line">        <span class="keyword">if</span>(p1-&gt;val &lt; p2-&gt;val)</span><br><span class="line">        &#123;</span><br><span class="line">            p1-&gt;next = merge(p1-&gt;next, p2);</span><br><span class="line">            <span class="keyword">return</span> p1;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> </span><br><span class="line">        &#123;</span><br><span class="line">            p2-&gt;next = merge(p1, p2-&gt;next);</span><br><span class="line">            <span class="keyword">return</span> p2;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">sortList</span><span class="params">(ListNode* head)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!head || !head-&gt;next)</span><br><span class="line">            <span class="keyword">return</span> head;</span><br><span class="line">        <span class="comment">//定位到mid</span></span><br><span class="line">        ListNode* fast = head;</span><br><span class="line">        ListNode* slow = head;</span><br><span class="line">        ListNode* mid = <span class="literal">nullptr</span>;</span><br><span class="line">        <span class="keyword">while</span>(fast &amp;&amp; fast-&gt;next)</span><br><span class="line">        &#123;</span><br><span class="line">            fast = fast-&gt;next-&gt;next;</span><br><span class="line">            mid = slow;</span><br><span class="line">            slow = slow-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        mid-&gt;next = <span class="literal">nullptr</span>;</span><br><span class="line">        <span class="comment">//分别对链表的两个部分进行排序。</span></span><br><span class="line">        ListNode* node1 = sortList(head);</span><br><span class="line">        ListNode* node2 = sortList(slow);</span><br><span class="line">        <span class="comment">//对两个已经排好序的链表进行合并。</span></span><br><span class="line">        <span class="keyword">return</span> merge(node1, node2);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ol><h2 id="2-两数相加"><a class="markdownIt-Anchor" href="#2-两数相加"></a> <a href="https://leetcode-cn.com/problems/add-two-numbers/" target="_blank" rel="noopener">2. 两数相加</a></h2><p>为什么我把这个题归结于合并链表题呢？其实上面三道题可以看作以链表的值的大小进行合并的一种方式，这个题不是根据大小进行合并，而是以“加法”操作对链表进行合并。那么我们看下在链表中如何按照&quot;加法&quot;这种操作对链表进行操作。</p><p>还是按照递归的三个步骤进行。</p><ol><li><p><strong>定义递归函数<code>ListNode* addTwoNumbers(ListNode* l1, ListNode* l2)</code>功能以及返回值</strong>：</p><p>定义递归函数功能：对链表<code>l1</code>和<code>l2</code>按照题目给定的规则进行合并，并返回合并后链表的头节点。</p><p>根据我们定义的递归的函数的功能，首先将<code>addTwoNumbers</code>作用范围放在整个链表，图中有绿色的阴影部分代表递归函数<code>addTwoNumbers</code>的作用范围，也就是将<code>p1</code>和<code>p2</code>作为参数传递给<code>addTwoNumbers(p1, p2)</code>作用的范围。</p><img src="/" style="zoom:50%;" / class="lazyload" data-src="https://cdn.jsdelivr.net/gh/jackymxp/image-bed/leetcode/20200322224858.png"><p>当把 <code>p1</code>和<code>p2</code> 作为参数传递给递归函数 <code>addTwoNumbers</code> 作用后，根据定义的递归函数功能，这个函数就完成了整个链表的相加，也就是期望的最终答案。</p><img src="/" style="zoom:50%;" / class="lazyload" data-src="https://cdn.jsdelivr.net/gh/jackymxp/image-bed/leetcode/20200322224942.png"></li><li><p><strong>寻找递归函数退出条件和返回值</strong></p><p>当有一个链表为空的时候，直接返回另外一个链表，不管另外一个链表是否为空。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(!l1 || !l2)</span><br><span class="line">    <span class="keyword">return</span> l1 ? l1 : l2;</span><br></pre></td></tr></table></figure></li><li><p><strong>缩小递归函数的规模，寻求层与层之间的关系</strong></p><p>如何缩小递归函数的规模呢，在这里只有一种选择，就是每次将<code>p1</code>和<code>p2</code>的指针后移一位，再次调用<code>node = addTwoNumbers(pm, pn)</code>完成剩余部分的加法合并。</p><img src="/" style="zoom:50%;" / class="lazyload" data-src="https://cdn.jsdelivr.net/gh/jackymxp/image-bed/leetcode/20200322225336.png"><p>当执行完<code>addTwoNumbers(pm, pn)</code>后，整个链表变成如下结构：</p><img src="/" style="zoom:50%;" / class="lazyload" data-src="https://tva1.sinaimg.cn/large/00831rSTly1gd33kz06wmj30pw0hi3z4.jpg"><p>为了将已经相加的链表和未相加的链表连接在一起，令<code>sum = p1-&gt;val + p2-&gt;val</code> 。</p><p>这里就需要对<code>sum</code>的值进行考虑，如果<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>s</mi><mi>u</mi><mi>m</mi><mo>&lt;</mo><mn>10</mn></mrow><annotation encoding="application/x-tex">sum &lt; 10</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.5782em;vertical-align:-0.0391em;"></span><span class="mord mathdefault">s</span><span class="mord mathdefault">u</span><span class="mord mathdefault">m</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">&lt;</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span><span class="mord">0</span></span></span></span>，如上图所示，直接重新分配一个值为<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>s</mi><mi>u</mi><mi>m</mi></mrow><annotation encoding="application/x-tex">sum</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">s</span><span class="mord mathdefault">u</span><span class="mord mathdefault">m</span></span></span></span>的节点<code>head</code>，并直接修改指针<code>head-&gt;next = node</code>即可。</p><img src="/" style="zoom:50%;" / class="lazyload" data-src="https://cdn.jsdelivr.net/gh/jackymxp/image-bed/leetcode/20200322230427.png"><p>当<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>s</mi><mi>u</mi><mi>m</mi><mo>&lt;</mo><mn>10</mn></mrow><annotation encoding="application/x-tex">sum &lt; 10</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.5782em;vertical-align:-0.0391em;"></span><span class="mord mathdefault">s</span><span class="mord mathdefault">u</span><span class="mord mathdefault">m</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">&lt;</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span><span class="mord">0</span></span></span></span>的逻辑代码如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(sum &lt; <span class="number">10</span>)</span><br><span class="line">&#123;</span><br><span class="line">    ListNode* node = addTwoNumbers(p1-&gt;next, p2-&gt;next);</span><br><span class="line">    ListNode* head = <span class="keyword">new</span> ListNode(sum);</span><br><span class="line">    head-&gt;next = node;</span><br><span class="line"><span class="keyword">return</span> node;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>但是当<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>s</mi><mi>u</mi><mi>m</mi><mo>&gt;</mo><mo>=</mo><mn>10</mn></mrow><annotation encoding="application/x-tex">sum &gt;= 10</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.5782em;vertical-align:-0.0391em;"></span><span class="mord mathdefault">s</span><span class="mord mathdefault">u</span><span class="mord mathdefault">m</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">&gt;</span></span><span class="base"><span class="strut" style="height:0.36687em;vertical-align:0em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span><span class="mord">0</span></span></span></span>是，要考虑到进位，这才是本题的难点。</p><p>如果<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>s</mi><mi>u</mi><mi>m</mi><mo>&gt;</mo><mo>=</mo><mn>10</mn></mrow><annotation encoding="application/x-tex">sum &gt;= 10</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.5782em;vertical-align:-0.0391em;"></span><span class="mord mathdefault">s</span><span class="mord mathdefault">u</span><span class="mord mathdefault">m</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">&gt;</span></span><span class="base"><span class="strut" style="height:0.36687em;vertical-align:0em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span><span class="mord">0</span></span></span></span>时，新分配一个值为<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>s</mi><mi>u</mi><mi>m</mi><mtext>  </mtext><mi>m</mi><mi>o</mi><mi>d</mi><mtext>  </mtext><mn>10</mn></mrow><annotation encoding="application/x-tex">sum \; mod \; 10</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault">s</span><span class="mord mathdefault">u</span><span class="mord mathdefault">m</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mord mathdefault">m</span><span class="mord mathdefault">o</span><span class="mord mathdefault">d</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mord">1</span><span class="mord">0</span></span></span></span>的节点<code>head</code>是不够的， 还需要分配一个值为<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>1</mn></mrow><annotation encoding="application/x-tex">1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span>的节点<code>flag</code>，在这里我们要如何处理这个进位操作呢？</p><p>其实很简单，只需要让<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>1</mn></mrow><annotation encoding="application/x-tex">1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span>与已经相加的<code>node</code>链表再做一次相加操作，即只需要让调用<code>addTwoNumbers(node, flag)</code>操作即可。</p><img src="/" style="zoom:50%;" / class="lazyload" data-src="https://cdn.jsdelivr.net/gh/jackymxp/image-bed/leetcode/20200322231503.png"><img src="/" style="zoom:50%;" / class="lazyload" data-src="https://tva1.sinaimg.cn/large/00831rSTly1gd3473mmy6j30o00eqdgl.jpg"><p>为了看的更加清楚，我将其画在了一起，其中绿色的部分代表递归已经完成了，其实应该等价于一个链表<code>next</code>，在这里为了看清楚，没有将其化为一个链表。</p><p><img src="/" alt="" / class="lazyload" data-src="https://tva1.sinaimg.cn/large/00831rSTly1gcxb7z847xj31rw0skq54.jpg"></p><p>这样当<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>s</mi><mi>u</mi><mi>m</mi><mo>&gt;</mo><mo>=</mo><mn>10</mn></mrow><annotation encoding="application/x-tex">sum &gt;= 10</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.5782em;vertical-align:-0.0391em;"></span><span class="mord mathdefault">s</span><span class="mord mathdefault">u</span><span class="mord mathdefault">m</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">&gt;</span></span><span class="base"><span class="strut" style="height:0.36687em;vertical-align:0em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span><span class="mord">0</span></span></span></span>大于<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>10</mn></mrow><annotation encoding="application/x-tex">10</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span><span class="mord">0</span></span></span></span>时的逻辑如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(sum &gt;= <span class="number">10</span>)</span><br><span class="line">&#123;</span><br><span class="line">    ListNode* node = addTwoNumbers(p1-&gt;next, p2-&gt;next);</span><br><span class="line">    ListNode* head = <span class="keyword">new</span> ListNode(sum % <span class="number">10</span>);</span><br><span class="line">    head-&gt;next = addTwoNumbers(node, <span class="keyword">new</span> ListNode(<span class="number">1</span>));</span><br><span class="line">    <span class="keyword">return</span> head;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><strong>完整代码</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">addTwoNumbers</span><span class="params">(ListNode* l1, ListNode* l2)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//递归退出条件，当有一个为空或者两个都为空</span></span><br><span class="line">        <span class="keyword">if</span>(!l1 || !l2)</span><br><span class="line">            <span class="keyword">return</span> l1 ? l1 : l2;</span><br><span class="line">        <span class="comment">//这里l1和l2都不为空，所以可以直接访问l1-&gt;val 和 l2-&gt;val</span></span><br><span class="line">        <span class="keyword">int</span> sum = l1-&gt;val + l2-&gt;val;</span><br><span class="line">        ListNode* newNode = <span class="keyword">new</span> ListNode(sum % <span class="number">10</span>);</span><br><span class="line">        <span class="comment">//保存l1-&gt;next和l2-&gt;next的addTwoNumbers结果</span></span><br><span class="line">        ListNode* nextNode = addTwoNumbers(l1-&gt;next, l2-&gt;next);</span><br><span class="line">        <span class="comment">//当sum小于10的时候，不会产生进位，所以直接赋值给next就可以</span></span><br><span class="line">        <span class="keyword">if</span>(sum &lt; <span class="number">10</span>)</span><br><span class="line">            newNode-&gt;next = nextNode;</span><br><span class="line">        <span class="keyword">else</span><span class="comment">//sum &gt;= 10,则需要将产生的结果和1做加法的结果赋值给next</span></span><br><span class="line">            newNode-&gt;next = addTwoNumbers(nextNode, <span class="keyword">new</span> ListNode(<span class="number">1</span>));</span><br><span class="line">        <span class="keyword">return</span> newNode;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><hr /></li></ol><h1 id="在链表中移除元素"><a class="markdownIt-Anchor" href="#在链表中移除元素"></a> 在链表中移除元素</h1><p>上面的一些题，都是通过递归修改链表内部的指针，从而得到期望的链表结构。其实这些题目用普通方法都是可以解答的，但是使用普通的方法很容易出错，修改修改指针就乱了，或者产生内存泄漏。</p><p>但是如果理解递归的基本思路，就可以编写出更简单的代码，也更容易理解。下面就继续通过递归的方式，去完成几个在链表中删除元素的题。继续理解上面说的递归的三个步骤。</p><h2 id="203-移除链表元素"><a class="markdownIt-Anchor" href="#203-移除链表元素"></a> <a href="https://leetcode-cn.com/problems/remove-linked-list-elements/" target="_blank" rel="noopener">203. 移除链表元素</a></h2><ol><li><p><strong>定义递归函数<code>ListNode* removeElements(ListNode* head, int val)</code>功能以及返回值</strong>：</p><p>定义递归函数功能：删除链表中值等于<code>val</code>的节点，并返回新的头节点。</p><p>根据定义的递归函数功能，首先将<code>removeElements</code>的作用范围放在整个链表，图中有绿色的阴影部分代表递归函数<code>reverseKGroup</code>的作用范围，也就是将<code>head</code>作为参数传递给<code>reverseKGroup(head, val)</code>作用的范围。</p><p><img src="/" alt="" / class="lazyload" data-src="https://tva1.sinaimg.cn/large/00831rSTly1gcw39mcqbnj31k606kgm1.jpg"></p><p>在这里设定<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>k</mi><mo>=</mo><mn>6</mn></mrow><annotation encoding="application/x-tex">k = 6</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">6</span></span></span></span>，当把<code>head</code>作为参数传递给递归函数作<code>removeElements</code>用后，根据定义的递归函数功能，这个函数就完成删除链表中所有值为<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>6</mn></mrow><annotation encoding="application/x-tex">6</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">6</span></span></span></span>的节点，并返回删除值为<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>6</mn></mrow><annotation encoding="application/x-tex">6</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">6</span></span></span></span>的链表后的链表头节点。</p><img src="/" style="zoom: 50%;" / class="lazyload" data-src="https://tva1.sinaimg.cn/large/00831rSTly1gcw3ecip1mj314k052wer.jpg"></li><li><p><strong>寻找递归函数退出条件和返回值</strong></p><p>当链表中不存在节点的时候，不需要删除任何节点，就直接返回。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(!head)</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br></pre></td></tr></table></figure></li><li><p><strong>缩小递归函数的规模，寻求层与层之间的关系</strong></p><p>为了缩减递归函数的规模，所以要将链表拆分为两个部分，由于要判断链表中的每个值是否等于<code>val</code>，所以要将链表分成长度分别为<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>1</mn></mrow><annotation encoding="application/x-tex">1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span>和长度为<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>k</mi><mo>−</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">k-1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.77777em;vertical-align:-0.08333em;"></span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span>的两个链表，其中<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>k</mi></mrow><annotation encoding="application/x-tex">k</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span></span></span></span>是原链表的长度。假设两部分链表的头节点分别是<code>head</code>和<code>newHead</code>。当函数缩减规模的时候，即将<code>newHead</code>作为参数传递给<code>removeElements</code>，其中用图表示如下：</p><p><img src="/" alt="" / class="lazyload" data-src="https://cdn.jsdelivr.net/gh/jackymxp/image-bed/leetcode/20200323063910.png"></p><p>当<code>removeElements(newHead, val)</code>执行完后，根据我们定义的递归的功能，即删除了上图绿色阴影中值为<code>val</code>的节点，整个链表变成如下图。</p><p><img src="/" alt="" / class="lazyload" data-src="https://cdn.jsdelivr.net/gh/jackymxp/image-bed/leetcode/20200323064820.png"></p><p>这时要判断当前节点<code>head-&gt;val</code>的值是否等于<code>val</code>，在这里就要分情况讨论了：</p><ul><li><p>如果<code>head-&gt;val != val</code>，表示的是不需要删除当前节点。为了将<code>head</code>与<code>retNode</code>串联起来，直接<code>head-&gt;next = retNode</code>即可。并且返回<code>head</code>。具体逻辑如上图所示。</p></li><li><p>如果<code>head-&gt;val == val</code>，表示的是需要删除当前节点，并且直接返回<code>retNode</code>。</p><p>用图形表示，当<code>head-&gt;val == 6</code>时，递归的情况如下：</p><p><img src="/" alt="" / class="lazyload" data-src="https://cdn.jsdelivr.net/gh/jackymxp/image-bed/leetcode/20200323120659.png"></p><p>当执行完<code>removeElements(newHead, val)</code>后，根据定义的递归功能，应该删除<code>newHead</code>后所有值为<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>6</mn></mrow><annotation encoding="application/x-tex">6</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">6</span></span></span></span>的节点，当执行完<code>removeElements(newHead, val)</code>后，整体的链表结构如下。</p><p><img src="/" alt="" / class="lazyload" data-src="https://cdn.jsdelivr.net/gh/jackymxp/image-bed/leetcode/20200323120443.png"></p><p>为了删除值为<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>6</mn></mrow><annotation encoding="application/x-tex">6</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">6</span></span></span></span>的节点，所以使用<code>delete head</code>即可，并且直接返回<code>retNode</code>即可。</p></li></ul><p>整体的代码逻辑如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">ListNode* newHead = head-&gt;next;</span><br><span class="line"><span class="comment">//将链表分割成两个部分</span></span><br><span class="line">head-&gt;next = <span class="literal">nullptr</span>;</span><br><span class="line">ListNode* retNode = removeElements(newHead, val);</span><br><span class="line"><span class="keyword">if</span>(head-&gt;val == val)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">delete</span> head;</span><br><span class="line">    <span class="keyword">return</span> retNode;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">    head-&gt;next = retNode;</span><br><span class="line">    <span class="keyword">return</span> head;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">4.  **完整代码**</span><br><span class="line"></span><br><span class="line">    &#96;&#96;&#96;cpp</span><br><span class="line">    class Solution &#123;</span><br><span class="line">    public:</span><br><span class="line">        ListNode* removeElements(ListNode* head, int val) &#123;</span><br><span class="line">            if(!head)</span><br><span class="line">                return head;</span><br><span class="line">            ListNode* newHead &#x3D; head-&gt;next;</span><br><span class="line">            &#x2F;&#x2F;断开为两个链表</span><br><span class="line">            head-&gt;next &#x3D; nullptr;</span><br><span class="line">            &#x2F;&#x2F;newHead 链表部分已经删除值为val的节点</span><br><span class="line">            ListNode* retNode &#x3D; removeElements(newHead, val);</span><br><span class="line">            if(head-&gt;val &#x3D;&#x3D; val)&#123;</span><br><span class="line">                delete head;</span><br><span class="line">                return retNode;</span><br><span class="line">            &#125;</span><br><span class="line">            else&#123;</span><br><span class="line">                head-&gt;next &#x3D; retNode;</span><br><span class="line">                return head;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br></pre></td></tr></table></figure><h2 id="83-删除排序链表中的重复元素"><a class="markdownIt-Anchor" href="#83-删除排序链表中的重复元素"></a> <a href="https://leetcode-cn.com/problems/remove-duplicates-from-sorted-list/" target="_blank" rel="noopener">83. 删除排序链表中的重复元素</a></h2><blockquote><p>给定一个排序链表，删除所有重复的元素，使得每个元素只出现一次。</p><p>示例 1:</p><p>输入: 1-&gt;1-&gt;2<br />输出: 1-&gt;2<br />示例 2:</p><p>输入: 1-&gt;1-&gt;2-&gt;3-&gt;3<br />输出: 1-&gt;2-&gt;3</p></blockquote><ol><li><p><strong>定义递归函数<code>ListNode* deleteDuplicates(ListNode* head)</code>功能以及返回值</strong></p><p>首先定义递归函数的功能是删除链表中值重复的元素，使重复的元素只出现一次。根据定义的递归函数功能，首先将<code>deleteDuplicates</code>的作用范围放在整个链表，图中有绿色的阴影部分代表递归函数<code>deleteDuplicates</code>的作用范围，也就是将<code>head</code>作为参数传递给<code>deleteDuplicates(head)</code>作用的范围。</p><p><img src="/" alt="" / class="lazyload" data-src="/Users/mengxiangpeng/Documents/blog/HexoBlog-Butterfly-BackUp/source/_posts/fucking-leetcode/01-%E9%93%BE%E8%A1%A8%E9%80%92%E5%BD%92%E4%B8%93%E9%A2%98.assets/00831rSTly1gd3r6br4tlj311u05maa9.jpg"></p><p>当把<code>head</code>作为参数传递给递归函数<code>deleteDuplicates</code>作用后，根据定义的递归函数功能，这个函数就完成了整个链表的翻转，也就是期望的最终答案。</p><img src="/" style="zoom:50%;" / class="lazyload" data-src="https://cdn.jsdelivr.net/gh/jackymxp/image-bed/leetcode/20200323122819.png"></li><li><p><strong>寻找递归函数退出条件和返回值</strong></p><p>当链表中不存在节点或者只有一个节点的时候，直接退出，因为一个节点不存在重复的节点。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(!head || !head-&gt;next)</span><br><span class="line">    <span class="keyword">return</span> head;</span><br></pre></td></tr></table></figure></li><li><p><strong>缩小递归函数的规模，寻求层与层之间的关系</strong></p><p>为了缩减递归函数的规模，所以要将链表拆分为两个部分，具体怎么拆分呢？这直接影响递归函数的编写。在这里我们将所有重复的节点看成是一部分，剩下的所有节点是另外一部分。具体解释一下。</p><p>这里将重复的节点看成是一组，重复节点的个数可能是<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>1</mn></mrow><annotation encoding="application/x-tex">1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span>或者更多。这里将原链表按照如下的方式进行划分为两个链表。也就是找到第一个和<code>head-&gt;val</code>值不同的节点，作为<code>newHead</code>。当缩小递归函数的范围的时候，即将<code>newHead</code>作为参数传入到<code>deleteDuplicates</code>函数中，其中递归函数的作用范围表示成图。</p><p><img src="/" alt="" / class="lazyload" data-src="https://cdn.jsdelivr.net/gh/jackymxp/image-bed/leetcode/20200323130416.png"></p><p>当递归函数<code>ListNode* retNode = deleteDuplicates(newHead)</code>执行完成后，根据递归函数的功能，这样就完成图中绿色阴影部分删除重复的节点。这样除前面重复的节点没有删除，后其余部分都符合题目要求，整个链表变成如下这个样子。</p><img src="/" style="zoom:50%;" / class="lazyload" data-src="https://tva1.sinaimg.cn/large/00831rSTly1gd3znjd91ej30uc07yjrv.jpg"><p>这时只要将重复的节点删除，<strong>只保留一个重复的节点</strong>。为了和已经完成的部分<code>retNode</code>连接起来，所以删除后的节点的<code>next</code>指针指向<code>retNode</code>。</p><p>将上述过程翻译成代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">ListNode* newHead = head-&gt;next;</span><br><span class="line"><span class="keyword">while</span>(newHead &amp;&amp; newHead-&gt;val == head-&gt;val)</span><br><span class="line">&#123;</span><br><span class="line">    ListNode* next = newHead-&gt;next;</span><br><span class="line">    <span class="keyword">delete</span> newHead;</span><br><span class="line">    newHead = next;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//将链表分为两个部分。·</span></span><br><span class="line">head-&gt;next = <span class="literal">nullptr</span>;</span><br><span class="line">ListNode* retNode = deleteDuplicates(newHead);</span><br><span class="line"></span><br><span class="line">head-&gt;next = retNode;</span><br></pre></td></tr></table></figure></li><li><p><strong>递归代码</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">deleteDuplicates</span><span class="params">(ListNode* head)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//递归退出条件</span></span><br><span class="line">        <span class="keyword">if</span>(!head || !head-&gt;next)</span><br><span class="line">            <span class="keyword">return</span> head;</span><br><span class="line"></span><br><span class="line">        ListNode* newHead = head-&gt;next;</span><br><span class="line">        <span class="keyword">while</span>(newHead &amp;&amp; newHead-&gt;val == head-&gt;val)</span><br><span class="line">        &#123;</span><br><span class="line">            ListNode* next = newHead-&gt;next;</span><br><span class="line">            <span class="keyword">delete</span> newHead;</span><br><span class="line">            newHead = next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//将链表分为两个部分。</span></span><br><span class="line">        head-&gt;next = <span class="literal">nullptr</span>;</span><br><span class="line">        <span class="comment">//对 newHead部分按照递归函数定义的功能删除重复节点，且只保留一个</span></span><br><span class="line">        ListNode* retNode = deleteDuplicates(newHead);</span><br><span class="line">        <span class="comment">//链接链表的两个部分</span></span><br><span class="line">        head-&gt;next = retNode;</span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ol><h2 id="82-删除排序链表中的重复元素-ii"><a class="markdownIt-Anchor" href="#82-删除排序链表中的重复元素-ii"></a> <a href="https://leetcode-cn.com/problems/remove-duplicates-from-sorted-list-ii/" target="_blank" rel="noopener">82. 删除排序链表中的重复元素 II</a></h2><blockquote><p>给定一个排序链表，删除所有含有重复数字的节点，只保留原始链表中 没有重复出现 的数字。</p><p>示例 1:</p><p>输入: 1-&gt;2-&gt;3-&gt;3-&gt;4-&gt;4-&gt;5<br />输出: 1-&gt;2-&gt;5<br />示例 2:</p><p>输入: 1-&gt;1-&gt;1-&gt;2-&gt;3<br />输出: 2-&gt;3</p></blockquote><ol><li><p><strong>定义递归函数<code>ListNode* deleteDuplicates(ListNode* head)</code>功能以及返回值</strong></p><p>首先定义递归函数的功能是删除链表中值重复的所有元素，也就是不保留任何值重复的元素。根据定义的递归函数功能，首先将<code>deleteDuplicates</code>的作用范围放在整个链表，图中有绿色的阴影部分代表递归函数<code>deleteDuplicates</code>的作用范围，也就是将<code>head</code>作为参数传递给<code>deleteDuplicates(head)</code>作用的范围。</p><p><img src="/" alt="" / class="lazyload" data-src="https://cdn.jsdelivr.net/gh/jackymxp/image-bed/leetcode/20200323184315.png"></p><p>当把<code>head</code>作为参数传递给递归函数<code>deleteDuplicates</code>作用后，根据定义的递归函数功能，这个函数就完成了整个链表的翻转，也就是期望的最终答案。</p><img src="/" style="zoom:50%;" / class="lazyload" data-src="https://cdn.jsdelivr.net/gh/jackymxp/image-bed/leetcode/20200323184654.png"></li><li><p><strong>寻找递归函数退出条件和返回值</strong></p><p>当链表中不存在节点或者只有一个节点的时候，直接退出，因为一个节点不存在重复的节点。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(!head || !head-&gt;next)</span><br><span class="line">    <span class="keyword">return</span> head;</span><br></pre></td></tr></table></figure></li><li><p><strong>缩小递归函数的规模，寻求层与层之间的关系</strong></p><p>在这里还是要思考如何减少递归函数的作用范围呢，仿照上面题的策略，将链表中的节点的值分成两组讨论，一组是只出现一次的节点的值；另外一组是链表中值重复的一组。</p><ul><li><p>如果值没有重复，则不用删除，链表的剩下部分头节点为<code>newHead</code>，删除从<code>newHead</code>开始链表的重复节点仍然是一个删除链表中重复节点的过程，依然可以直接使用<code>deleteDuplicates(newHead)</code>完成剩余的部分，使用图表示如下图所示。</p><p><img src="/" alt="" / class="lazyload" data-src="https://cdn.jsdelivr.net/gh/jackymxp/image-bed/leetcode/20200323190109.png"></p><p>当执行完<code>deleteDuplicates(newHead)</code>后，整个链表变成如下结构，再将两个部分连接起来。</p><img src="/" style="zoom:50%;" / class="lazyload" data-src="https://cdn.jsdelivr.net/gh/jackymxp/image-bed/leetcode/20200323191339.png"><p>当不存在重复节点时的代码逻辑如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(head-&gt;val != head-&gt;next-&gt;val)&#123;<span class="comment">//链表中至少存在两个节点，所以可以直接访问head-&gt;next并不为空</span></span><br><span class="line">    head-&gt;next = deleteDuplicates(head-&gt;next);</span><br><span class="line">    <span class="keyword">return</span> head;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>如果出现重复的节点就需要将<code>newHead</code>定位到下一个大于待删除的节点，再将所有值相同的节点全部释放掉。链表<code>newHead</code>部分仍然可以看作是删除值重复节点的过程，可以调用<code>deleteDuplicates(newHead)</code>完成剩下部分的操作。</p><p><img src="/" alt="" / class="lazyload" data-src="https://cdn.jsdelivr.net/gh/jackymxp/image-bed/leetcode/20200323195350.png"></p><p>存在重复节点时的代码逻辑如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(head-&gt;val == head-&gt;next-&gt;val)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//定位到newHead节点</span></span><br><span class="line">    ListNode* newHead = head;</span><br><span class="line">    <span class="keyword">int</span> val = head-&gt;val;</span><br><span class="line">   <span class="keyword">while</span>(newHead &amp;&amp; newHead-&gt;val == val)</span><br><span class="line">    &#123;</span><br><span class="line">        ListNode* next = newHead-&gt;next;</span><br><span class="line">        <span class="keyword">delete</span> newHead;</span><br><span class="line">        newHead = next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//将 newHead 后的链表删除重复节点，并将删除后的头节点返回</span></span><br><span class="line">    <span class="keyword">return</span> deleteDuplicates(newHead);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li><li><p><strong>递归代码</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">deleteDuplicates</span><span class="params">(ListNode* head)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//递归退出条件，当链表长度小于2的时候</span></span><br><span class="line">        <span class="keyword">if</span>(!head || !head-&gt;next)</span><br><span class="line">            <span class="keyword">return</span> head;</span><br><span class="line">        <span class="keyword">if</span>(head-&gt;val != head-&gt;next-&gt;val)&#123;</span><br><span class="line">            head-&gt;next = deleteDuplicates(head-&gt;next);</span><br><span class="line">            <span class="keyword">return</span> head;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            ListNode* newHead = head;</span><br><span class="line">            <span class="keyword">int</span> val = head-&gt;val;</span><br><span class="line">            <span class="keyword">while</span>(newHead &amp;&amp; newHead-&gt;val == val)</span><br><span class="line">            &#123;</span><br><span class="line">                ListNode* next = newHead-&gt;next;</span><br><span class="line">                <span class="keyword">delete</span> newHead;</span><br><span class="line">                newHead = next;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> deleteDuplicates(newHead);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ol><h2 id="19-删除链表的倒数第n个节点"><a class="markdownIt-Anchor" href="#19-删除链表的倒数第n个节点"></a> <a href="https://leetcode-cn.com/problems/remove-nth-node-from-end-of-list/" target="_blank" rel="noopener">19. 删除链表的倒数第N个节点</a></h2><blockquote><p>给定一个链表，删除链表的倒数第 n 个节点，并且返回链表的头结点。</p><p>示例：</p><p>给定一个链表: 1-&gt;2-&gt;3-&gt;4-&gt;5, 和 n = 2.</p><p>当删除了倒数第二个节点后，链表变为 1-&gt;2-&gt;3-&gt;5.</p></blockquote><p>对于这道题，拿到手里来，是不是没有任何思路。但是只要记得上面的套路，这道题依然可以用递归解决。问题的难点是如何使用递归定位到倒数第<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">n</span></span></span></span>个节点。以倒数第<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">n</span></span></span></span>个节点作为分隔节点，将链表分成两个部分。接下来还是三步走。</p><ol><li><p><strong>定义递归函数<code>ListNode* removeNthFromEnd(ListNode* head, int n)</code>功能以及返回值</strong></p><p>根据定义的递归函数功能，首先将<code>removeNthFromEnd</code>的作用范围放在整个链表，图中有绿色的阴影部分代表递归函数<code>reverseList</code>的作用范围，也就是将<code>head</code>作为参数传递给<code>removeNthFromEnd(head, n)</code>作用的范围。</p><p><img src="/" alt="" / class="lazyload" data-src="https://tva1.sinaimg.cn/large/00831rSTly1gd2x4tff4nj318e0620u7.jpg"></p><p>当把<code>head</code>作为参数传递给递归函数<code>removeNthFromEnd</code>作用后，根据定义的递归函数功能，这个函数就完成了删除倒数第n个节点，也就是期望的最终答案。</p><img src="/" style="zoom:50%;" / class="lazyload" data-src="https://cdn.jsdelivr.net/gh/jackymxp/image-bed/leetcode/20200323210439.png"></li><li><p><strong>寻找递归函数退出条件和返回值</strong></p><p>当链表中没有节点的时候，不能进行删除操作，就可以直接返回。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(!head)</span><br><span class="line">    <span class="keyword">return</span> head;</span><br></pre></td></tr></table></figure></li><li><p><strong>缩小递归函数的规模，寻求层与层之间的关系</strong></p><p>这里我们似乎找不到任何递归函数如何缩减规模的策略，因为这个题，很难通过递归找到倒数第<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">n</span></span></span></span>个节点。在这里我选择通过介绍递归的原理，来讲解这个题。</p><p>我们定义整个链表的尾节点为第<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>0</mn></mrow><annotation encoding="application/x-tex">0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">0</span></span></span></span>个节点，倒数第一个为<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>1</mn></mrow><annotation encoding="application/x-tex">1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span>个节点，那么问题来了，我们如何通过递归定位到最后一个节点呢？</p><p>因为最后一个节点有特殊标记<code>nullptr</code>，所以通过递归遍历整个链表，直到定位到<code>nullptr</code>节点，标记此时的标志为<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>t</mi><mi>h</mi><mtext>  </mtext><mo>=</mo><mtext>  </mtext><mn>0</mn></mrow><annotation encoding="application/x-tex">th \;= \;0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault">t</span><span class="mord mathdefault">h</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">0</span></span></span></span>。那么在递归到<code>nullptr</code>的过程中，这个过程叫做递。</p><p>当在归的时候，每次归的时候将<code>th++</code>，这样当<code>th == n</code>时候，就可以删除该节点了。</p><p>无图无真相：</p><p><img src="/" alt="" / class="lazyload" data-src="https://cdn.jsdelivr.net/gh/jackymxp/image-bed/leetcode/20200323213633.png"></p></li><li><p><strong>完成代码</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> th;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">removeNthFromEnd</span><span class="params">(ListNode* head, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>(head == <span class="literal">nullptr</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            th = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//递的过程</span></span><br><span class="line">        head-&gt;next = removeNthFromEnd(head-&gt;next, n);</span><br><span class="line">        <span class="comment">//每次归的过程，都将标识位做一次加加操作</span></span><br><span class="line">        th++;</span><br><span class="line">        <span class="keyword">if</span>(th == n)</span><br><span class="line">        &#123;</span><br><span class="line">            ListNode* next = head-&gt;next;</span><br><span class="line">            <span class="keyword">delete</span> head;</span><br><span class="line">            <span class="keyword">return</span> next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ol><h1 id="总结"><a class="markdownIt-Anchor" href="#总结"></a> 总结</h1><p>这一篇博客中，都是使用递归解决和链表相关的问题。我们可以总结出使用递归解决链表相关问题的套路。</p><ol><li>首先定义递归函数<code>fun(ListNode* head, ...)</code>的具体功能。</li><li>根据具体的语境，找到递归函数的出口。</li><li>将一个链表分成两个部分，假设链表两部分的头节点分别是<code>head</code>和<code>newHead</code>，其中在<code>newHead</code>部分的链表操作和整个链表的结构是相同的，只是规模更小。也就是说当执行完<code>fun(newHead, …)</code>后，根据我们定义的递归函数的功能，链表变成了什么样子。</li><li>将<code>fun(newHead, …)</code>执行后的链表的返回值与<code>head</code>部分联系起来，找到如何变换<code>head</code>部分，才能让其达到我们期望的结构。这不基本是递归函数的难点。</li></ol><p>在上面解题的过程中，为了将递归函数的功能表示的明确些。刻意将链表分成两个部分，其实有很多题是不需要明确的分成两个部分，而直接改变指针的指向会简化很多代码，但是递归的逻辑就会稍微模糊一点。</p><p>在<a href="https://leetcode-cn.com/problems/remove-nth-node-from-end-of-list/" target="_blank" rel="noopener">删除链表的倒数第N个节点</a>题中，讨论了递归函数的原理，什么时候递，什么时候归，通过上面一些题的例子，我们应该知道那里是递的过程，哪里是归的过程，理解了递和归的过程，对于理解递归的原理还是会有很多帮助的。</p><p>当然能写出递归函数都是在以基本功为基础的，比如定位到链表的中间节点。做链表题的时候，更重要的是对代码鲁棒性的考察，比如当链表没有节点的时候，或者只有一个节点的时候，我们写的函数能不能安全运行，又比如想判断<code>head-&gt;val</code>的值，首先我们要保证<code>head != nullptr</code>，所以在写代码的时候，一般写成<code>if(head &amp;&amp; head-&gt;val == val)</code>等，这些都是我们需要注意的。</p>]]></content>
      
      
      <categories>
          
          <category> leetcode </category>
          
          <category> 编程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数 </tag>
            
            <tag> 递归 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>通过链表学递归</title>
      <link href="/2020/03/15/fucking-leetcode/01-%E9%93%BE%E8%A1%A8%E9%80%92%E5%BD%92%E4%B8%93%E9%A2%98/"/>
      <url>/2020/03/15/fucking-leetcode/01-%E9%93%BE%E8%A1%A8%E9%80%92%E5%BD%92%E4%B8%93%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><h1 id="为什么要写博客"><a class="markdownIt-Anchor" href="#为什么要写博客"></a> 为什么要写博客</h1><p>技术博客的内容固然重要，当然写作的背景和目的甚至比内容更重要。这就如同技术一样，知道技术本身重要，但是了解技术的提出背景和能够解决什么问题更重要。在文章的最后，总结博客的知识点以及存在的问题，这样方便引出下文，使得整套博客的内容有始有终，读起来有剧情感。</p><p>当然写博客是一个总结的过程，回顾自己的成长之路，看到自己努力的成果，这是一个正反馈的过程。回想一年多以前的自己，链表翻转的问题都不一定能够完整的写出来，但是经过一年多的刷题，自己再面对<code>Leetcode</code>上的题时，即使做不出来，也是会有思路的。</p><p>在这里讲一下自己的刷题过程，总体的策略就是按照<code>tag</code>进行刷题。具体来讲，每天早上在床上的时候，开始看一下题目，之后在洗漱、吃饭、走路的时候就可以想思路，甚至是实现的细节。有了电脑后去实现，如果成果就思考一下优化的方案；没成功的话，看看思路是不是正确，只会在接下来的空闲时间里去思考问题出在了哪里。在晚上洗脚时调试，临近睡觉之前看评论区的大神代码，毕竟代码一般都不会超过<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>40</mn></mrow><annotation encoding="application/x-tex">40</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">4</span><span class="mord">0</span></span></span></span>行代码。第二天早上尝试不同的方案去解题。这个过程虽是一个自信心受挫但是成长蛮快的阶段。</p><p>半年前就已经将<strong>链表</strong>专题的内容几乎做完，之后又做了<strong>二叉树</strong>专题，后续又做了<strong>递归回溯</strong>、<strong>动态规划</strong>等专题。经过不断的总结，把自己的做题的套路和心得记录下来，总结分享。</p><p>这篇博客主要介绍如何去使用<strong>递归</strong>解决<strong>链表</strong>问题，由浅入深，后续的博客中会使用<strong>递归</strong>解决<strong>二叉树</strong>等问题。</p><p><img src="/" alt="" / class="lazyload" data-src="https://cdn.jsdelivr.net/gh/jackymxp/image-bed/leetcode/00831rSTly1gcvfra4larj30u017de1t-20200322192003869.jpg"></p><h1 id="解决链表问题的一般技巧"><a class="markdownIt-Anchor" href="#解决链表问题的一般技巧"></a> 解决链表问题的一般技巧</h1><p>链表是通过带有指针域的节点相互连接成的一种线性结构，由于链表的这种天然的特性，一般都是通过修改链表中节点的指向完成链表的<strong>增删改查</strong>问题。修改链表节点的指针指向一般有非递归方法和递归法。</p><h2 id="1-非递归法"><a class="markdownIt-Anchor" href="#1-非递归法"></a> 1. 非递归法</h2><p><strong>通过修改指针的方式一般有以下几种技巧</strong>：</p><ul><li><p>设置虚拟头节点，但在函数最后返回之前，记得释放内存。</p></li><li><p>使用快慢指针，一般用于定位到中间节点或者判断链表是否有环问题。</p></li></ul><h2 id="2-递归法"><a class="markdownIt-Anchor" href="#2-递归法"></a> 2. 递归法</h2><ul><li><p><strong>递归法的原理</strong></p><p>由于链表是通过指针域连接的线性结构，所以可以把一个完整的链表看成若干个结构相同但是长更短的链表构成，这就相当于在递归函数中缩减了函数的规模。</p><p>当链表的长度短到一定的程度，就相当于递归函数的退出条件。</p><p>当对更短的节点修改了指针后，链表的局部达到了期望的结构。其余的链表也使用同样的方法即调用同一个函数来修改节点的指向，这样就完成了整体链表结构的修改。</p><p>这就是通过递归修改链表的原理，通过这个原理总结了编写递归函数的</p></li><li><p><strong>编写递归函数的三个步骤：</strong></p><ol><li>定义了一个递归函数<code>fun(ListNode*)</code>，一定要<strong>明确递归函数的功能，以及递归函数的返回值</strong>。这样是当传入头节点<code>head</code>并且执行完<code>fun(head)</code>函数后，链表的结构就应该改变成希望的样子。这个就是递归的功能。</li><li><strong>明确递归函数的退出条件</strong>。否则递归函数找不到出口，就一直递归下去，爆栈。</li><li>将链表拆成若干部分，一部分的头节点是<code>head</code>，另外一部分的头节点是<code>newHead</code>，<strong>根据定义的函数的功能，推理当执行完<code>fun(newHead)</code>的时候，链表变成了什么样子，这时<code>newHead</code>部分已经变成我们期望的链表结构。接下来就是应该如何修改<code>head</code>为头节点的链表的的指针，使得整个链表的结构和期望的结构相同</strong>。</li></ol><p><strong>理解递归的本质就是学会放弃思考，放弃你刨根问底的想法，切记千万不要进入递归函数中探索太多的细节，只要理解递归两层之间接口之间的关系，以及递归退出的条件</strong>。人脑的栈太小，探索不了太多细节就乱了。实在想探索递归函数运行的细节，就在纸上画图，画出每层递归函数的入口参数及返回值。<strong>至于为什么我们需要放弃思考而信任递归的结果，那是因为我们更相信数学归纳法。</strong></p></li></ul><p>好了，给出我的心得之后，但是这些就像是数学公式一样，如果不通过例题是很难知道怎么用这些公式一样。所以接下来就通过一些例题来体会一下如何写好递归函数。<strong>记住想要理解递归，就要放弃思考，放弃刨根问底的钻研精神。</strong></p><h1 id="翻转链表题"><a class="markdownIt-Anchor" href="#翻转链表题"></a> 翻转链表题</h1><h2 id="206-反转链表"><a class="markdownIt-Anchor" href="#206-反转链表"></a> <a href="https://leetcode-cn.com/problems/reverse-linked-list/" target="_blank" rel="noopener">206. 反转链表</a></h2><ol><li><p><strong>定义递归函数<code>ListNode* reverseList(ListNode* head)</code>功能以及返回值</strong>：</p><p>定义功能为：翻转以<code>head</code>为头节点的链表，并返回翻转后的链表的头节点。</p><p>根据定义的递归函数功能，首先将<code>reverseList</code>的作用范围放在整个链表，图中有绿色的阴影部分代表递归函数<code>reverseList</code>的作用范围，也就是将<code>head</code>作为参数传递给<code>reverseList(head)</code>作用的范围。</p><p><img src="/" alt="" / class="lazyload" data-src="https://tva1.sinaimg.cn/large/00831rSTly1gd2x4tff4nj318e0620u7.jpg"></p><p>当把<code>head</code>作为参数传递给递归函数<code>reverseList</code>作用后，根据定义的递归函数功能，这个函数就完成了整个链表的翻转，也就是期望的最终答案。</p><p><img src="/" alt="" / class="lazyload" data-src="https://tva1.sinaimg.cn/large/00831rSTly1gd2x4twjlmj315604kmxx.jpg"></p></li><li><p><strong>寻找递归函数退出条件和返回值</strong></p><p>当链表中只有一个节点或者没有节点的时候，不需要任何反转，就可以直接返回。</p> <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(!head || !head-&gt;next)</span><br><span class="line">    <span class="keyword">return</span> head;</span><br></pre></td></tr></table></figure></li><li><p><strong>缩小递归函数的规模，寻求层与层之间的关系</strong></p><p>为了缩小递归函数的规模，所以要将链表分成了两个部分，由于是每一个节点都要进行反转，所以要将链表分成长度分别为<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>1</mn></mrow><annotation encoding="application/x-tex">1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span>和<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>k</mi><mo>−</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">k-1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.77777em;vertical-align:-0.08333em;"></span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span>的两个链表，其中<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>k</mi></mrow><annotation encoding="application/x-tex">k</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span></span></span></span>是原链表的长度。两部分链表的头节点分别为<code>head</code>和<code>newHead</code>。当缩小递归函数的范围的时候，即将<code>newHead</code>作为参数传入到<code>reverseList</code>函数中，其中递归函数的作用范围表示成图。</p><p><img src="/" alt="" / class="lazyload" data-src="https://cdn.jsdelivr.net/gh/jackymxp/image-bed/leetcode/20200322101626.png"></p><p>当递归函数<code>reverseList(newHead)</code>执行完成后，根据递归函数的功能，这样就完成了长度为<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>k</mi><mo>−</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">k-1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.77777em;vertical-align:-0.08333em;"></span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span>部分链表的反转，除头节点外的其余节点都符合期望的结构。整个链表变成如下这个样子。</p><p><img src="/" alt="" / class="lazyload" data-src="https://cdn.jsdelivr.net/gh/jackymxp/image-bed/leetcode/20200322102043.png"></p><p>写成代码的形式：</p> <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ListNode* newHead = next-&gt;next;</span><br><span class="line">head-&gt;next = <span class="literal">nullptr</span>; <span class="comment">//将链表分成两个部分</span></span><br><span class="line">ListNode* retHead = reverseList(newHead);</span><br></pre></td></tr></table></figure><p>通过观察发现，只要在修改<code>head</code>和<code>newHead</code>的指针就完成了这个链表的反转。</p><p><strong>最后不要忘记让头节点<code>head-&gt;next</code>指向<code>nullptr</code>，否则递归函数找不到空节点，递归超时。这样就完成了翻转</strong>。写成代码如下：</p> <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">newHead-&gt;next = head;</span><br><span class="line">head-&gt;next = <span class="literal">nullptr</span>;</span><br></pre></td></tr></table></figure><p>当然除了上面一个一个减少递归的规模的话，我们还可以一半一半的减少，比如，我们每次翻转链表的一半，最后再将两部分合并起来。</p><p>问题的关键，我们如何把一个链表拆成两部分，上面的策略是将链表拆成了长度为<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>1</mn></mrow><annotation encoding="application/x-tex">1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span>和长度为<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>k</mi><mo>−</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">k-1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.77777em;vertical-align:-0.08333em;"></span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span>两个部分，现在将链表拆成长度相等的两个部分，所以问题是，如何定位到链表的中间节点，这里使用快慢指针定位到链表的中间节点。</p> <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">ListNode* fast = head;</span><br><span class="line">ListNode* slow = head;</span><br><span class="line">ListNode* mid = <span class="literal">NULL</span>;</span><br><span class="line"><span class="keyword">while</span>(fast &amp;&amp; fast-&gt;next)</span><br><span class="line">&#123;</span><br><span class="line">    fast = fast-&gt;next-&gt;next;</span><br><span class="line">    mid = slow;</span><br><span class="line">    slow = slow-&gt;next;</span><br><span class="line">&#125;</span><br><span class="line">mid-&gt;next = <span class="literal">NULL</span>;</span><br></pre></td></tr></table></figure><p>当定位到中间节点后，我们对每一部分都进行翻转</p><p><img src="/" alt="" / class="lazyload" data-src="https://cdn.jsdelivr.net/gh/jackymxp/image-bed/leetcode/20200403182532.png"></p><p>根据递归函数的功能，当执行完<code>reverseList(head)</code>和<code>reverseList(slow)</code>之后，每一部分都进行了翻转。</p><p><img src="/" alt="" / class="lazyload" data-src="https://cdn.jsdelivr.net/gh/jackymxp/image-bed/leetcode/20200403183121.png"></p><p>这时候后只要改变<code>slow-&gt;next = tmp</code>就可以。最后返回<code>tmp2</code>。</p> <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ListNode* tmp = reverseList(head);</span><br><span class="line">ListNode* retNode = reverseList(slow);</span><br><span class="line">slow-&gt;next = tmp;</span><br></pre></td></tr></table></figure></li><li><p><strong>递归代码</strong></p> <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">reverseList</span><span class="params">(ListNode* head)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//当链表中只有一个节点或者没有节点的时候，直接退出</span></span><br><span class="line">        <span class="keyword">if</span>(!head || !head-&gt;next)</span><br><span class="line">            <span class="keyword">return</span> head;</span><br><span class="line">        <span class="comment">//分成两个部分</span></span><br><span class="line">        ListNode* newHead = head-&gt;next;</span><br><span class="line">        head-&gt;next = <span class="literal">nullptr</span>;</span><br><span class="line">        <span class="comment">//完成 k - 1 部分的翻转</span></span><br><span class="line">        ListNode* retHead = reverseList(newHead);</span><br><span class="line">        <span class="comment">//修改指针，是最后一部分完成翻转</span></span><br><span class="line">        newHead-&gt;next = head;</span><br><span class="line">        head-&gt;next = <span class="literal">nullptr</span>;</span><br><span class="line">        <span class="keyword">return</span> retHead;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li><li><p><strong>迭代代码</strong></p> <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">reverseList</span><span class="params">(ListNode* head)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!head || !head-&gt;next)</span><br><span class="line">            <span class="keyword">return</span> head;</span><br><span class="line">        ListNode* pre = <span class="literal">nullptr</span>;</span><br><span class="line">        ListNode* cur = head;  <span class="comment">//pre -&gt; cur -&gt; next   ===&gt;&gt;&gt;   pre &lt;- cur &lt;- next</span></span><br><span class="line">        <span class="keyword">while</span>(cur)</span><br><span class="line">        &#123;</span><br><span class="line">            ListNode* next = cur-&gt;next; <span class="comment">//保存下一个节点</span></span><br><span class="line">            cur-&gt;next = pre; <span class="comment">//修改next指针是其指向 pre</span></span><br><span class="line">            <span class="comment">//pre和next都向后移动一位</span></span><br><span class="line">            pre = cur;  </span><br><span class="line">            cur = next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> pre;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ol><hr /><h2 id="24-两两交换链表中的节点"><a class="markdownIt-Anchor" href="#24-两两交换链表中的节点"></a> <a href="https://leetcode-cn.com/problems/swap-nodes-in-pairs/" target="_blank" rel="noopener">24. 两两交换链表中的节点</a></h2><p>还是按照递归的套路，分三步。</p><ol><li><p><strong>定义递归函数<code>ListNode* swapPairs(ListNode* head)</code>功能以及返回值</strong></p><p>定义递归函数功能：每两个翻转链表中的节点，并将翻转后新的链表节点作为返回值。</p><p>根据定义的递归函数功能，首先将<code>swapPairs</code>的作用范围放在整个链表，图中有绿色的阴影部分代表递归函数<code>swapPairs</code>的作用范围，也就是将就是将<code>head</code>作为参数传递给<code>swapPairs(head)</code>作用的范围。</p><p><img src="/" alt="" / class="lazyload" data-src="https://tva1.sinaimg.cn/large/00831rSTly1gcvk3rsggjj318e06imxj.jpg"></p><p>当把<code>head</code>作为参数传递给递归函数<code>swapPairs</code>作用后，根据定义的递归函数功能，这个函数就完成<strong>两两交换其中相邻的节点</strong>，并返回了交换后的链表的头节点<code>retHead</code>。</p><p><img src="/" alt="" / class="lazyload" data-src="https://cdn.jsdelivr.net/gh/jackymxp/image-bed/leetcode/20200322105029.png"></p></li><li><p><strong>寻找递归函数退出条件和返回值</strong></p><p>当链表中只有一个节点或者没有节点的时候，不需要任何反转，就可以直接返回。</p> <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(head == <span class="literal">nullptr</span> || head-&gt;next == <span class="literal">nullptr</span>)</span><br><span class="line">    <span class="keyword">return</span> head;</span><br></pre></td></tr></table></figure></li><li><p><strong>缩小递归函数的规模，寻求层与层之间的关系</strong></p><p>为了缩小递归函数的规模，所以要将链表分成了两个部分，由于是每一个节点都要进行反转，所以要将链表分成长度分别为<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>2</mn></mrow><annotation encoding="application/x-tex">2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">2</span></span></span></span>和<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>k</mi><mo>−</mo><mn>2</mn></mrow><annotation encoding="application/x-tex">k-2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.77777em;vertical-align:-0.08333em;"></span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">2</span></span></span></span>的两个链表，其中<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>k</mi></mrow><annotation encoding="application/x-tex">k</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span></span></span></span>是原链表的长度。两部分链表的头节点分别为<code>head</code>和<code>newHead</code>。当缩小递归函数的范围的时候，即将<code>newHead</code>作为参数传入到<code>swapPairs</code>函数中，其中递归函数的作用范围表示成图。</p><p><img src="/" alt="" / class="lazyload" data-src="https://cdn.jsdelivr.net/gh/jackymxp/image-bed/leetcode/20200322105844.png"></p><p>当递归函数<code>swapPairs(newHead)</code>执行完成后，根据递归函数的功能，除第一个和第二个节点没有符合期望的结构，其余节点都符合期望的结构。整个链表变成如下这个样子。</p><p><img src="/" alt="image-20200322110545833" / class="lazyload" data-src="https://tva1.sinaimg.cn/large/00831rSTly1gd2kg8bafij31100803za.jpg"></p><p>写成代码的形式：</p> <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//将链表分为两个部分</span></span><br><span class="line">ListNode* newHead = head-&gt;next-&gt;next;</span><br><span class="line">head-&gt;next-&gt;next = <span class="literal">nullptr</span>;</span><br><span class="line"><span class="comment">//递归反转长度为 k - 2 的链表部分</span></span><br><span class="line">ListNode* retNode = swapPairs(newHead);</span><br></pre></td></tr></table></figure><p>最后和预期的结构相对比，只要修改<code>head</code>、<code>newHead</code>的指针域，即可完成整个链表的两两节点的交换，写成代码：</p> <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//对照图片，完成长度为 2 的链表的节点交换</span></span><br><span class="line">ListNode* retHead = head-&gt;next;</span><br><span class="line">retHead-&gt;next = head;</span><br><span class="line">head-&gt;next = retNode;</span><br><span class="line"><span class="keyword">return</span> retHead;</span><br></pre></td></tr></table></figure></li><li><p><strong>递归代码</strong></p> <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">swapPairs</span><span class="params">(ListNode* head)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//递归退出条件，只有一个节点，或者没有节点的时候</span></span><br><span class="line">        <span class="keyword">if</span>(!head || !head-&gt;next)</span><br><span class="line">            <span class="keyword">return</span> head;</span><br><span class="line">        <span class="comment">//将链表分为两个部分</span></span><br><span class="line">        ListNode* newHead = head-&gt;next-&gt;next;</span><br><span class="line">        head-&gt;next-&gt;next = <span class="literal">nullptr</span>;</span><br><span class="line">        <span class="comment">//递归反转长度为 k - 2 的链表部分</span></span><br><span class="line">        ListNode* retNode = swapPairs(newHead);</span><br><span class="line">        <span class="comment">//通过修改长度为2部分链表的指针，完成这个链表的翻转</span></span><br><span class="line">        ListNode* retHead = head-&gt;next;</span><br><span class="line">        retHead-&gt;next = head;</span><br><span class="line">        head-&gt;next = retNode;</span><br><span class="line">        <span class="keyword">return</span> retHead;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li><li><p><strong>迭代代码</strong></p> <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">swapPairs</span><span class="params">(ListNode* head)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!head || !head-&gt;next)</span><br><span class="line">            <span class="keyword">return</span> head;</span><br><span class="line">        ListNode *first = head;</span><br><span class="line">        ListNode *second = head-&gt;next;</span><br><span class="line">        <span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">            ListNode *third = second-&gt;next;</span><br><span class="line">            <span class="comment">//交换</span></span><br><span class="line">            swap(second-&gt;val,first-&gt;val);</span><br><span class="line">            <span class="keyword">if</span>(!third || !third-&gt;next)<span class="keyword">return</span> head;</span><br><span class="line">            <span class="comment">//向前前进两步</span></span><br><span class="line">            first = third;</span><br><span class="line">            second = third-&gt;next;</span><br><span class="line">            third = third-&gt;next-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ol><hr /><h2 id="25-k-个一组翻转链表"><a class="markdownIt-Anchor" href="#25-k-个一组翻转链表"></a> <a href="https://leetcode-cn.com/problems/reverse-nodes-in-k-group/" target="_blank" rel="noopener">25. K 个一组翻转链表</a></h2><p>这道题在<code>leetcode</code>中被定义为难题，但是有前面的基础，当<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>k</mi><mo>=</mo><mn>2</mn></mrow><annotation encoding="application/x-tex">k=2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">2</span></span></span></span>的时候，就是<a href="https://leetcode-cn.com/problems/swap-nodes-in-pairs/" target="_blank" rel="noopener">两两交换链表中的节点</a>题；当<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>k</mi></mrow><annotation encoding="application/x-tex">k</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span></span></span></span>等于链表长度时，就是<a href="https://leetcode-cn.com/problems/reverse-linked-list/" target="_blank" rel="noopener">反转链表</a>题，所以做这个题就不是很难了，只需要做一小部分的改动就可以。下面根据递归套路的三个步骤，完成这个题。</p><ol><li><p><strong>定义递归函数<code>ListNode* reverseKGroup(ListNode* head, int k)</code>功能以及返回值</strong></p><p>定义递归函数功能：在链表中，每<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>k</mi></mrow><annotation encoding="application/x-tex">k</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span></span></span></span>个节点翻转一次，并将新的链表节点作为返回值。</p><p>根据定义的递归函数功能，首先将<code>reverseKGroup</code>的作用范围放在整个链表，图中有绿色的阴影部分代表递归函数<code>reverseKGroup</code>的作用范围，也就是将<code>head</code>作为参数传递给<code>reverseKGroup(head)</code>作用的范围。</p><p><img src="/" alt="" / class="lazyload" data-src="https://cdn.jsdelivr.net/gh/jackymxp/image-bed/leetcode/20200322120919.png"></p><p>当把<code>head</code>作为参数传递给递归函数<code>reverseKGroup</code>作用后，根据定义的递归函数功能，这个函数就完成以<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>k</mi></mrow><annotation encoding="application/x-tex">k</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span></span></span></span>个为一组进行翻转链表，并返回翻转后的链表头节点。假设这里<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>k</mi><mo>=</mo><mn>3</mn></mrow><annotation encoding="application/x-tex">k = 3</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">3</span></span></span></span>。</p><p><img src="/" alt="" / class="lazyload" data-src="https://cdn.jsdelivr.net/gh/jackymxp/image-bed/leetcode/20200322120958.png"></p></li><li><p><strong>寻找递归函数退出条件和返回值</strong></p><p>当链表中的节点的个数小于<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>k</mi></mrow><annotation encoding="application/x-tex">k</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span></span></span></span>的时候，不够一组，可以不需要做任何的翻转操作直接返回。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(NodeNumLessK(head, k) == <span class="literal">true</span>)</span><br><span class="line">    <span class="keyword">return</span> head;</span><br></pre></td></tr></table></figure></li><li><p><strong>缩小递归函数的规模，寻求层与层之间的关系</strong></p><p>为了缩小递归函数的规模，所以要将链表分成了两个部分，由于是每<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>k</mi></mrow><annotation encoding="application/x-tex">k</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span></span></span></span>节点反转，所以将链表分成长度分别为<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>k</mi></mrow><annotation encoding="application/x-tex">k</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span></span></span></span>和<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>n</mi><mo>−</mo><mi>k</mi></mrow><annotation encoding="application/x-tex">n-k</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.66666em;vertical-align:-0.08333em;"></span><span class="mord mathdefault">n</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span></span></span></span>的两个链表，其中<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">n</span></span></span></span>是原链表的长度。两部分链表的头节点分别为<code>head</code>和<code>newHead</code>。当缩小递归函数的范围的时候，即将<code>newHead</code>作为参数传入到<code>reverseKGroup</code>函数中，其中递归函数的作用范围表示成图。</p><p><img src="/" alt="" / class="lazyload" data-src="https://cdn.jsdelivr.net/gh/jackymxp/image-bed/leetcode/20200322121211.png"></p><p>当递归函数<code>reverseKGroup(newHead)</code>执行完成后，根据递归函数的功能，除前<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>k</mi></mrow><annotation encoding="application/x-tex">k</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span></span></span></span>个链表没有符合期望的结构，其余节点都符合期望的结构。整个链表变成如下这个样子。</p><p><img src="/" alt="image-20200322121314111" / class="lazyload" data-src="https://tva1.sinaimg.cn/large/00831rSTly1gd2x4ueqt7j31cm07o75j.jpg"></p><p>写成代码的形式：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//定位到第 k 个节点</span></span><br><span class="line">ListNode* newHead = head;</span><br><span class="line">ListNode* retNode;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; k; i++)&#123;</span><br><span class="line">    retNode = newHead;</span><br><span class="line">    newHead = newHead-&gt;next;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//将链表分成两个部分</span></span><br><span class="line">retNode-&gt;next = <span class="literal">nullptr</span>;</span><br><span class="line"><span class="comment">//递归反转长度为 n - k 的链表部分</span></span><br><span class="line">ListNode* retHead = reverseKGroup(newHead, k);</span><br></pre></td></tr></table></figure><p>最后和预期的结构相对比，只要翻转前<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>k</mi></mrow><annotation encoding="application/x-tex">k</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span></span></span></span>个链表的节点，再改变指针的指向就完成了所有节点按照<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>k</mi></mrow><annotation encoding="application/x-tex">k</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span></span></span></span>个一组翻转链表。写成代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">reverseList(head);</span><br><span class="line">    <span class="comment">//将第一部分和第二部分连接起来</span></span><br><span class="line">    head-&gt;next = retHead;</span><br><span class="line">    <span class="keyword">return</span> retNode;</span><br></pre></td></tr></table></figure></li><li><p><strong>递归代码</strong></p><p><strong>PS:</strong> 这段代码虽然有近<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>50</mn></mrow><annotation encoding="application/x-tex">50</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">5</span><span class="mord">0</span></span></span></span>行，但是抛出递归退出条件的判断和前面遇到的翻转链表的代码，当然还有很多注释之外，核心的代码不到<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>10</mn></mrow><annotation encoding="application/x-tex">10</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span><span class="mord">0</span></span></span></span>行，所以结合前面的图和注释很容易理解。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">NodeNumLessK</span><span class="params">(ListNode* p, <span class="keyword">int</span> k)</span></span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; k; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(p == <span class="literal">nullptr</span>)</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            p = p-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">ListNode* <span class="title">reverseList</span><span class="params">(ListNode* head)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//当只有一个节点或者没有节点，递归退出条件</span></span><br><span class="line">        <span class="keyword">if</span>(!head || !head-&gt;next)</span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line">        <span class="comment">//缩小递归规模</span></span><br><span class="line">        ListNode* newHead = reverseList(head-&gt;next);</span><br><span class="line">        <span class="comment">//改变层与层之间的关系</span></span><br><span class="line">        <span class="comment">//当head-&gt;next部分完成反转后，改变指针指向，完成整个链表的翻转</span></span><br><span class="line">        head-&gt;next-&gt;next = head;</span><br><span class="line">        <span class="comment">//将head-&gt;next置空，否则找不到空节点，递归超时</span></span><br><span class="line">        head-&gt;next = <span class="literal">nullptr</span>;</span><br><span class="line">        <span class="keyword">return</span> newHead;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">ListNode* <span class="title">reverseKGroup</span><span class="params">(ListNode* head, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//当链表节点小于k的时候，直接退出</span></span><br><span class="line">        <span class="keyword">if</span>(NodeNumLessK(head, k))</span><br><span class="line">            <span class="keyword">return</span> head;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//定位到第 k 个节点</span></span><br><span class="line">        ListNode* newHead = head;</span><br><span class="line">        ListNode* retNode;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; k; i++)&#123;</span><br><span class="line">            retNode = newHead;</span><br><span class="line">            newHead = newHead-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//将链表分成两个部分</span></span><br><span class="line">        retNode-&gt;next = <span class="literal">nullptr</span>;</span><br><span class="line">        <span class="comment">//递归反转长度为 n - k 的链表部分</span></span><br><span class="line">        ListNode* retHead = reverseKGroup(newHead, k);</span><br><span class="line"></span><br><span class="line">        reverseList(head);</span><br><span class="line">        <span class="comment">//将第一部分和第二部分连接起来</span></span><br><span class="line">        head-&gt;next = retHead;</span><br><span class="line">        <span class="keyword">return</span> retNode;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ol><hr /><h1 id="合并链表题"><a class="markdownIt-Anchor" href="#合并链表题"></a> 合并链表题</h1><p>翻转链表类型的题目，涉及的都是直接修改链表的指针指向，在合并链表的过程中，涉及的还是修改指针的指向，唯一不同的是，链表翻转是一个链表的，而合并链表的题可能涉及到多个链表，但是也只是单纯的改变指针指。</p><h2 id="21-合并两个有序链表"><a class="markdownIt-Anchor" href="#21-合并两个有序链表"></a> <a href="https://leetcode-cn.com/problems/merge-two-sorted-lists/" target="_blank" rel="noopener">21. 合并两个有序链表</a></h2><p>还是按照递归的三个步骤</p><ol><li><p><strong>定义递归函数<code>ListNode* mergeTwoLists(ListNode* l1, ListNode* l2)</code>功能以及返回值</strong></p><p>合并两个已经排序的链表，并且返回排序后链表的头节点。</p><p>根据这个定义，当传入两个如下所示的链表，应该返回的是这样的链表。</p><p><img src="/" alt="" / class="lazyload" data-src="https://tva1.sinaimg.cn/large/00831rSTly1gcwo90kk3fj31ly0pqmz2.jpg"></p></li><li><p><strong>寻找递归函数退出条件和返回值</strong></p><p>当两个链表中有一个链表为空的时候，不管另外一个链表是否为空，都直接返回另外一个链表。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(!l1 || !l2)</span><br><span class="line">    <span class="keyword">return</span> l1 ? l1 : l2;</span><br></pre></td></tr></table></figure></li><li><p><strong>缩小递归函数的规模，寻求层与层之间的关系</strong></p><p>为了缩小递归函数的规模，所以要将链表分成了两个部分，由于是合并链表，所以将链表分成已排序的和未排序的链表两个部分。合并的过程从两个链表的头节点开始，<code>p1</code>的头节点值小于<code>p2</code>的值，所以<code>p1</code>的头节点就是合并后的链表的头节点。 将<code>p1</code>节点单独拿出来，并且保存<code>p1</code>节点的下一个节点为<code>pn</code>。此时<code>p1</code>节点已经是有序的。</p><p>继续合并链表中的剩余节点，发现<code>pn</code>和<code>p2</code>依然是一个合并有序链表的过程，还是依然比较两个头节点的值，所以这个过程依然可以调用<code>mergeTwoLists(pn, p2)</code>完成链表剩余部分的排序。</p><p><img src="/" alt="" / class="lazyload" data-src="https://tva1.sinaimg.cn/large/00831rSTly1gcwoqo4jfvj312u0k0my8.jpg"></p><p>当递归函数 <code>mergeTwoLists(pn, p2)</code> 执行完成后，根据递归函数的功能，<code>pn</code>和<code>p2</code>链表已经形成一个有序的链表，所以整个链表变成如下这个样子。</p><p>将链表的两部分连接起来，所以将<code>p1-&gt;next</code>指向<code>retNode</code>。</p><p><img src="/" alt="" / class="lazyload" data-src="https://cdn.jsdelivr.net/gh/jackymxp/image-bed/leetcode/20200322203408.png"></p><p>将上述过程写成代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(p1-&gt;val &lt; p2-&gt;val)</span><br><span class="line">&#123;</span><br><span class="line">    ListNode* pn = l1-&gt;next;</span><br><span class="line">    l1-&gt;next = <span class="literal">nullptr</span>;</span><br><span class="line">    ListNode* retNode = mergeTwoLists(pn, p2);</span><br><span class="line">    p1-&gt;next = retNode;</span><br><span class="line">    <span class="keyword">return</span> p1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当<code>p2</code>的值小于<code>p1</code>的值时，合并的过程还是这个样子的。</p><p><img src="/" alt="" / class="lazyload" data-src="https://cdn.jsdelivr.net/gh/jackymxp/image-bed/leetcode/20200322205036.png"></p></li><li><p><strong>完整代码</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">mergeTwoLists</span><span class="params">(ListNode* l1, ListNode* l2)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//当有一个链表为空的时候，直接返回另外一个链表，不管另外一个是否为空</span></span><br><span class="line">        <span class="keyword">if</span>(!l1 || !l2)</span><br><span class="line">            <span class="keyword">return</span> l1 ? l1 : l2;</span><br><span class="line">        <span class="comment">//当l1-&gt;val 小于l2-&gt;val, 直接将l1-&gt;next指向递归的下一层</span></span><br><span class="line">        <span class="keyword">if</span>(l1-&gt;val &lt; l2-&gt;val)</span><br><span class="line">        &#123;</span><br><span class="line">            l1-&gt;next = mergeTwoLists(l1-&gt;next, l2);</span><br><span class="line">            <span class="keyword">return</span> l1;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            l2-&gt;next = mergeTwoLists(l1, l2-&gt;next);</span><br><span class="line">            <span class="keyword">return</span> l2;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ol><h2 id="23-合并k个排序链表"><a class="markdownIt-Anchor" href="#23-合并k个排序链表"></a> <a href="https://leetcode-cn.com/problems/merge-k-sorted-lists/" target="_blank" rel="noopener">23. 合并K个排序链表</a></h2><p>有了<a href="https://leetcode-cn.com/problems/merge-two-sorted-lists/" target="_blank" rel="noopener">合并两个有序链表</a>基础，解决这道题的基本思路还是一样，这次不画图，只是根据定义的递归函数<code>ListNode* mergeKLists(vector&lt;ListNode*&gt;&amp; lists)</code>和上一题的<code>ListNode* mergeTwoLists(ListNode* l1, ListNode* l2)</code>的函数基础，单纯的推导出如何合并<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>k</mi></mrow><annotation encoding="application/x-tex">k</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span></span></span></span>个链表。</p><p>还是按照递归的三个步骤继续走起。</p><ol><li><p><strong>定义递归函数<code>ListNode* mergeKLists(vector&lt;ListNode*&gt;&amp; lists)</code>功能以及返回值</strong></p><p>定义递归函数功能：按照从小达到的顺序合并<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>k</mi></mrow><annotation encoding="application/x-tex">k</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span></span></span></span>个有序链表，并返回排序后链表的头节点。</p></li><li><p><strong>寻找递归函数退出条件和返回值</strong></p><p>想一下，这时候的递归的退出条件是什么？很简单，无非就是讨论<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>k</mi></mrow><annotation encoding="application/x-tex">k</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span></span></span></span>的值。</p><ul><li>当<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>k</mi><mo>=</mo><mn>0</mn></mrow><annotation encoding="application/x-tex">k = 0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">0</span></span></span></span>时，不需要返回任何链表，所以直接返回<code>nullptr</code>。</li><li>当<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>k</mi><mo>=</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">k = 1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span>时，只有一个链表，不需要合并操作，直接返回<code>lists[0]</code>。</li><li>当<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>k</mi><mo>=</mo><mn>2</mn></mrow><annotation encoding="application/x-tex">k = 2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">2</span></span></span></span>时，这个就是合并两个有序链表，直接调用<code>ListNode* mergeTwoLists(lists[0], lists[1])</code>完成合并。</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(k == <span class="number">0</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(k == <span class="number">1</span>)</span><br><span class="line">    <span class="keyword">return</span> lists[<span class="number">0</span>];</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(k == <span class="number">2</span>)</span><br><span class="line">    <span class="keyword">return</span> mergeTwoLists(lists[<span class="number">0</span>], lists[<span class="number">1</span>]);</span><br></pre></td></tr></table></figure></li><li><p><strong>缩小递归函数的规模，寻求层与层之间的关系</strong></p><p>为了缩小递归函数的规模，所以要将<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>k</mi></mrow><annotation encoding="application/x-tex">k</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span></span></span></span>个链表分成了两个部分，但是每个部分有多少个链表，这里可以有不同的分配策略。</p><p><strong>策略1：</strong></p><p>将<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>k</mi></mrow><annotation encoding="application/x-tex">k</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span></span></span></span>个链表拆分成两部分，其中一部分的链表规模是<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>1</mn></mrow><annotation encoding="application/x-tex">1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span>，另外一部分链表的规模时<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>k</mi><mo>−</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">k-1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.77777em;vertical-align:-0.08333em;"></span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span>。当有<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>k</mi></mrow><annotation encoding="application/x-tex">k</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span></span></span></span>个链表的时候，调用的是<code>mergeKLists</code>函数，那么当<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>k</mi><mo>=</mo><mi>k</mi><mo>−</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">k = k-1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.77777em;vertical-align:-0.08333em;"></span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span>时并且<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>k</mi><mo>−</mo><mn>1</mn><mo>&gt;</mo><mn>2</mn></mrow><annotation encoding="application/x-tex">k-1 &gt; 2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.77777em;vertical-align:-0.08333em;"></span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.68354em;vertical-align:-0.0391em;"></span><span class="mord">1</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">&gt;</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">2</span></span></span></span>时，依然可以调用<code>mergeKLists(lists[0...k-2])</code>函数合并<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>k</mi><mo>−</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">k-1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.77777em;vertical-align:-0.08333em;"></span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span>个链表，并返回一个排序的链表头节点<code>node</code>，再和规模为<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>1</mn></mrow><annotation encoding="application/x-tex">1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span>的第<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>k</mi></mrow><annotation encoding="application/x-tex">k</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span></span></span></span>个链表做合并两个排序链表的过程，即调用<code>mergeTwoLists(node, lists[k-1])</code>，再返回。</p><p>对应的代码</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ListNode* node = mergeKLists(<span class="built_in">vector</span>&lt;ListNode*&gt;(lists.begin(), lists.end()<span class="number">-1</span>));</span><br><span class="line"><span class="keyword">return</span> mergeTwoLists(node, lists[lists.size()<span class="number">-1</span>]);</span><br></pre></td></tr></table></figure><p>这样的合并策略由于每次只能合并一条链表，所以递归深度比较深，所以性能开销比较大。</p><p><strong>策略2:</strong></p><p>仿照归并排序，将<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>k</mi></mrow><annotation encoding="application/x-tex">k</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span></span></span></span>个链表分成<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>2</mn></mrow><annotation encoding="application/x-tex">2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">2</span></span></span></span>个部分，每部分有<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>k</mi><mi mathvariant="normal">/</mi><mn>2</mn></mrow><annotation encoding="application/x-tex">k/2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span><span class="mord">/</span><span class="mord">2</span></span></span></span>个链表。当<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>k</mi><mo>=</mo><mi>k</mi><mi mathvariant="normal">/</mi><mn>2</mn></mrow><annotation encoding="application/x-tex">k = k/2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span><span class="mord">/</span><span class="mord">2</span></span></span></span>时并且<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>k</mi><mi mathvariant="normal">/</mi><mn>2</mn><mo>&gt;</mo><mn>2</mn></mrow><annotation encoding="application/x-tex">k/2 &gt; 2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span><span class="mord">/</span><span class="mord">2</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">&gt;</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">2</span></span></span></span>时，依然可以调用<code>mergeKLists(lists[0...k/2))</code>和<code>mergeKLists(lists[k/2...k))</code>函数合并<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>k</mi><mi mathvariant="normal">/</mi><mn>2</mn></mrow><annotation encoding="application/x-tex">k/2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span><span class="mord">/</span><span class="mord">2</span></span></span></span>个链表，每部分都会返回排序<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>k</mi><mi mathvariant="normal">/</mi><mn>2</mn></mrow><annotation encoding="application/x-tex">k/2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span><span class="mord">/</span><span class="mord">2</span></span></span></span>个链表的头节点<code>node1</code>和<code>node2</code>，这时候再调用<code>mergeTwoLists(node1, node2)</code>，再返回。</p><p>对应的代码</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="built_in">vector</span>&lt;ListNode*&gt; <span class="title">front</span><span class="params">(lists.begin(), lists.begin()+len/<span class="number">2</span>)</span></span>;</span><br><span class="line"><span class="function"><span class="built_in">vector</span>&lt;ListNode*&gt; <span class="title">back</span><span class="params">(lists.begin()+len/<span class="number">2</span>, lists.end())</span></span>;</span><br><span class="line"><span class="comment">//合并前k/2个链表</span></span><br><span class="line">ListNode* node1 = mergeKLists(front);</span><br><span class="line"><span class="comment">//合并后k/2个链表</span></span><br><span class="line">ListNode* node2 = mergeKLists(back);</span><br><span class="line"><span class="comment">//将两个链表合并的结果使用合并两个链表函数合并</span></span><br><span class="line"><span class="keyword">return</span> mergeTwoLists(node1, node2);</span><br></pre></td></tr></table></figure></li><li><p><strong>完整代码</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line">    <span class="function">ListNode* <span class="title">mergeTwoLists</span><span class="params">(ListNode* l1, ListNode* l2)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//当有一个链表为空的时候，直接返回另外一个链表，不管另外一个是否为空</span></span><br><span class="line">        <span class="keyword">if</span>(!l1 || !l2)</span><br><span class="line">            <span class="keyword">return</span> l1 ? l1 : l2;</span><br><span class="line">        <span class="comment">//当l1-&gt;val 小于l2-&gt;val, 直接将l1-&gt;next指向递归的下一层</span></span><br><span class="line">        <span class="keyword">if</span>(l1-&gt;val &lt; l2-&gt;val)</span><br><span class="line">        &#123;</span><br><span class="line">            l1-&gt;next = mergeTwoLists(l1-&gt;next, l2);</span><br><span class="line">            <span class="keyword">return</span> l1;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            l2-&gt;next = mergeTwoLists(l1, l2-&gt;next);</span><br><span class="line">            <span class="keyword">return</span> l2;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">mergeKLists</span><span class="params">(<span class="built_in">vector</span>&lt;ListNode*&gt;&amp; lists)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> len = lists.size();</span><br><span class="line">        <span class="keyword">if</span>(len == <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(len == <span class="number">1</span>)</span><br><span class="line">            <span class="keyword">return</span> lists[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(len == <span class="number">2</span>)</span><br><span class="line">            <span class="keyword">return</span> mergeTwoLists(lists[<span class="number">0</span>], lists[<span class="number">1</span>]);</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">vector</span>&lt;ListNode*&gt; front(lists.begin(), lists.begin()+len/<span class="number">2</span>);</span><br><span class="line">            <span class="function"><span class="built_in">vector</span>&lt;ListNode*&gt; <span class="title">back</span><span class="params">(lists.begin()+len/<span class="number">2</span>, lists.end())</span></span>;</span><br><span class="line">            ListNode* node1 = mergeKLists(front);</span><br><span class="line">            ListNode* node2 = mergeKLists(back);</span><br><span class="line">            <span class="keyword">return</span> mergeTwoLists(node1, node2);</span><br><span class="line">        &#125;         </span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ol><h2 id="148-排序链表"><a class="markdownIt-Anchor" href="#148-排序链表"></a> <a href="https://leetcode-cn.com/problems/sort-list/" target="_blank" rel="noopener">148. 排序链表</a></h2><p>这个题要求使用<code>O(nlogn)</code>的时间复杂度，只有快速排序、堆排序、归并排序符合这个时间的复杂度为了复用上面实现的合并两个有序链表的代码， 采用<strong>归并排序</strong>。</p><p>还是原来的套路，分三步继续走。Let’s go。</p><ol><li><p><strong>定义递归函数<code>ListNode* sortList(ListNode* head)</code>功能以及返回值</strong>：</p><p>根据定义的递归函数功能，首先将<code>sortList</code>的作用范围放在整个链表，图中有绿色的阴影部分代表递归函数<code>sortList</code>的作用范围，也就是将<code>head</code>作为参数传递给<code>sortList(head)</code>作用的范围。</p><p><img src="/" alt="" / class="lazyload" data-src="https://cdn.jsdelivr.net/gh/jackymxp/image-bed/leetcode/20200322222549.png"></p><p>当把<code>head</code>作为参数传递给递归函数<code>sortList</code>作用后，根据定义的递归函数功能，这个函数就完成了整个链表的排序，也就是期望的最终答案。</p><p><img src="/" alt="" / class="lazyload" data-src="https://cdn.jsdelivr.net/gh/jackymxp/image-bed/leetcode/20200322222859.png"></p></li><li><p><strong>寻找递归函数退出条件和返回值</strong></p><p>当链表长度为<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>1</mn></mrow><annotation encoding="application/x-tex">1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span>或者<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>0</mn></mrow><annotation encoding="application/x-tex">0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">0</span></span></span></span>时，就不用排序，直接返回就可以。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(!head || !head-&gt;next)</span><br><span class="line">    <span class="keyword">return</span> head;</span><br></pre></td></tr></table></figure></li><li><p><strong>缩小递归函数的规模，寻求层与层之间的关系</strong></p><p>在这里思考，如何缩小递归的规模，也就是让<code>sortList</code>中传入的链表长度减少，那就是将链表分为两个部分，分别对链表的每一个部分进行排序。具体怎么分有不同的策略，也可以仿照上题的策略，但是比较高效的方法是每部分链表长度分别为原来的<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>1</mn><mi mathvariant="normal">/</mi><mn>2</mn></mrow><annotation encoding="application/x-tex">1/2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mord">/</span><span class="mord">2</span></span></span></span>。也就是从中间断开链表。所以涉及到的问题是，如何寻找一个链表的中点？</p><p>这里使用快慢指针，快指针一次走两步，慢指针一次走一步，当快指针到尾部的时候，慢指针刚好走到链表的中点。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">ListNode* fast = head;</span><br><span class="line">ListNode* slow = head;</span><br><span class="line">ListNode* mid = <span class="literal">nullptr</span>;</span><br><span class="line"><span class="keyword">while</span>(fast &amp;&amp; fast-&gt;next)</span><br><span class="line">&#123;</span><br><span class="line">    fast = fast-&gt;next-&gt;next;</span><br><span class="line">    mid = slow;</span><br><span class="line">    slow = slow-&gt;next;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//为了使的链表成为两个独立的部分，将slow的next置空</span></span><br><span class="line">slow-&gt;next = <span class="literal">nullptr</span>;</span><br><span class="line"><span class="comment">//此时[head, slow] 是链表的前一个部分</span></span><br><span class="line"><span class="comment">//[mid, end)是链表的后一个部分。</span></span><br></pre></td></tr></table></figure><p>找到中点后，可以调用<code>p1 = sortList(head)</code> 和<code>p2 = sortList(mid)</code>分别对原链表的两部分进行了排序。</p><p><img src="/" alt="" / class="lazyload" data-src="https://cdn.jsdelivr.net/gh/jackymxp/image-bed/leetcode/20200322223155.png"></p><p>根据定义递归函数的功能，就是排序一个链表，所以当<code>p1 = sortList(head)</code> 和<code>p2 = sortList(mid)</code>执行之后，整个链表变成如下这个样子。</p><p><img src="/" alt="" / class="lazyload" data-src="https://cdn.jsdelivr.net/gh/jackymxp/image-bed/leetcode/20200322223416.png"></p><p>那么接下来的问题时，就是如何合并两个已经排序的链表呢？咦，这不是<a href="https://leetcode-cn.com/problems/merge-two-sorted-lists/" target="_blank" rel="noopener"> 合并两个有序链表</a>这个题嘛。所以直接调用<code>mergeTwoLists(node1, node2)</code>合并两个排序链表。</p><p>最后上一张图来表示一下这一个过程。其中绿色的阴影部分表示的是使用<code>sortList</code>函数，粉色的阴影表示的是<code>mergeTwoLists</code>作用范围。</p><p><img src="/" alt="" / class="lazyload" data-src="https://tva1.sinaimg.cn/large/00831rSTly1gcx9ggnj0dj31r70u07bp.jpg"></p></li><li><p><strong>完整代码</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line">    <span class="function">ListNode* <span class="title">merge</span><span class="params">(ListNode* p1, ListNode* p2)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!p1 || !p2)</span><br><span class="line">            <span class="keyword">return</span> p1 ? p1 : p2;</span><br><span class="line">        <span class="keyword">if</span>(p1-&gt;val &lt; p2-&gt;val)</span><br><span class="line">        &#123;</span><br><span class="line">            p1-&gt;next = merge(p1-&gt;next, p2);</span><br><span class="line">            <span class="keyword">return</span> p1;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> </span><br><span class="line">        &#123;</span><br><span class="line">            p2-&gt;next = merge(p1, p2-&gt;next);</span><br><span class="line">            <span class="keyword">return</span> p2;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">sortList</span><span class="params">(ListNode* head)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!head || !head-&gt;next)</span><br><span class="line">            <span class="keyword">return</span> head;</span><br><span class="line">        <span class="comment">//定位到mid</span></span><br><span class="line">        ListNode* fast = head;</span><br><span class="line">        ListNode* slow = head;</span><br><span class="line">        ListNode* mid = <span class="literal">nullptr</span>;</span><br><span class="line">        <span class="keyword">while</span>(fast &amp;&amp; fast-&gt;next)</span><br><span class="line">        &#123;</span><br><span class="line">            fast = fast-&gt;next-&gt;next;</span><br><span class="line">            mid = slow;</span><br><span class="line">            slow = slow-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        mid-&gt;next = <span class="literal">nullptr</span>;</span><br><span class="line">        <span class="comment">//分别对链表的两个部分进行排序。</span></span><br><span class="line">        ListNode* node1 = sortList(head);</span><br><span class="line">        ListNode* node2 = sortList(slow);</span><br><span class="line">        <span class="comment">//对两个已经排好序的链表进行合并。</span></span><br><span class="line">        <span class="keyword">return</span> merge(node1, node2);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ol><h2 id="2-两数相加"><a class="markdownIt-Anchor" href="#2-两数相加"></a> <a href="https://leetcode-cn.com/problems/add-two-numbers/" target="_blank" rel="noopener">2. 两数相加</a></h2><p>为什么我把这个题归结于合并链表题呢？其实上面三道题可以看作以链表的值的大小进行合并的一种方式，这个题不是根据大小进行合并，而是以“加法”操作对链表进行合并。那么我们看下在链表中如何按照&quot;加法&quot;这种操作对链表进行操作。</p><p>还是按照递归的三个步骤进行。</p><ol><li><p><strong>定义递归函数<code>ListNode* addTwoNumbers(ListNode* l1, ListNode* l2)</code>功能以及返回值</strong>：</p><p>定义递归函数功能：对链表<code>l1</code>和<code>l2</code>按照题目给定的规则进行合并，并返回合并后链表的头节点。</p><p>根据我们定义的递归的函数的功能，首先将<code>addTwoNumbers</code>作用范围放在整个链表，图中有绿色的阴影部分代表递归函数<code>addTwoNumbers</code>的作用范围，也就是将<code>p1</code>和<code>p2</code>作为参数传递给<code>addTwoNumbers(p1, p2)</code>作用的范围。</p><img src="/" style="zoom:50%;" / class="lazyload" data-src="https://cdn.jsdelivr.net/gh/jackymxp/image-bed/leetcode/20200322224858.png"><p>当把 <code>p1</code>和<code>p2</code> 作为参数传递给递归函数 <code>addTwoNumbers</code> 作用后，根据定义的递归函数功能，这个函数就完成了整个链表的相加，也就是期望的最终答案。</p><img src="/" style="zoom:50%;" / class="lazyload" data-src="https://cdn.jsdelivr.net/gh/jackymxp/image-bed/leetcode/20200322224942.png"></li><li><p><strong>寻找递归函数退出条件和返回值</strong></p><p>当有一个链表为空的时候，直接返回另外一个链表，不管另外一个链表是否为空。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(!l1 || !l2)</span><br><span class="line">    <span class="keyword">return</span> l1 ? l1 : l2;</span><br></pre></td></tr></table></figure></li><li><p><strong>缩小递归函数的规模，寻求层与层之间的关系</strong></p><p>如何缩小递归函数的规模呢，在这里只有一种选择，就是每次将<code>p1</code>和<code>p2</code>的指针后移一位，再次调用<code>node = addTwoNumbers(pm, pn)</code>完成剩余部分的加法合并。</p><img src="/" style="zoom:50%;" / class="lazyload" data-src="https://cdn.jsdelivr.net/gh/jackymxp/image-bed/leetcode/20200322225336.png"><p>当执行完<code>addTwoNumbers(pm, pn)</code>后，整个链表变成如下结构：</p><img src="/" style="zoom:50%;" / class="lazyload" data-src="https://tva1.sinaimg.cn/large/00831rSTly1gd33kz06wmj30pw0hi3z4.jpg"><p>为了将已经相加的链表和未相加的链表连接在一起，令<code>sum = p1-&gt;val + p2-&gt;val</code> 。</p><p>这里就需要对<code>sum</code>的值进行考虑，如果<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>s</mi><mi>u</mi><mi>m</mi><mo>&lt;</mo><mn>10</mn></mrow><annotation encoding="application/x-tex">sum &lt; 10</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.5782em;vertical-align:-0.0391em;"></span><span class="mord mathdefault">s</span><span class="mord mathdefault">u</span><span class="mord mathdefault">m</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">&lt;</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span><span class="mord">0</span></span></span></span>，如上图所示，直接重新分配一个值为<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>s</mi><mi>u</mi><mi>m</mi></mrow><annotation encoding="application/x-tex">sum</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">s</span><span class="mord mathdefault">u</span><span class="mord mathdefault">m</span></span></span></span>的节点<code>head</code>，并直接修改指针<code>head-&gt;next = node</code>即可。</p><img src="/" style="zoom:50%;" / class="lazyload" data-src="https://cdn.jsdelivr.net/gh/jackymxp/image-bed/leetcode/20200322230427.png"><p>当<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>s</mi><mi>u</mi><mi>m</mi><mo>&lt;</mo><mn>10</mn></mrow><annotation encoding="application/x-tex">sum &lt; 10</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.5782em;vertical-align:-0.0391em;"></span><span class="mord mathdefault">s</span><span class="mord mathdefault">u</span><span class="mord mathdefault">m</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">&lt;</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span><span class="mord">0</span></span></span></span>的逻辑代码如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(sum &lt; <span class="number">10</span>)</span><br><span class="line">&#123;</span><br><span class="line">    ListNode* node = addTwoNumbers(p1-&gt;next, p2-&gt;next);</span><br><span class="line">    ListNode* head = <span class="keyword">new</span> ListNode(sum);</span><br><span class="line">    head-&gt;next = node;</span><br><span class="line"><span class="keyword">return</span> node;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>但是当<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>s</mi><mi>u</mi><mi>m</mi><mo>&gt;</mo><mo>=</mo><mn>10</mn></mrow><annotation encoding="application/x-tex">sum &gt;= 10</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.5782em;vertical-align:-0.0391em;"></span><span class="mord mathdefault">s</span><span class="mord mathdefault">u</span><span class="mord mathdefault">m</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">&gt;</span></span><span class="base"><span class="strut" style="height:0.36687em;vertical-align:0em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span><span class="mord">0</span></span></span></span>是，要考虑到进位，这才是本题的难点。</p><p>如果<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>s</mi><mi>u</mi><mi>m</mi><mo>&gt;</mo><mo>=</mo><mn>10</mn></mrow><annotation encoding="application/x-tex">sum &gt;= 10</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.5782em;vertical-align:-0.0391em;"></span><span class="mord mathdefault">s</span><span class="mord mathdefault">u</span><span class="mord mathdefault">m</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">&gt;</span></span><span class="base"><span class="strut" style="height:0.36687em;vertical-align:0em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span><span class="mord">0</span></span></span></span>时，新分配一个值为<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>s</mi><mi>u</mi><mi>m</mi><mtext>  </mtext><mi>m</mi><mi>o</mi><mi>d</mi><mtext>  </mtext><mn>10</mn></mrow><annotation encoding="application/x-tex">sum \; mod \; 10</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault">s</span><span class="mord mathdefault">u</span><span class="mord mathdefault">m</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mord mathdefault">m</span><span class="mord mathdefault">o</span><span class="mord mathdefault">d</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mord">1</span><span class="mord">0</span></span></span></span>的节点<code>head</code>是不够的， 还需要分配一个值为<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>1</mn></mrow><annotation encoding="application/x-tex">1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span>的节点<code>flag</code>，在这里我们要如何处理这个进位操作呢？</p><p>其实很简单，只需要让<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>1</mn></mrow><annotation encoding="application/x-tex">1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span>与已经相加的<code>node</code>链表再做一次相加操作，即只需要让调用<code>addTwoNumbers(node, flag)</code>操作即可。</p><img src="/" style="zoom:50%;" / class="lazyload" data-src="https://cdn.jsdelivr.net/gh/jackymxp/image-bed/leetcode/20200322231503.png"><img src="/" style="zoom:50%;" / class="lazyload" data-src="https://tva1.sinaimg.cn/large/00831rSTly1gd3473mmy6j30o00eqdgl.jpg"><p>为了看的更加清楚，我将其画在了一起，其中绿色的部分代表递归已经完成了，其实应该等价于一个链表<code>next</code>，在这里为了看清楚，没有将其化为一个链表。</p><p><img src="/" alt="" / class="lazyload" data-src="https://tva1.sinaimg.cn/large/00831rSTly1gcxb7z847xj31rw0skq54.jpg"></p><p>这样当<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>s</mi><mi>u</mi><mi>m</mi><mo>&gt;</mo><mo>=</mo><mn>10</mn></mrow><annotation encoding="application/x-tex">sum &gt;= 10</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.5782em;vertical-align:-0.0391em;"></span><span class="mord mathdefault">s</span><span class="mord mathdefault">u</span><span class="mord mathdefault">m</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">&gt;</span></span><span class="base"><span class="strut" style="height:0.36687em;vertical-align:0em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span><span class="mord">0</span></span></span></span>大于<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>10</mn></mrow><annotation encoding="application/x-tex">10</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span><span class="mord">0</span></span></span></span>时的逻辑如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(sum &gt;= <span class="number">10</span>)</span><br><span class="line">&#123;</span><br><span class="line">    ListNode* node = addTwoNumbers(p1-&gt;next, p2-&gt;next);</span><br><span class="line">    ListNode* head = <span class="keyword">new</span> ListNode(sum % <span class="number">10</span>);</span><br><span class="line">    head-&gt;next = addTwoNumbers(node, <span class="keyword">new</span> ListNode(<span class="number">1</span>));</span><br><span class="line">    <span class="keyword">return</span> head;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><strong>完整代码</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">addTwoNumbers</span><span class="params">(ListNode* l1, ListNode* l2)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//递归退出条件，当有一个为空或者两个都为空</span></span><br><span class="line">        <span class="keyword">if</span>(!l1 || !l2)</span><br><span class="line">            <span class="keyword">return</span> l1 ? l1 : l2;</span><br><span class="line">        <span class="comment">//这里l1和l2都不为空，所以可以直接访问l1-&gt;val 和 l2-&gt;val</span></span><br><span class="line">        <span class="keyword">int</span> sum = l1-&gt;val + l2-&gt;val;</span><br><span class="line">        ListNode* newNode = <span class="keyword">new</span> ListNode(sum % <span class="number">10</span>);</span><br><span class="line">        <span class="comment">//保存l1-&gt;next和l2-&gt;next的addTwoNumbers结果</span></span><br><span class="line">        ListNode* nextNode = addTwoNumbers(l1-&gt;next, l2-&gt;next);</span><br><span class="line">        <span class="comment">//当sum小于10的时候，不会产生进位，所以直接赋值给next就可以</span></span><br><span class="line">        <span class="keyword">if</span>(sum &lt; <span class="number">10</span>)</span><br><span class="line">            newNode-&gt;next = nextNode;</span><br><span class="line">        <span class="keyword">else</span><span class="comment">//sum &gt;= 10,则需要将产生的结果和1做加法的结果赋值给next</span></span><br><span class="line">            newNode-&gt;next = addTwoNumbers(nextNode, <span class="keyword">new</span> ListNode(<span class="number">1</span>));</span><br><span class="line">        <span class="keyword">return</span> newNode;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><hr /></li></ol><h1 id="在链表中移除元素"><a class="markdownIt-Anchor" href="#在链表中移除元素"></a> 在链表中移除元素</h1><p>上面的一些题，都是通过递归修改链表内部的指针，从而得到期望的链表结构。其实这些题目用普通方法都是可以解答的，但是使用普通的方法很容易出错，修改修改指针就乱了，或者产生内存泄漏。</p><p>但是如果理解递归的基本思路，就可以编写出更简单的代码，也更容易理解。下面就继续通过递归的方式，去完成几个在链表中删除元素的题。继续理解上面说的递归的三个步骤。</p><h2 id="203-移除链表元素"><a class="markdownIt-Anchor" href="#203-移除链表元素"></a> <a href="https://leetcode-cn.com/problems/remove-linked-list-elements/" target="_blank" rel="noopener">203. 移除链表元素</a></h2><ol><li><p><strong>定义递归函数<code>ListNode* removeElements(ListNode* head, int val)</code>功能以及返回值</strong>：</p><p>定义递归函数功能：删除链表中值等于<code>val</code>的节点，并返回新的头节点。</p><p>根据定义的递归函数功能，首先将<code>removeElements</code>的作用范围放在整个链表，图中有绿色的阴影部分代表递归函数<code>reverseKGroup</code>的作用范围，也就是将<code>head</code>作为参数传递给<code>reverseKGroup(head, val)</code>作用的范围。</p><p><img src="/" alt="" / class="lazyload" data-src="https://tva1.sinaimg.cn/large/00831rSTly1gcw39mcqbnj31k606kgm1.jpg"></p><p>在这里设定<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>k</mi><mo>=</mo><mn>6</mn></mrow><annotation encoding="application/x-tex">k = 6</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">6</span></span></span></span>，当把<code>head</code>作为参数传递给递归函数作<code>removeElements</code>用后，根据定义的递归函数功能，这个函数就完成删除链表中所有值为<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>6</mn></mrow><annotation encoding="application/x-tex">6</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">6</span></span></span></span>的节点，并返回删除值为<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>6</mn></mrow><annotation encoding="application/x-tex">6</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">6</span></span></span></span>的链表后的链表头节点。</p><img src="/" style="zoom: 50%;" / class="lazyload" data-src="https://tva1.sinaimg.cn/large/00831rSTly1gcw3ecip1mj314k052wer.jpg"></li><li><p><strong>寻找递归函数退出条件和返回值</strong></p><p>当链表中不存在节点的时候，不需要删除任何节点，就直接返回。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(!head)</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br></pre></td></tr></table></figure></li><li><p><strong>缩小递归函数的规模，寻求层与层之间的关系</strong></p><p>为了缩减递归函数的规模，所以要将链表拆分为两个部分，由于要判断链表中的每个值是否等于<code>val</code>，所以要将链表分成长度分别为<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>1</mn></mrow><annotation encoding="application/x-tex">1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span>和长度为<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>k</mi><mo>−</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">k-1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.77777em;vertical-align:-0.08333em;"></span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span>的两个链表，其中<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>k</mi></mrow><annotation encoding="application/x-tex">k</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span></span></span></span>是原链表的长度。假设两部分链表的头节点分别是<code>head</code>和<code>newHead</code>。当函数缩减规模的时候，即将<code>newHead</code>作为参数传递给<code>removeElements</code>，其中用图表示如下：</p><p><img src="/" alt="" / class="lazyload" data-src="https://cdn.jsdelivr.net/gh/jackymxp/image-bed/leetcode/20200323063910.png"></p><p>当<code>removeElements(newHead, val)</code>执行完后，根据我们定义的递归的功能，即删除了上图绿色阴影中值为<code>val</code>的节点，整个链表变成如下图。</p><p><img src="/" alt="" / class="lazyload" data-src="https://cdn.jsdelivr.net/gh/jackymxp/image-bed/leetcode/20200323064820.png"></p><p>这时要判断当前节点<code>head-&gt;val</code>的值是否等于<code>val</code>，在这里就要分情况讨论了：</p><ul><li><p>如果<code>head-&gt;val != val</code>，表示的是不需要删除当前节点。为了将<code>head</code>与<code>retNode</code>串联起来，直接<code>head-&gt;next = retNode</code>即可。并且返回<code>head</code>。具体逻辑如上图所示。</p></li><li><p>如果<code>head-&gt;val == val</code>，表示的是需要删除当前节点，并且直接返回<code>retNode</code>。</p><p>用图形表示，当<code>head-&gt;val == 6</code>时，递归的情况如下：</p><p><img src="/" alt="" / class="lazyload" data-src="https://cdn.jsdelivr.net/gh/jackymxp/image-bed/leetcode/20200323120659.png"></p><p>当执行完<code>removeElements(newHead, val)</code>后，根据定义的递归功能，应该删除<code>newHead</code>后所有值为<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>6</mn></mrow><annotation encoding="application/x-tex">6</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">6</span></span></span></span>的节点，当执行完<code>removeElements(newHead, val)</code>后，整体的链表结构如下。</p><p><img src="/" alt="" / class="lazyload" data-src="https://cdn.jsdelivr.net/gh/jackymxp/image-bed/leetcode/20200323120443.png"></p><p>为了删除值为<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>6</mn></mrow><annotation encoding="application/x-tex">6</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">6</span></span></span></span>的节点，所以使用<code>delete head</code>即可，并且直接返回<code>retNode</code>即可。</p></li></ul><p>整体的代码逻辑如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">ListNode* newHead = head-&gt;next;</span><br><span class="line"><span class="comment">//将链表分割成两个部分</span></span><br><span class="line">head-&gt;next = <span class="literal">nullptr</span>;</span><br><span class="line">ListNode* retNode = removeElements(newHead, val);</span><br><span class="line"><span class="keyword">if</span>(head-&gt;val == val)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">delete</span> head;</span><br><span class="line">    <span class="keyword">return</span> retNode;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">    head-&gt;next = retNode;</span><br><span class="line">    <span class="keyword">return</span> head;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">4.  **完整代码**</span><br><span class="line"></span><br><span class="line">    &#96;&#96;&#96;cpp</span><br><span class="line">    class Solution &#123;</span><br><span class="line">    public:</span><br><span class="line">        ListNode* removeElements(ListNode* head, int val) &#123;</span><br><span class="line">            if(!head)</span><br><span class="line">                return head;</span><br><span class="line">            ListNode* newHead &#x3D; head-&gt;next;</span><br><span class="line">            &#x2F;&#x2F;断开为两个链表</span><br><span class="line">            head-&gt;next &#x3D; nullptr;</span><br><span class="line">            &#x2F;&#x2F;newHead 链表部分已经删除值为val的节点</span><br><span class="line">            ListNode* retNode &#x3D; removeElements(newHead, val);</span><br><span class="line">            if(head-&gt;val &#x3D;&#x3D; val)&#123;</span><br><span class="line">                delete head;</span><br><span class="line">                return retNode;</span><br><span class="line">            &#125;</span><br><span class="line">            else&#123;</span><br><span class="line">                head-&gt;next &#x3D; retNode;</span><br><span class="line">                return head;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br></pre></td></tr></table></figure><h2 id="83-删除排序链表中的重复元素"><a class="markdownIt-Anchor" href="#83-删除排序链表中的重复元素"></a> <a href="https://leetcode-cn.com/problems/remove-duplicates-from-sorted-list/" target="_blank" rel="noopener">83. 删除排序链表中的重复元素</a></h2><blockquote><p>给定一个排序链表，删除所有重复的元素，使得每个元素只出现一次。</p><p>示例 1:</p><p>输入: 1-&gt;1-&gt;2<br />输出: 1-&gt;2<br />示例 2:</p><p>输入: 1-&gt;1-&gt;2-&gt;3-&gt;3<br />输出: 1-&gt;2-&gt;3</p></blockquote><ol><li><p><strong>定义递归函数<code>ListNode* deleteDuplicates(ListNode* head)</code>功能以及返回值</strong></p><p>首先定义递归函数的功能是删除链表中值重复的元素，使重复的元素只出现一次。根据定义的递归函数功能，首先将<code>deleteDuplicates</code>的作用范围放在整个链表，图中有绿色的阴影部分代表递归函数<code>deleteDuplicates</code>的作用范围，也就是将<code>head</code>作为参数传递给<code>deleteDuplicates(head)</code>作用的范围。</p><p><img src="/" alt="" / class="lazyload" data-src="/Users/mengxiangpeng/Documents/blog/HexoBlog-Butterfly-BackUp/source/_posts/fucking-leetcode/01-%E9%93%BE%E8%A1%A8%E9%80%92%E5%BD%92%E4%B8%93%E9%A2%98.assets/00831rSTly1gd3r6br4tlj311u05maa9.jpg"></p><p>当把<code>head</code>作为参数传递给递归函数<code>deleteDuplicates</code>作用后，根据定义的递归函数功能，这个函数就完成了整个链表的翻转，也就是期望的最终答案。</p><img src="/" style="zoom:50%;" / class="lazyload" data-src="https://cdn.jsdelivr.net/gh/jackymxp/image-bed/leetcode/20200323122819.png"></li><li><p><strong>寻找递归函数退出条件和返回值</strong></p><p>当链表中不存在节点或者只有一个节点的时候，直接退出，因为一个节点不存在重复的节点。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(!head || !head-&gt;next)</span><br><span class="line">    <span class="keyword">return</span> head;</span><br></pre></td></tr></table></figure></li><li><p><strong>缩小递归函数的规模，寻求层与层之间的关系</strong></p><p>为了缩减递归函数的规模，所以要将链表拆分为两个部分，具体怎么拆分呢？这直接影响递归函数的编写。在这里我们将所有重复的节点看成是一部分，剩下的所有节点是另外一部分。具体解释一下。</p><p>这里将重复的节点看成是一组，重复节点的个数可能是<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>1</mn></mrow><annotation encoding="application/x-tex">1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span>或者更多。这里将原链表按照如下的方式进行划分为两个链表。也就是找到第一个和<code>head-&gt;val</code>值不同的节点，作为<code>newHead</code>。当缩小递归函数的范围的时候，即将<code>newHead</code>作为参数传入到<code>deleteDuplicates</code>函数中，其中递归函数的作用范围表示成图。</p><p><img src="/" alt="" / class="lazyload" data-src="https://cdn.jsdelivr.net/gh/jackymxp/image-bed/leetcode/20200323130416.png"></p><p>当递归函数<code>ListNode* retNode = deleteDuplicates(newHead)</code>执行完成后，根据递归函数的功能，这样就完成图中绿色阴影部分删除重复的节点。这样除前面重复的节点没有删除，后其余部分都符合题目要求，整个链表变成如下这个样子。</p><img src="/" style="zoom:50%;" / class="lazyload" data-src="https://tva1.sinaimg.cn/large/00831rSTly1gd3znjd91ej30uc07yjrv.jpg"><p>这时只要将重复的节点删除，<strong>只保留一个重复的节点</strong>。为了和已经完成的部分<code>retNode</code>连接起来，所以删除后的节点的<code>next</code>指针指向<code>retNode</code>。</p><p>将上述过程翻译成代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">ListNode* newHead = head-&gt;next;</span><br><span class="line"><span class="keyword">while</span>(newHead &amp;&amp; newHead-&gt;val == head-&gt;val)</span><br><span class="line">&#123;</span><br><span class="line">    ListNode* next = newHead-&gt;next;</span><br><span class="line">    <span class="keyword">delete</span> newHead;</span><br><span class="line">    newHead = next;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//将链表分为两个部分。·</span></span><br><span class="line">head-&gt;next = <span class="literal">nullptr</span>;</span><br><span class="line">ListNode* retNode = deleteDuplicates(newHead);</span><br><span class="line"></span><br><span class="line">head-&gt;next = retNode;</span><br></pre></td></tr></table></figure></li><li><p><strong>递归代码</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">deleteDuplicates</span><span class="params">(ListNode* head)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//递归退出条件</span></span><br><span class="line">        <span class="keyword">if</span>(!head || !head-&gt;next)</span><br><span class="line">            <span class="keyword">return</span> head;</span><br><span class="line"></span><br><span class="line">        ListNode* newHead = head-&gt;next;</span><br><span class="line">        <span class="keyword">while</span>(newHead &amp;&amp; newHead-&gt;val == head-&gt;val)</span><br><span class="line">        &#123;</span><br><span class="line">            ListNode* next = newHead-&gt;next;</span><br><span class="line">            <span class="keyword">delete</span> newHead;</span><br><span class="line">            newHead = next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//将链表分为两个部分。</span></span><br><span class="line">        head-&gt;next = <span class="literal">nullptr</span>;</span><br><span class="line">        <span class="comment">//对 newHead部分按照递归函数定义的功能删除重复节点，且只保留一个</span></span><br><span class="line">        ListNode* retNode = deleteDuplicates(newHead);</span><br><span class="line">        <span class="comment">//链接链表的两个部分</span></span><br><span class="line">        head-&gt;next = retNode;</span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ol><h2 id="82-删除排序链表中的重复元素-ii"><a class="markdownIt-Anchor" href="#82-删除排序链表中的重复元素-ii"></a> <a href="https://leetcode-cn.com/problems/remove-duplicates-from-sorted-list-ii/" target="_blank" rel="noopener">82. 删除排序链表中的重复元素 II</a></h2><blockquote><p>给定一个排序链表，删除所有含有重复数字的节点，只保留原始链表中 没有重复出现 的数字。</p><p>示例 1:</p><p>输入: 1-&gt;2-&gt;3-&gt;3-&gt;4-&gt;4-&gt;5<br />输出: 1-&gt;2-&gt;5<br />示例 2:</p><p>输入: 1-&gt;1-&gt;1-&gt;2-&gt;3<br />输出: 2-&gt;3</p></blockquote><ol><li><p><strong>定义递归函数<code>ListNode* deleteDuplicates(ListNode* head)</code>功能以及返回值</strong></p><p>首先定义递归函数的功能是删除链表中值重复的所有元素，也就是不保留任何值重复的元素。根据定义的递归函数功能，首先将<code>deleteDuplicates</code>的作用范围放在整个链表，图中有绿色的阴影部分代表递归函数<code>deleteDuplicates</code>的作用范围，也就是将<code>head</code>作为参数传递给<code>deleteDuplicates(head)</code>作用的范围。</p><p><img src="/" alt="" / class="lazyload" data-src="https://cdn.jsdelivr.net/gh/jackymxp/image-bed/leetcode/20200323184315.png"></p><p>当把<code>head</code>作为参数传递给递归函数<code>deleteDuplicates</code>作用后，根据定义的递归函数功能，这个函数就完成了整个链表的翻转，也就是期望的最终答案。</p><img src="/" style="zoom:50%;" / class="lazyload" data-src="https://cdn.jsdelivr.net/gh/jackymxp/image-bed/leetcode/20200323184654.png"></li><li><p><strong>寻找递归函数退出条件和返回值</strong></p><p>当链表中不存在节点或者只有一个节点的时候，直接退出，因为一个节点不存在重复的节点。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(!head || !head-&gt;next)</span><br><span class="line">    <span class="keyword">return</span> head;</span><br></pre></td></tr></table></figure></li><li><p><strong>缩小递归函数的规模，寻求层与层之间的关系</strong></p><p>在这里还是要思考如何减少递归函数的作用范围呢，仿照上面题的策略，将链表中的节点的值分成两组讨论，一组是只出现一次的节点的值；另外一组是链表中值重复的一组。</p><ul><li><p>如果值没有重复，则不用删除，链表的剩下部分头节点为<code>newHead</code>，删除从<code>newHead</code>开始链表的重复节点仍然是一个删除链表中重复节点的过程，依然可以直接使用<code>deleteDuplicates(newHead)</code>完成剩余的部分，使用图表示如下图所示。</p><p><img src="/" alt="" / class="lazyload" data-src="https://cdn.jsdelivr.net/gh/jackymxp/image-bed/leetcode/20200323190109.png"></p><p>当执行完<code>deleteDuplicates(newHead)</code>后，整个链表变成如下结构，再将两个部分连接起来。</p><img src="/" style="zoom:50%;" / class="lazyload" data-src="https://cdn.jsdelivr.net/gh/jackymxp/image-bed/leetcode/20200323191339.png"><p>当不存在重复节点时的代码逻辑如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(head-&gt;val != head-&gt;next-&gt;val)&#123;<span class="comment">//链表中至少存在两个节点，所以可以直接访问head-&gt;next并不为空</span></span><br><span class="line">    head-&gt;next = deleteDuplicates(head-&gt;next);</span><br><span class="line">    <span class="keyword">return</span> head;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>如果出现重复的节点就需要将<code>newHead</code>定位到下一个大于待删除的节点，再将所有值相同的节点全部释放掉。链表<code>newHead</code>部分仍然可以看作是删除值重复节点的过程，可以调用<code>deleteDuplicates(newHead)</code>完成剩下部分的操作。</p><p><img src="/" alt="" / class="lazyload" data-src="https://cdn.jsdelivr.net/gh/jackymxp/image-bed/leetcode/20200323195350.png"></p><p>存在重复节点时的代码逻辑如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(head-&gt;val == head-&gt;next-&gt;val)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//定位到newHead节点</span></span><br><span class="line">    ListNode* newHead = head;</span><br><span class="line">    <span class="keyword">int</span> val = head-&gt;val;</span><br><span class="line">   <span class="keyword">while</span>(newHead &amp;&amp; newHead-&gt;val == val)</span><br><span class="line">    &#123;</span><br><span class="line">        ListNode* next = newHead-&gt;next;</span><br><span class="line">        <span class="keyword">delete</span> newHead;</span><br><span class="line">        newHead = next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//将 newHead 后的链表删除重复节点，并将删除后的头节点返回</span></span><br><span class="line">    <span class="keyword">return</span> deleteDuplicates(newHead);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li><li><p><strong>递归代码</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">deleteDuplicates</span><span class="params">(ListNode* head)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//递归退出条件，当链表长度小于2的时候</span></span><br><span class="line">        <span class="keyword">if</span>(!head || !head-&gt;next)</span><br><span class="line">            <span class="keyword">return</span> head;</span><br><span class="line">        <span class="keyword">if</span>(head-&gt;val != head-&gt;next-&gt;val)&#123;</span><br><span class="line">            head-&gt;next = deleteDuplicates(head-&gt;next);</span><br><span class="line">            <span class="keyword">return</span> head;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            ListNode* newHead = head;</span><br><span class="line">            <span class="keyword">int</span> val = head-&gt;val;</span><br><span class="line">            <span class="keyword">while</span>(newHead &amp;&amp; newHead-&gt;val == val)</span><br><span class="line">            &#123;</span><br><span class="line">                ListNode* next = newHead-&gt;next;</span><br><span class="line">                <span class="keyword">delete</span> newHead;</span><br><span class="line">                newHead = next;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> deleteDuplicates(newHead);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ol><h2 id="19-删除链表的倒数第n个节点"><a class="markdownIt-Anchor" href="#19-删除链表的倒数第n个节点"></a> <a href="https://leetcode-cn.com/problems/remove-nth-node-from-end-of-list/" target="_blank" rel="noopener">19. 删除链表的倒数第N个节点</a></h2><blockquote><p>给定一个链表，删除链表的倒数第 n 个节点，并且返回链表的头结点。</p><p>示例：</p><p>给定一个链表: 1-&gt;2-&gt;3-&gt;4-&gt;5, 和 n = 2.</p><p>当删除了倒数第二个节点后，链表变为 1-&gt;2-&gt;3-&gt;5.</p></blockquote><p>对于这道题，拿到手里来，是不是没有任何思路。但是只要记得上面的套路，这道题依然可以用递归解决。问题的难点是如何使用递归定位到倒数第<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">n</span></span></span></span>个节点。以倒数第<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">n</span></span></span></span>个节点作为分隔节点，将链表分成两个部分。接下来还是三步走。</p><ol><li><p><strong>定义递归函数<code>ListNode* removeNthFromEnd(ListNode* head, int n)</code>功能以及返回值</strong></p><p>根据定义的递归函数功能，首先将<code>removeNthFromEnd</code>的作用范围放在整个链表，图中有绿色的阴影部分代表递归函数<code>reverseList</code>的作用范围，也就是将<code>head</code>作为参数传递给<code>removeNthFromEnd(head, n)</code>作用的范围。</p><p><img src="/" alt="" / class="lazyload" data-src="https://tva1.sinaimg.cn/large/00831rSTly1gd2x4tff4nj318e0620u7.jpg"></p><p>当把<code>head</code>作为参数传递给递归函数<code>removeNthFromEnd</code>作用后，根据定义的递归函数功能，这个函数就完成了删除倒数第n个节点，也就是期望的最终答案。</p><img src="/" style="zoom:50%;" / class="lazyload" data-src="https://cdn.jsdelivr.net/gh/jackymxp/image-bed/leetcode/20200323210439.png"></li><li><p><strong>寻找递归函数退出条件和返回值</strong></p><p>当链表中没有节点的时候，不能进行删除操作，就可以直接返回。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(!head)</span><br><span class="line">    <span class="keyword">return</span> head;</span><br></pre></td></tr></table></figure></li><li><p><strong>缩小递归函数的规模，寻求层与层之间的关系</strong></p><p>这里我们似乎找不到任何递归函数如何缩减规模的策略，因为这个题，很难通过递归找到倒数第<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">n</span></span></span></span>个节点。在这里我选择通过介绍递归的原理，来讲解这个题。</p><p>我们定义整个链表的尾节点为第<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>0</mn></mrow><annotation encoding="application/x-tex">0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">0</span></span></span></span>个节点，倒数第一个为<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>1</mn></mrow><annotation encoding="application/x-tex">1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span>个节点，那么问题来了，我们如何通过递归定位到最后一个节点呢？</p><p>因为最后一个节点有特殊标记<code>nullptr</code>，所以通过递归遍历整个链表，直到定位到<code>nullptr</code>节点，标记此时的标志为<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>t</mi><mi>h</mi><mtext>  </mtext><mo>=</mo><mtext>  </mtext><mn>0</mn></mrow><annotation encoding="application/x-tex">th \;= \;0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault">t</span><span class="mord mathdefault">h</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">0</span></span></span></span>。那么在递归到<code>nullptr</code>的过程中，这个过程叫做递。</p><p>当在归的时候，每次归的时候将<code>th++</code>，这样当<code>th == n</code>时候，就可以删除该节点了。</p><p>无图无真相：</p><p><img src="/" alt="" / class="lazyload" data-src="https://cdn.jsdelivr.net/gh/jackymxp/image-bed/leetcode/20200323213633.png"></p></li><li><p><strong>完成代码</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> th;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">removeNthFromEnd</span><span class="params">(ListNode* head, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>(head == <span class="literal">nullptr</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            th = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//递的过程</span></span><br><span class="line">        head-&gt;next = removeNthFromEnd(head-&gt;next, n);</span><br><span class="line">        <span class="comment">//每次归的过程，都将标识位做一次加加操作</span></span><br><span class="line">        th++;</span><br><span class="line">        <span class="keyword">if</span>(th == n)</span><br><span class="line">        &#123;</span><br><span class="line">            ListNode* next = head-&gt;next;</span><br><span class="line">            <span class="keyword">delete</span> head;</span><br><span class="line">            <span class="keyword">return</span> next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ol><p>#其他类型</p><h2 id="430-扁平化多级双向链表"><a class="markdownIt-Anchor" href="#430-扁平化多级双向链表"></a> <a href="https://leetcode-cn.com/problems/flatten-a-multilevel-doubly-linked-list/" target="_blank" rel="noopener">430. 扁平化多级双向链表</a></h2><blockquote><p>当有这样一个链表，扁平化后变成下图所示的链表。</p><p><img src="/" alt="" / class="lazyload" data-src="https://cdn.jsdelivr.net/gh/jackymxp/image-bed/leetcode/20200408074102.png"></p><p><img src="/" alt="" / class="lazyload" data-src="https://cdn.jsdelivr.net/gh/jackymxp/image-bed/leetcode/20200408082602.png"></p></blockquote><p>首先我们分析，能不能使用递归去解题，也就是看看在原数据中，存不存在数据规模更小的，但是和原数据规模一样的操作的，如果有，我们就可以使用递归解决。我们把链表节点<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>3</mn></mrow><annotation encoding="application/x-tex">3</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">3</span></span></span></span>这里拆开，发现以节点<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>7</mn></mrow><annotation encoding="application/x-tex">7</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">7</span></span></span></span>为开始的链表又是可以使用原操作进行的，所以我们可以使用递归</p><p>使用递归法解题还是按照三个步骤。</p><h1 id="总结"><a class="markdownIt-Anchor" href="#总结"></a> 总结</h1><p>这一篇博客中，都是使用递归解决和链表相关的问题。我们可以总结出使用递归解决链表相关问题的套路。</p><ol><li>首先定义递归函数<code>fun(ListNode* head, ...)</code>的具体功能。</li><li>根据具体的语境，找到递归函数的出口。</li><li>将一个链表分成两个部分，假设链表两部分的头节点分别是<code>head</code>和<code>newHead</code>，其中在<code>newHead</code>部分的链表操作和整个链表的结构是相同的，只是规模更小。也就是说当执行完<code>fun(newHead, …)</code>后，根据我们定义的递归函数的功能，链表变成了什么样子。</li><li>将<code>fun(newHead, …)</code>执行后的链表的返回值与<code>head</code>部分联系起来，找到如何变换<code>head</code>部分，才能让其达到我们期望的结构。这不基本是递归函数的难点。</li></ol><p>在上面解题的过程中，为了将递归函数的功能表示的明确些。刻意将链表分成两个部分，其实有很多题是不需要明确的分成两个部分，而直接改变指针的指向会简化很多代码，但是递归的逻辑就会稍微模糊一点。</p><p>在<a href="https://leetcode-cn.com/problems/remove-nth-node-from-end-of-list/" target="_blank" rel="noopener">删除链表的倒数第N个节点</a>题中，讨论了递归函数的原理，什么时候递，什么时候归，通过上面一些题的例子，我们应该知道那里是递的过程，哪里是归的过程，理解了递和归的过程，对于理解递归的原理还是会有很多帮助的。</p><p>当然能写出递归函数都是在以基本功为基础的，比如定位到链表的中间节点。做链表题的时候，更重要的是对代码鲁棒性的考察，比如当链表没有节点的时候，或者只有一个节点的时候，我们写的函数能不能安全运行，又比如想判断<code>head-&gt;val</code>的值，首先我们要保证<code>head != nullptr</code>，所以在写代码的时候，一般写成<code>if(head &amp;&amp; head-&gt;val == val)</code>等，这些都是我们需要注意的。</p>]]></content>
      
      
      <categories>
          
          <category> leetcode </category>
          
          <category> 编程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 递归 </tag>
            
            <tag> 链表 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>如何计算最大公约数</title>
      <link href="/2020/03/13/%E6%9C%80%E5%A4%A7%E5%85%AC%E7%BA%A6%E6%95%B0/"/>
      <url>/2020/03/13/%E6%9C%80%E5%A4%A7%E5%85%AC%E7%BA%A6%E6%95%B0/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><h1 id="如何求最大公约数"><a class="markdownIt-Anchor" href="#如何求最大公约数"></a> 如何求最大公约数</h1><p>最大公约数指能够<strong>整除多个整数</strong>的最大正整数。而多个整数不能都为零。</p><p>本文将从暴力法开始一步步地求解最大公约数，从理论推导到计算机代码实现的的一个递进过程。</p><h2 id="暴力法"><a class="markdownIt-Anchor" href="#暴力法"></a> 暴力法</h2><p>没有什么是暴力法解决不了的，如果有，那就是我们不能把有限的时间内投入到无限的找bug中。</p><img src="/" style="zoom:50%;" / class="lazyload" data-src="https://tva1.sinaimg.cn/large/00831rSTly1gcud1ue072j30im0j21bc.jpg"><h3 id="暴力法的原理"><a class="markdownIt-Anchor" href="#暴力法的原理"></a> 暴力法的原理</h3><p>暴力法的原理很简答，就是从2开始，枚举每一个数字，直到最小的数字。</p><h3 id="暴力法的代码实现"><a class="markdownIt-Anchor" href="#暴力法的代码实现"></a> 暴力法的代码实现</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">gcd</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> smaller = a &lt; b ? a : b;</span><br><span class="line">    <span class="keyword">int</span> bigger = a &gt; b ? a : b;</span><br><span class="line">    <span class="keyword">int</span> res = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= smaller; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>((bigger % i == <span class="number">0</span>) &amp;&amp; (smaller % i == <span class="number">0</span>))</span><br><span class="line">            res = i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="辗转相除法"><a class="markdownIt-Anchor" href="#辗转相除法"></a> 辗转相除法</h2><h3 id="辗转相除法的历史"><a class="markdownIt-Anchor" href="#辗转相除法的历史"></a> 辗转相除法的历史</h3><p>辗转相除法， 又名欧几里得算法（Euclidean algorithm），其历史可以追溯到公元前300多年。</p><blockquote><p>“欧几里得算法是所有算法的鼻祖，因为它是现存最古老的非凡算法。”- 高德纳</p></blockquote><img src="/" alt="image-20200313213018498" style="zoom:50%;" / class="lazyload" data-src="https://tva1.sinaimg.cn/large/00831rSTly1gcsmhlv6cqj30n40n6b29.jpg"><h3 id="辗转相除法原理"><a class="markdownIt-Anchor" href="#辗转相除法原理"></a> 辗转相除法原理</h3><p><strong>两个正整数<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>a</mi></mrow><annotation encoding="application/x-tex">a</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">a</span></span></span></span>和<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>b</mi></mrow><annotation encoding="application/x-tex">b</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault">b</span></span></span></span>，<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo stretchy="false">(</mo><mi>a</mi><mo>&gt;</mo><mi>b</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">(a &gt; b)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathdefault">a</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">&gt;</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">b</span><span class="mclose">)</span></span></span></span>，它们的最大公约数等于<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>a</mi></mrow><annotation encoding="application/x-tex">a</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">a</span></span></span></span>除以<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>b</mi></mrow><annotation encoding="application/x-tex">b</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault">b</span></span></span></span>的余数<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>c</mi></mrow><annotation encoding="application/x-tex">c</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">c</span></span></span></span>和<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>b</mi></mrow><annotation encoding="application/x-tex">b</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault">b</span></span></span></span>之间的最大公约数。</strong></p><p><strong>翻译成人话，举个例子</strong></p><p>利用辗转相除法计算 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>a</mi><mo>=</mo><mn>25</mn></mrow><annotation encoding="application/x-tex">a = 25</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">a</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">2</span><span class="mord">5</span></span></span></span>和<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>b</mi><mo>=</mo><mn>10</mn></mrow><annotation encoding="application/x-tex">b = 10</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault">b</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span><span class="mord">0</span></span></span></span>的最大公约数的过程如下：</p><blockquote><ol><li>从<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>25</mn></mrow><annotation encoding="application/x-tex">25</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">2</span><span class="mord">5</span></span></span></span>中不断减去<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>10</mn></mrow><annotation encoding="application/x-tex">10</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span><span class="mord">0</span></span></span></span>，直到小于10，(可以减去2次，商为2)，余数为5</li><li>从10中不断的5，直到结果小于5，(可以减去2次，商为2)，余数为0</li><li>当余数为0的时候，算法终止，否则继续回到1.2。</li></ol></blockquote><table><thead><tr><th style="text-align:center">步骤数</th><th style="text-align:center">算式</th><th style="text-align:center">商和余数</th></tr></thead><tbody><tr><td style="text-align:center">0</td><td style="text-align:center">25 = 10 <em>q</em>0 + <em>r</em>0</td><td style="text-align:center"><em>q</em>0 = 2、<em>r</em>0 = 5</td></tr><tr><td style="text-align:center">1</td><td style="text-align:center">10 = 5 <em>q</em>1 + <em>r</em>1</td><td style="text-align:center"><em>q</em>1 = 2、<em>r</em>1 = 0 （算法终止）</td></tr></tbody></table><p>写成连续的等式形式如下：</p><p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>g</mi><mi>c</mi><mi>d</mi><mo stretchy="false">(</mo><mn>25</mn><mo separator="true">,</mo><mn>10</mn><mo stretchy="false">)</mo><mo>=</mo><mi>g</mi><mi>c</mi><mi>d</mi><mo stretchy="false">(</mo><mn>10</mn><mo separator="true">,</mo><mn>5</mn><mo stretchy="false">)</mo><mo>=</mo><mi>g</mi><mi>c</mi><mi>d</mi><mo stretchy="false">(</mo><mn>5</mn><mo separator="true">,</mo><mn>0</mn><mo stretchy="false">)</mo><mo>=</mo><mn>5</mn></mrow><annotation encoding="application/x-tex">gcd(25, 10) = gcd(10, 5) = gcd(5, 0) = 5</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.03588em;">g</span><span class="mord mathdefault">c</span><span class="mord mathdefault">d</span><span class="mopen">(</span><span class="mord">2</span><span class="mord">5</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">1</span><span class="mord">0</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.03588em;">g</span><span class="mord mathdefault">c</span><span class="mord mathdefault">d</span><span class="mopen">(</span><span class="mord">1</span><span class="mord">0</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">5</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.03588em;">g</span><span class="mord mathdefault">c</span><span class="mord mathdefault">d</span><span class="mopen">(</span><span class="mord">5</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">0</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">5</span></span></span></span></span></p><p>将例子升华一下，形成通用的方程：</p><p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>g</mi><mi>c</mi><mi>d</mi><mo stretchy="false">(</mo><mi>a</mi><mo separator="true">,</mo><mn>0</mn><mo stretchy="false">)</mo><mo>=</mo><mi>a</mi></mrow><annotation encoding="application/x-tex">gcd(a, 0) = a</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.03588em;">g</span><span class="mord mathdefault">c</span><span class="mord mathdefault">d</span><span class="mopen">(</span><span class="mord mathdefault">a</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">0</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">a</span></span></span></span></span></p><ul><li>对应递归或者循环退出条件</li></ul><p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>g</mi><mi>c</mi><mi>d</mi><mo stretchy="false">(</mo><mi>a</mi><mo separator="true">,</mo><mi>b</mi><mo stretchy="false">)</mo><mo>=</mo><mi>g</mi><mi>c</mi><mi>d</mi><mo stretchy="false">(</mo><mi>b</mi><mo separator="true">,</mo><mi>a</mi><mtext>  </mtext><mi>m</mi><mi>o</mi><mi>d</mi><mtext>  </mtext><mi>b</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">gcd(a, b) = gcd(b, a\;mod\; b)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.03588em;">g</span><span class="mord mathdefault">c</span><span class="mord mathdefault">d</span><span class="mopen">(</span><span class="mord mathdefault">a</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">b</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.03588em;">g</span><span class="mord mathdefault">c</span><span class="mord mathdefault">d</span><span class="mopen">(</span><span class="mord mathdefault">b</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">a</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mord mathdefault">m</span><span class="mord mathdefault">o</span><span class="mord mathdefault">d</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mord mathdefault">b</span><span class="mclose">)</span></span></span></span></span></p><ul><li>对应递归关系，层与层之间的关系。</li></ul><p>对于验证辗转相除法的正确性的证明，这里就不讲了。</p><h3 id="辗转相除法的代码实现"><a class="markdownIt-Anchor" href="#辗转相除法的代码实现"></a> 辗转相除法的代码实现</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">gcd</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(a == <span class="number">0</span> || b == <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> a ? a : b;</span><br><span class="line">    <span class="keyword">int</span> smaller = a &lt; b ? a : b;</span><br><span class="line">    <span class="keyword">int</span> bigger = a &gt; b ? a : b;</span><br><span class="line">    <span class="keyword">return</span> gcd(smaller, bigger % smaller);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="辗转相除法存在的问题"><a class="markdownIt-Anchor" href="#辗转相除法存在的问题"></a> 辗转相除法存在的问题</h3><p><strong>当两个正整数</strong><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>a</mi></mrow><annotation encoding="application/x-tex">a</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">a</span></span></span></span>和<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>b</mi></mrow><annotation encoding="application/x-tex">b</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault">b</span></span></span></span>都特别大的时候，做<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>a</mi><mtext>  </mtext><mi>m</mi><mi>o</mi><mi>d</mi><mtext>  </mtext><mi>b</mi></mrow><annotation encoding="application/x-tex">a\;mod\; b</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault">a</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mord mathdefault">m</span><span class="mord mathdefault">o</span><span class="mord mathdefault">d</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mord mathdefault">b</span></span></span></span>的性能开销比较大。所以要将取模的操作进行替换。</p><h2 id="更相减损术"><a class="markdownIt-Anchor" href="#更相减损术"></a> 更相减损术</h2><h3 id="更相减损术的历史"><a class="markdownIt-Anchor" href="#更相减损术的历史"></a> 更相减损术的历史</h3><p>古希腊人很聪明，但是我们的祖先也不差，更相减损术，出自于中国古代的《九章算术》。</p><p><img src="/" alt="" / class="lazyload" data-src="https://tva1.sinaimg.cn/large/00831rSTgy1gct8xlddmmg30bn0f6q8f.gif"></p><h3 id="更相减损术原理"><a class="markdownIt-Anchor" href="#更相减损术原理"></a> 更相减损术原理</h3><p><strong>两个正整数<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>a</mi></mrow><annotation encoding="application/x-tex">a</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">a</span></span></span></span>和<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>b</mi></mrow><annotation encoding="application/x-tex">b</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault">b</span></span></span></span>（<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>a</mi><mo>&gt;</mo><mi>b</mi></mrow><annotation encoding="application/x-tex">a&gt;b</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.5782em;vertical-align:-0.0391em;"></span><span class="mord mathdefault">a</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">&gt;</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault">b</span></span></span></span>），它们的最大公约数等于<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>a</mi><mo>−</mo><mi>b</mi></mrow><annotation encoding="application/x-tex">a-b</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.66666em;vertical-align:-0.08333em;"></span><span class="mord mathdefault">a</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault">b</span></span></span></span>的差值<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>c</mi></mrow><annotation encoding="application/x-tex">c</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">c</span></span></span></span>和较小数<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>b</mi></mrow><annotation encoding="application/x-tex">b</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault">b</span></span></span></span>的最大公约数。</strong></p><p>这个就不用翻译成人话了，直接给出理论推倒。</p><p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>g</mi><mi>c</mi><mi>d</mi><mo stretchy="false">(</mo><mi>a</mi><mo separator="true">,</mo><mn>0</mn><mo stretchy="false">)</mo><mo>=</mo><mi>a</mi></mrow><annotation encoding="application/x-tex">gcd(a, 0) = a</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.03588em;">g</span><span class="mord mathdefault">c</span><span class="mord mathdefault">d</span><span class="mopen">(</span><span class="mord mathdefault">a</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">0</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">a</span></span></span></span></span></p><ul><li>对应递归或者循环退出条件</li></ul><p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>g</mi><mi>c</mi><mi>d</mi><mo stretchy="false">(</mo><mi>a</mi><mo separator="true">,</mo><mi>b</mi><mo stretchy="false">)</mo><mo>=</mo><mi>g</mi><mi>c</mi><mi>d</mi><mo stretchy="false">(</mo><mi>b</mi><mo separator="true">,</mo><mtext>  </mtext><mi>a</mi><mtext>  </mtext><mo>−</mo><mtext>  </mtext><mi>b</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">gcd(a, b) = gcd(b, \;a\;-\; b)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.03588em;">g</span><span class="mord mathdefault">c</span><span class="mord mathdefault">d</span><span class="mopen">(</span><span class="mord mathdefault">a</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">b</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.03588em;">g</span><span class="mord mathdefault">c</span><span class="mord mathdefault">d</span><span class="mopen">(</span><span class="mord mathdefault">b</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mord mathdefault">a</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">b</span><span class="mclose">)</span></span></span></span></span></p><ul><li>对应递归关系，层与层之间的关系。</li></ul><p>最后直接上代码。</p><h3 id="更相减损术的代码实现"><a class="markdownIt-Anchor" href="#更相减损术的代码实现"></a> 更相减损术的代码实现</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">gcd</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(a == <span class="number">0</span> || b == <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> a ? a : b;</span><br><span class="line">    <span class="keyword">int</span> smaller = a &lt; b ? a : b;</span><br><span class="line">    <span class="keyword">int</span> bigger = a &gt; b ? a : b;</span><br><span class="line">    <span class="keyword">return</span> gcd(bigger - smaller, smaller);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="更相减损术存在的问题"><a class="markdownIt-Anchor" href="#更相减损术存在的问题"></a> 更相减损术存在的问题</h3><p>虽然这里用减法代替了取模操作，但是由于每次都做的是<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>a</mi><mo>−</mo><mi>b</mi></mrow><annotation encoding="application/x-tex">a - b</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.66666em;vertical-align:-0.08333em;"></span><span class="mord mathdefault">a</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault">b</span></span></span></span>操作，所以收敛速度是一个问题。举个极端的例子，当<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>a</mi><mo>=</mo><mn>9999</mn><mo separator="true">,</mo><mi>b</mi><mo>=</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">a = 9999, b = 1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">a</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord">9</span><span class="mord">9</span><span class="mord">9</span><span class="mord">9</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">b</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span>时，这个收敛速度就很慢，在计算机中就要<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>9998</mn></mrow><annotation encoding="application/x-tex">9998</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">9</span><span class="mord">9</span><span class="mord">9</span><span class="mord">8</span></span></span></span>次递归。时间和空间性能都存在很大问题。</p><h2 id="中西结合"><a class="markdownIt-Anchor" href="#中西结合"></a> 中西结合</h2><img src="/" alt="image-20200315093823406" style="zoom:50%;" / class="lazyload" data-src="https://tva1.sinaimg.cn/large/00831rSTly1gcud5di2vdj315w0q61kx.jpg"><p>求最大公约数的问题，可以看成纯粹的数学计算。在计算机中有关有关于计算优化的问题，总结了以下几点：</p><blockquote><ol><li>能用加减解决的，尽量不要用乘除法搞定。</li><li>能用移位运算搞定的，不要用乘除法搞定。<ol><li>比如<code>a /= 2</code> 写成 <code>a &gt;&gt;= 1</code></li><li><code>a *= 6</code> 写成 <code>a = a &lt;&lt; 2 + a &lt;&lt; 1</code></li></ol></li><li>尽量避免一些取模操作，一些特殊的取模操作可以用<code>&amp;</code>运算符代替。<ol><li>判断奇偶<code>a % 2</code> 写成 <code>a &amp; 0x1</code> 形式。</li><li>对<code>a % (2^n)</code>这种数字求模写成<code>a &amp; (2^n - 1)</code>。</li></ol></li><li>优化计算方法，减少计算迭代的次数。</li></ol></blockquote><p>在这里，对暴力法的改进成辗转相除法或更相减损术对应最后一点，是最难的一点，性能提升的很高，数学家一般干这个。</p><p>而大多数人还是通过1、2、3、4条进行改进就可以了。</p><p>最后对辗转相除法和更相减损术进行一些计算上的优化，首先应该明确以下一些原理：</p><blockquote><ol><li>当正整数a和b（a&gt;b）都是偶数时，<code>gcd(a, b) = gcd(a/2, b/2) * 2</code></li><li>当正整数a为奇数时，b（a&gt;b）是偶数时，<code>gcd(a, b) = gcd(a, b/2)</code></li><li>当正整数a为偶数时，b（a&gt;b）是奇数时，<code>gcd(a, b) = gcd(a/2, b)</code></li><li>当正整数a为奇数时，b（a&gt;b）是奇数时，<code>gcd(a, b) = gcd(b, a-b)</code>，此时的<code>a-b</code>是一个整数，又回到了一奇一偶的情况。</li></ol></blockquote><p>注意到其中存在除以2这种特殊的数字，所以直接使用移位运算代替。</p><h3 id="结合位运算的辗转相除法和更相减损术的代码实现"><a class="markdownIt-Anchor" href="#结合位运算的辗转相除法和更相减损术的代码实现"></a> 结合位运算的辗转相除法和更相减损术的代码实现</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">gcd</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(a == <span class="number">0</span> || b == <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> a ? a : b;</span><br><span class="line">    <span class="keyword">int</span> smaller = a &lt; b ? a : b;</span><br><span class="line">    <span class="keyword">int</span> bigger = a &gt; b ? a : b;</span><br><span class="line">    <span class="comment">/*a 偶数  b 偶数*/</span></span><br><span class="line">    <span class="keyword">if</span>(!(smaller &amp; <span class="number">0x1</span>) &amp;&amp; !(bigger &amp; <span class="number">0x1</span>))</span><br><span class="line">        <span class="keyword">return</span> gcd(bigger &gt;&gt; <span class="number">1</span>, smaller &gt;&gt; <span class="number">1</span>) &lt;&lt; <span class="number">1</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/*a 偶数  b 奇数*/</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(!(smaller &amp; <span class="number">0x1</span>) &amp;&amp; (bigger &amp; <span class="number">0x1</span>))</span><br><span class="line">        <span class="keyword">return</span> gcd(bigger, smaller &gt;&gt; <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*a 奇数  b 偶数*/</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>((smaller &amp; <span class="number">0x1</span>) &amp;&amp; !(bigger &amp; <span class="number">0x1</span>))</span><br><span class="line">        <span class="keyword">return</span> gcd(bigger &gt;&gt; <span class="number">1</span>, smaller);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*a 奇数  b 奇数*/</span></span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> gcd(bigger - smaller, smaller);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="总结"><a class="markdownIt-Anchor" href="#总结"></a> 总结</h2><p>其实，有很多东西都是原理或者理论简单，但是实际实现起来还是会有很多细节需要注意的，比如甚至是一个看起来不成问题的求最大公约数的问题，还有这么多门道。</p><p>为了尽快给出一个能用可行的方案，使用了暴力法，但是对于效率和性能的优化是我们必须追求的目标。所以引入了两个求最大公约数的算法。辗转相除法要求两个数的模，但是在计算机中的计算又要尽量避免大数的取模操作。采用更相减损术将取模操作改成了加减法，但是收敛速度又成为了一个大问题。继而将两种方案结合起来，形成一个相对高效的求两个数的最大公约数算法和代码。</p><blockquote><p>这里不得不说，数学才是真正的生产力，是优化的正道。</p><p>而对于一些位运算优化或者代码层面的优化，相对于数学方法的优化，只能说是旁门左道。</p></blockquote><h2 id="测试代码"><a class="markdownIt-Anchor" href="#测试代码"></a> 测试代码</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;ctime&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/time.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> bf&#123;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">gcd</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(a == <span class="number">0</span> || b == <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> a ? a : b;</span><br><span class="line">    <span class="keyword">int</span> smaller = a &lt; b ? a : b;</span><br><span class="line">    <span class="keyword">int</span> bigger = a &gt; b ? a : b;</span><br><span class="line">    <span class="keyword">int</span> res = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= smaller; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>((bigger % i == <span class="number">0</span>) &amp;&amp; (smaller % i == <span class="number">0</span>))</span><br><span class="line">            res = i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> div&#123;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">gcd</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(a == <span class="number">0</span> || b == <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> a ? a : b;</span><br><span class="line">    <span class="keyword">int</span> smaller = a &lt; b ? a : b;</span><br><span class="line">    <span class="keyword">int</span> bigger = a &gt; b ? a : b;</span><br><span class="line">    <span class="keyword">return</span> gcd(smaller, bigger % smaller);</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> gx&#123;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">gcd</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(a == <span class="number">0</span> || b == <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> a ? a : b;</span><br><span class="line">    <span class="keyword">int</span> smaller = a &lt; b ? a : b;</span><br><span class="line">    <span class="keyword">int</span> bigger = a &gt; b ? a : b;</span><br><span class="line">    <span class="keyword">return</span> gcd(bigger - smaller, smaller);</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> divandgx&#123;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">gcd</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(a == <span class="number">0</span> || b == <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> a ? a : b;</span><br><span class="line">    <span class="keyword">int</span> smaller = a &lt; b ? a : b;</span><br><span class="line">    <span class="keyword">int</span> bigger = a &gt; b ? a : b;</span><br><span class="line">    <span class="comment">/*a 偶数  b 偶数*/</span></span><br><span class="line">    <span class="keyword">if</span>(!(smaller &amp; <span class="number">0x1</span>) &amp;&amp; !(bigger &amp; <span class="number">0x1</span>))</span><br><span class="line">        <span class="keyword">return</span> gcd(bigger &gt;&gt; <span class="number">1</span>, smaller &gt;&gt; <span class="number">1</span>) &lt;&lt; <span class="number">1</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/*a 偶数  b 奇数*/</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(!(smaller &amp; <span class="number">0x1</span>) &amp;&amp; (bigger &amp; <span class="number">0x1</span>))</span><br><span class="line">        <span class="keyword">return</span> gcd(bigger, smaller &gt;&gt; <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*a 奇数  b 偶数*/</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>((smaller &amp; <span class="number">0x1</span>) &amp;&amp; !(bigger &amp; <span class="number">0x1</span>))</span><br><span class="line">        <span class="keyword">return</span> gcd(bigger &gt;&gt; <span class="number">1</span>, smaller);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*a 奇数  b 奇数*/</span></span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> gcd(bigger - smaller, smaller);</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">testgcd</span><span class="params">(<span class="built_in">string</span> testname, <span class="keyword">int</span>(*gcd)(<span class="keyword">int</span>, <span class="keyword">int</span>), <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; a, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">timeval</span> <span class="title">start</span>, <span class="title">end</span>;</span></span><br><span class="line">    gettimeofday(&amp;start, <span class="literal">NULL</span>);</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; res;</span><br><span class="line">    <span class="keyword">int</span> len = a.size();</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        res.push_back(gcd(a[i], b[i]));</span><br><span class="line">    &#125;</span><br><span class="line">    gettimeofday(&amp;end, <span class="literal">NULL</span>);</span><br><span class="line">    <span class="keyword">double</span> duration = ((end.tv_sec - start.tv_sec) * <span class="built_in">pow</span>(<span class="number">10</span>, <span class="number">6</span>) + (end.tv_usec - start.tv_usec));</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"test %s has findished, it spent %f us\n"</span>, testname.c_str(), duration);</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> testNum = <span class="number">1000000</span>;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; avec, bvec;</span><br><span class="line">    <span class="keyword">int</span> left = <span class="number">0</span>, right = <span class="number">10000</span>;</span><br><span class="line">    srand(time(<span class="literal">NULL</span>));</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; testNum; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> a  = random() % (right - left + <span class="number">1</span>) + left;</span><br><span class="line">        avec.push_back(a);</span><br><span class="line">        <span class="keyword">int</span> b  = random() % (right - left + <span class="number">1</span>) + left;</span><br><span class="line">        bvec.push_back(b);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">auto</span> res1 = testgcd(<span class="string">"暴力求解法"</span>, bf::gcd, avec, bvec);</span><br><span class="line">    <span class="keyword">auto</span> res2 = testgcd(<span class="string">"辗转相除法"</span>, div::gcd, avec, bvec);</span><br><span class="line">    <span class="keyword">auto</span> res3 = testgcd(<span class="string">"更相减损术"</span>, gx::gcd, avec, bvec);</span><br><span class="line">    <span class="keyword">auto</span> res4 = testgcd(<span class="string">"位运算优化"</span>, divandgx::gcd, avec, bvec);    </span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(res1 != res2 || res1 != res3 || res1 != res4)</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"Error "</span> &lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>运行结果</li></ul><blockquote><p>test 暴力求解法 has findished, it spent 7127775.000000 us<br />test 辗转相除法 has findished, it spent 75551.000000 us<br />test 更相减损术 has findished, it spent 66527.000000 us<br />test 位运算优化 has findished, it spent 112157.000000 us</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 数学 </category>
          
          <category> 编程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 最大公约数 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
