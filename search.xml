<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>test</title>
      <link href="/2020/03/21/test/"/>
      <url>/2020/03/21/test/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><h2 id="测试标题"><a class="markdownIt-Anchor" href="#测试标题"></a> 测试标题</h2><h2 id="测试代码段"><a class="markdownIt-Anchor" href="#测试代码段"></a> 测试代码段</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"hello world new theme !"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="测试引用"><a class="markdownIt-Anchor" href="#测试引用"></a> 测试引用</h2><blockquote><p>fdifhdfd<br />dfdfdf</p></blockquote><h2 id="测试数学公式"><a class="markdownIt-Anchor" href="#测试数学公式"></a> 测试数学公式</h2><p>爱因斯坦的质能方程： <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>E</mi><mo>=</mo><mi>m</mi><msup><mi>c</mi><mn>2</mn></msup></mrow><annotation encoding="application/x-tex">E=mc^2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.05764em;">E</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.8141079999999999em;vertical-align:0em;"></span><span class="mord mathdefault">m</span><span class="mord"><span class="mord mathdefault">c</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span></span></span></span></p><p><span class="katex"><span class="katex-mathml"><math><semantics><mtable rowspacing="0.24999999999999992em" columnalign="center" columnspacing="1em"><mtr><mtd><mstyle scriptlevel="0" displaystyle="true"><mrow><mi>a</mi><mo>=</mo><mi>b</mi><mi mathvariant="normal">∣</mi><mi mathvariant="normal">∣</mi><mi>e</mi><mo>=</mo><mi>b</mi><mo>+</mo><mi>c</mi></mrow></mstyle></mtd></mtr></mtable><annotation encoding="application/x-tex">\begin{gathered} a=b || e=b+c \end{gathered}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.5000000000000002em;vertical-align:-0.5000000000000002em;"></span><span class="mord"><span class="mtable"><span class="col-align-c"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1em;"><span style="top:-3.16em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathdefault">a</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mord mathdefault">b</span><span class="mord">∣</span><span class="mord">∣</span><span class="mord mathdefault">e</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mord mathdefault">b</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mord mathdefault">c</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.5000000000000002em;"><span></span></span></span></span></span></span></span></span></span></span></p><h2 id="测试note"><a class="markdownIt-Anchor" href="#测试note"></a> 测试note</h2><div class="note success">            <h4 id="success-header"><a class="markdownIt-Anchor" href="#success-header"></a> Success Header</h4><p><strong>Welcome</strong> to <a href="https://hexo.io" target="_blank" rel="noopener">Hexo!</a></p>          </div><p><a href="https://theme-next.org/docs/tag-plugins/note" target="_blank" rel="noopener">具体用法</a></p><h2 id="流程图测试"><a class="markdownIt-Anchor" href="#流程图测试"></a> 流程图测试</h2><div class="mermaid">           pie     title Key elements in Product X     "Calcium" : 42.96     "Potassium" : 50.05     "Magnesium" : 10.01     "Iron" : 5           </div><p><a href="https://mermaid-js.github.io/mermaid/#/" target="_blank" rel="noopener">具体文档</a></p>]]></content>
      
      
      <categories>
          
          <category> 测试 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 测试博客 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>通过链表学递归</title>
      <link href="/2020/03/15/fucking-leetcode/01-%E9%93%BE%E8%A1%A8%E9%80%92%E5%BD%92%E4%B8%93%E9%A2%98/"/>
      <url>/2020/03/15/fucking-leetcode/01-%E9%93%BE%E8%A1%A8%E9%80%92%E5%BD%92%E4%B8%93%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><h1 id="为什么要写博客"><a class="markdownIt-Anchor" href="#为什么要写博客"></a> 为什么要写博客</h1><p>技术博客的内容固然重要，当然写作的背景和目的甚至比内容更重要。这就如同技术一样，知道技术本身重要，但是了解技术的提出背景和能够解决什么问题更重要。在文章的最后，总结博客的知识点以及存在的问题，这样方便引出下文，使得整套博客的内容有始有终，读起来有剧情感。</p><p>当然写博客是一个总结的过程，回顾自己的成长之路，看到自己努力的成果，这是一个正反馈的过程。回想一年多以前的自己，链表翻转的问题都不一定能够完整的写出来，但是经过一年多的刷题，自己再面对<code>Leetcode</code>上的题时，即使做不出来，也是会有思路的。</p><p>在这里讲一下自己的刷题过程，总体的策略就是按照<code>tag</code>进行刷题。具体来讲，每天早上在床上的时候，开始看一下题目，之后在洗漱、吃饭、走路的时候就可以想思路，甚至是实现的细节。有了电脑后去实现，如果成果就思考一下优化的方案；没成功的话，看看思路是不是正确，只会在接下来的空闲时间里去思考问题出在了哪里。在晚上洗脚时调试，临近睡觉之前看评论区的大神代码，毕竟代码一般都不会超过<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>40</mn></mrow><annotation encoding="application/x-tex">40</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">4</span><span class="mord">0</span></span></span></span>行代码。第二天早上尝试不同的方案去解题。这个过程虽是一个自信心受挫但是成长蛮快的阶段。</p><p>半年前就已经将<strong>链表</strong>专题的内容几乎做完，之后又做了<strong>二叉树</strong>专题，后续又做了<strong>递归回溯</strong>、<strong>动态规划</strong>等专题。经过不断的总结，把自己的做题的套路和心得记录下来，总结分享。</p><p>这篇博客主要介绍如何去使用<strong>递归</strong>解决<strong>链表</strong>问题，由浅入深，后续的博客中会使用<strong>递归</strong>解决<strong>二叉树</strong>等问题。</p><p><img src="/" alt="" / class="lazyload" data-src="https://cdn.jsdelivr.net/gh/jackymxp/image-bed/leetcode/00831rSTly1gcvfra4larj30u017de1t-20200322192003869.jpg"></p><h1 id="解决链表问题的一般技巧"><a class="markdownIt-Anchor" href="#解决链表问题的一般技巧"></a> 解决链表问题的一般技巧</h1><p>链表是通过带有指针域的节点相互连接成的一种线性结构，由于链表的这种天然的特性，一般都是通过修改链表中节点的指向完成链表的<strong>增删改查</strong>问题。修改链表节点的指针指向一般有非递归方法和递归法。</p><h2 id="1-非递归法"><a class="markdownIt-Anchor" href="#1-非递归法"></a> 1. 非递归法</h2><p><strong>通过修改指针的方式一般有以下几种技巧</strong>：</p><ul><li><p>设置虚拟头节点，但在函数最后返回之前，记得释放内存。</p></li><li><p>使用快慢指针，一般用于定位到中间节点或者判断链表是否有环问题。</p></li></ul><h2 id="2-递归法"><a class="markdownIt-Anchor" href="#2-递归法"></a> 2. 递归法</h2><ul><li><p><strong>递归法的原理</strong></p><p>由于链表是通过指针域连接的线性结构，所以可以把一个完整的链表看成若干个结构相同但是长更短的链表构成，这就相当于在递归函数中缩减了函数的规模。</p><p>当链表的长度短到一定的程度，就相当于递归函数的退出条件。</p><p>当对更短的节点修改了指针后，链表的局部达到了期望的结构。其余的链表也使用同样的方法即调用同一个函数来修改节点的指向，这样就完成了整体链表结构的修改。</p><p>这就是通过递归修改链表的原理，通过这个原理总结了编写递归函数的</p></li><li><p><strong>编写递归函数的三个步骤：</strong></p><ol><li>定义了一个递归函数<code>fun(ListNode*)</code>，一定要<strong>明确递归函数的功能，以及递归函数的返回值</strong>。这样是当传入头节点<code>head</code>并且执行完<code>fun(head)</code>函数后，链表的结构就应该改变成希望的样子。这个就是递归的功能。</li><li><strong>明确递归函数的退出条件</strong>。否则递归函数找不到出口，就一直递归下去，爆栈。</li><li>将链表拆成若干部分，一部分的头节点是<code>head</code>，另外一部分的头节点是<code>newHead</code>，<strong>根据定义的函数的功能，推理当执行完<code>fun(newHead)</code>的时候，链表变成了什么样子，这时<code>newHead</code>部分已经变成我们期望的链表结构。接下来就是应该如何修改<code>head</code>为头节点的链表的的指针，使得整个链表的结构和期望的结构相同</strong>。</li></ol><p><strong>切记千万不要进入递归函数中探索太多的细节</strong>，人脑的栈太小，探索不了太多细节就乱了。实在想探索递归函数运行的细节，就在纸上画图，画出每层递归函数的入口参数及返回值。</p></li></ul><p>好了，给出我的心得之后，但是这些就像是数学公式一样，如果不通过例题是很难知道怎么用这些公式一样。所以接下来就通过一些例题来体会一下如何写好递归函数。</p><h1 id="翻转链表题"><a class="markdownIt-Anchor" href="#翻转链表题"></a> 翻转链表题</h1><h2 id="206-反转链表"><a class="markdownIt-Anchor" href="#206-反转链表"></a> <a href="https://leetcode-cn.com/problems/reverse-linked-list/" target="_blank" rel="noopener">206. 反转链表</a></h2><ol><li><p><strong>定义递归函数<code>ListNode* reverseList(ListNode* head)</code>功能以及返回值</strong>：</p><p>定义功能为：翻转以<code>head</code>为头节点的链表，并返回翻转后的链表的头节点。</p><p>根据定义的递归函数功能，首先将<code>reverseList</code>的作用范围放在整个链表，图中有绿色的阴影部分代表递归函数<code>reverseList</code>的作用范围，也就是将<code>head</code>作为参数传递给<code>reverseList(head)</code>作用的范围。</p><p><img src="/" alt="" / class="lazyload" data-src="https://tva1.sinaimg.cn/large/00831rSTly1gd2x4tff4nj318e0620u7.jpg"></p><p>当把<code>head</code>作为参数传递给递归函数<code>reverseList</code>作用后，根据定义的递归函数功能，这个函数就完成了整个链表的翻转，也就是期望的最终答案。</p><p><img src="/" alt="" / class="lazyload" data-src="https://tva1.sinaimg.cn/large/00831rSTly1gd2x4twjlmj315604kmxx.jpg"></p></li><li><p><strong>寻找递归函数退出条件和返回值</strong></p><p>当链表中只有一个节点或者没有节点的时候，不需要任何反转，就可以直接返回。</p> <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(!head || !head-&gt;next)</span><br><span class="line">    <span class="keyword">return</span> head;</span><br></pre></td></tr></table></figure></li><li><p><strong>缩小递归函数的规模，寻求层与层之间的关系</strong></p><p>为了缩小递归函数的规模，所以要将链表分成了两个部分，由于是每一个节点都要进行反转，所以要将链表分成长度分别为<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>1</mn></mrow><annotation encoding="application/x-tex">1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span>和<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>k</mi><mo>−</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">k-1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.77777em;vertical-align:-0.08333em;"></span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span>的两个链表，其中<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>k</mi></mrow><annotation encoding="application/x-tex">k</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span></span></span></span>是原链表的长度。两部分链表的头节点分别为<code>head</code>和<code>newHead</code>。当缩小递归函数的范围的时候，即将<code>newHead</code>作为参数传入到<code>reverseList</code>函数中，其中递归函数的作用范围表示成图。</p><p><img src="/" alt="" / class="lazyload" data-src="https://cdn.jsdelivr.net/gh/jackymxp/image-bed/leetcode/20200322101626.png"></p><p>当递归函数<code>reverseList(newHead)</code>执行完成后，根据递归函数的功能，这样就完成了长度为<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>k</mi><mo>−</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">k-1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.77777em;vertical-align:-0.08333em;"></span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span>部分链表的反转，除头节点外的其余节点都符合期望的结构。整个链表变成如下这个样子。</p><p><img src="/" alt="" / class="lazyload" data-src="https://cdn.jsdelivr.net/gh/jackymxp/image-bed/leetcode/20200322102043.png"></p><p>写成代码的形式：</p> <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ListNode* newHead = next-&gt;next;</span><br><span class="line">head-&gt;next = <span class="literal">nullptr</span>; <span class="comment">//将链表分成两个部分</span></span><br><span class="line">ListNode* retHead = reverseList(newHead);</span><br></pre></td></tr></table></figure><p>通过观察发现，只要在修改<code>head</code>和<code>newHead</code>的指针就完成了这个链表的反转。</p><p><strong>最后不要忘记让头节点<code>head-&gt;next</code>指向<code>nullptr</code>，否则递归函数找不到空节点，递归超时。这样就完成了翻转</strong>。写成代码如下：</p> <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">newHead-&gt;next = head;</span><br><span class="line">head-&gt;next = <span class="literal">nullptr</span>;</span><br></pre></td></tr></table></figure></li><li><p><strong>递归代码</strong></p> <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">reverseList</span><span class="params">(ListNode* head)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//当链表中只有一个节点或者没有节点的时候，直接退出</span></span><br><span class="line">        <span class="keyword">if</span>(!head || !head-&gt;next)</span><br><span class="line">            <span class="keyword">return</span> head;</span><br><span class="line">        <span class="comment">//分成两个部分</span></span><br><span class="line">        ListNode* newHead = head-&gt;next;</span><br><span class="line">        head-&gt;next = <span class="literal">nullptr</span>;</span><br><span class="line">        <span class="comment">//完成 k - 1 部分的翻转</span></span><br><span class="line">        ListNode* retHead = reverseList(newHead);</span><br><span class="line">        <span class="comment">//修改指针，是最后一部分完成翻转</span></span><br><span class="line">        newHead-&gt;next = head;</span><br><span class="line">        head-&gt;next = <span class="literal">nullptr</span>;</span><br><span class="line">        <span class="keyword">return</span> retHead;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li><li><p><strong>迭代代码</strong></p> <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">reverseList</span><span class="params">(ListNode* head)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!head || !head-&gt;next)</span><br><span class="line">            <span class="keyword">return</span> head;</span><br><span class="line">        ListNode* pre = <span class="literal">nullptr</span>;</span><br><span class="line">        ListNode* cur = head;  <span class="comment">//pre -&gt; cur -&gt; next   ===&gt;&gt;&gt;   pre &lt;- cur &lt;- next</span></span><br><span class="line">        <span class="keyword">while</span>(cur)</span><br><span class="line">        &#123;</span><br><span class="line">            ListNode* next = cur-&gt;next; <span class="comment">//保存下一个节点</span></span><br><span class="line">            cur-&gt;next = pre; <span class="comment">//修改next指针是其指向 pre</span></span><br><span class="line">            <span class="comment">//pre和next都向后移动一位</span></span><br><span class="line">            pre = cur;  </span><br><span class="line">            cur = next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> pre;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ol><hr /><h2 id="24-两两交换链表中的节点"><a class="markdownIt-Anchor" href="#24-两两交换链表中的节点"></a> <a href="https://leetcode-cn.com/problems/swap-nodes-in-pairs/" target="_blank" rel="noopener">24. 两两交换链表中的节点</a></h2><p>还是按照递归的套路，分三步。</p><ol><li><p><strong>定义递归函数<code>ListNode* swapPairs(ListNode* head)</code>功能以及返回值</strong></p><p>定义递归函数功能：每两个翻转链表中的节点，并将翻转后新的链表节点作为返回值。</p><p>根据定义的递归函数功能，首先将<code>swapPairs</code>的作用范围放在整个链表，图中有绿色的阴影部分代表递归函数<code>swapPairs</code>的作用范围，也就是将就是将<code>head</code>作为参数传递给<code>swapPairs(head)</code>作用的范围。</p><p><img src="/" alt="" / class="lazyload" data-src="https://tva1.sinaimg.cn/large/00831rSTly1gcvk3rsggjj318e06imxj.jpg"></p><p>当把<code>head</code>作为参数传递给递归函数<code>swapPairs</code>作用后，根据定义的递归函数功能，这个函数就完成<strong>两两交换其中相邻的节点</strong>，并返回了交换后的链表的头节点<code>retHead</code>。</p><p><img src="/" alt="" / class="lazyload" data-src="https://cdn.jsdelivr.net/gh/jackymxp/image-bed/leetcode/20200322105029.png"></p></li><li><p><strong>寻找递归函数退出条件和返回值</strong></p><p>当链表中只有一个节点或者没有节点的时候，不需要任何反转，就可以直接返回。</p> <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(head == <span class="literal">nullptr</span> || head-&gt;next == <span class="literal">nullptr</span>)</span><br><span class="line">    <span class="keyword">return</span> head;</span><br></pre></td></tr></table></figure></li><li><p><strong>缩小递归函数的规模，寻求层与层之间的关系</strong></p><p>为了缩小递归函数的规模，所以要将链表分成了两个部分，由于是每一个节点都要进行反转，所以要将链表分成长度分别为<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>2</mn></mrow><annotation encoding="application/x-tex">2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">2</span></span></span></span>和<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>k</mi><mo>−</mo><mn>2</mn></mrow><annotation encoding="application/x-tex">k-2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.77777em;vertical-align:-0.08333em;"></span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">2</span></span></span></span>的两个链表，其中<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>k</mi></mrow><annotation encoding="application/x-tex">k</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span></span></span></span>是原链表的长度。两部分链表的头节点分别为<code>head</code>和<code>newHead</code>。当缩小递归函数的范围的时候，即将<code>newHead</code>作为参数传入到<code>swapPairs</code>函数中，其中递归函数的作用范围表示成图。</p><p><img src="/" alt="" / class="lazyload" data-src="https://cdn.jsdelivr.net/gh/jackymxp/image-bed/leetcode/20200322105844.png"></p><p>当递归函数<code>swapPairs(newHead)</code>执行完成后，根据递归函数的功能，除第一个和第二个节点没有符合期望的结构，其余节点都符合期望的结构。整个链表变成如下这个样子。</p><p><img src="/" alt="image-20200322110545833" / class="lazyload" data-src="https://tva1.sinaimg.cn/large/00831rSTly1gd2kg8bafij31100803za.jpg"></p><p>写成代码的形式：</p> <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//将链表分为两个部分</span></span><br><span class="line">ListNode* newHead = head-&gt;next-&gt;next;</span><br><span class="line">head-&gt;next-&gt;next = <span class="literal">nullptr</span>;</span><br><span class="line"><span class="comment">//递归反转长度为 k - 2 的链表部分</span></span><br><span class="line">ListNode* retNode = swapPairs(newHead);</span><br></pre></td></tr></table></figure><p>最后和预期的结构相对比，只要修改<code>head</code>、<code>newHead</code>的指针域，即可完成整个链表的两两节点的交换，写成代码：</p> <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//对照图片，完成长度为 2 的链表的节点交换</span></span><br><span class="line">ListNode* retHead = head-&gt;next;</span><br><span class="line">retHead-&gt;next = head;</span><br><span class="line">head-&gt;next = retNode;</span><br><span class="line"><span class="keyword">return</span> retHead;</span><br></pre></td></tr></table></figure></li><li><p><strong>递归代码</strong></p> <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">swapPairs</span><span class="params">(ListNode* head)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//递归退出条件，只有一个节点，或者没有节点的时候</span></span><br><span class="line">        <span class="keyword">if</span>(!head || !head-&gt;next)</span><br><span class="line">            <span class="keyword">return</span> head;</span><br><span class="line">        <span class="comment">//将链表分为两个部分</span></span><br><span class="line">        ListNode* newHead = head-&gt;next-&gt;next;</span><br><span class="line">        head-&gt;next-&gt;next = <span class="literal">nullptr</span>;</span><br><span class="line">        <span class="comment">//递归反转长度为 k - 2 的链表部分</span></span><br><span class="line">        ListNode* retNode = swapPairs(newHead);</span><br><span class="line">        <span class="comment">//通过修改长度为2部分链表的指针，完成这个链表的翻转</span></span><br><span class="line">        ListNode* retHead = head-&gt;next;</span><br><span class="line">        retHead-&gt;next = head;</span><br><span class="line">        head-&gt;next = retNode;</span><br><span class="line">        <span class="keyword">return</span> retHead;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li><li><p><strong>迭代代码</strong></p> <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">swapPairs</span><span class="params">(ListNode* head)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!head || !head-&gt;next)</span><br><span class="line">            <span class="keyword">return</span> head;</span><br><span class="line">        ListNode *first = head;</span><br><span class="line">        ListNode *second = head-&gt;next;</span><br><span class="line">        <span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">            ListNode *third = second-&gt;next;</span><br><span class="line">            <span class="comment">//交换</span></span><br><span class="line">            swap(second-&gt;val,first-&gt;val);</span><br><span class="line">            <span class="keyword">if</span>(!third || !third-&gt;next)<span class="keyword">return</span> head;</span><br><span class="line">            <span class="comment">//向前前进两步</span></span><br><span class="line">            first = third;</span><br><span class="line">            second = third-&gt;next;</span><br><span class="line">            third = third-&gt;next-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ol><hr /><h2 id="25-k-个一组翻转链表"><a class="markdownIt-Anchor" href="#25-k-个一组翻转链表"></a> <a href="https://leetcode-cn.com/problems/reverse-nodes-in-k-group/" target="_blank" rel="noopener">25. K 个一组翻转链表</a></h2><p>这道题在<code>leetcode</code>中被定义为难题，但是有前面的基础，当<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>k</mi><mo>=</mo><mn>2</mn></mrow><annotation encoding="application/x-tex">k=2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">2</span></span></span></span>的时候，就是<a href="https://leetcode-cn.com/problems/swap-nodes-in-pairs/" target="_blank" rel="noopener">两两交换链表中的节点</a>题；当<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>k</mi></mrow><annotation encoding="application/x-tex">k</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span></span></span></span>等于链表长度时，就是<a href="https://leetcode-cn.com/problems/reverse-linked-list/" target="_blank" rel="noopener">反转链表</a>题，所以做这个题就不是很难了，只需要做一小部分的改动就可以。下面根据递归套路的三个步骤，完成这个题。</p><ol><li><p><strong>定义递归函数<code>ListNode* reverseKGroup(ListNode* head, int k)</code>功能以及返回值</strong></p><p>定义递归函数功能：在链表中，每<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>k</mi></mrow><annotation encoding="application/x-tex">k</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span></span></span></span>个节点翻转一次，并将新的链表节点作为返回值。</p><p>根据定义的递归函数功能，首先将<code>reverseKGroup</code>的作用范围放在整个链表，图中有绿色的阴影部分代表递归函数<code>reverseKGroup</code>的作用范围，也就是将<code>head</code>作为参数传递给<code>reverseKGroup(head)</code>作用的范围。</p><p><img src="/" alt="" / class="lazyload" data-src="https://cdn.jsdelivr.net/gh/jackymxp/image-bed/leetcode/20200322120919.png"></p><p>当把<code>head</code>作为参数传递给递归函数<code>reverseKGroup</code>作用后，根据定义的递归函数功能，这个函数就完成以<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>k</mi></mrow><annotation encoding="application/x-tex">k</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span></span></span></span>个为一组进行翻转链表，并返回翻转后的链表头节点。假设这里<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>k</mi><mo>=</mo><mn>3</mn></mrow><annotation encoding="application/x-tex">k = 3</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">3</span></span></span></span>。</p><p><img src="/" alt="" / class="lazyload" data-src="https://cdn.jsdelivr.net/gh/jackymxp/image-bed/leetcode/20200322120958.png"></p></li><li><p><strong>寻找递归函数退出条件和返回值</strong></p><p>当链表中的节点的个数小于<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>k</mi></mrow><annotation encoding="application/x-tex">k</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span></span></span></span>的时候，不够一组，可以不需要做任何的翻转操作直接返回。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(NodeNumLessK(head, k) == <span class="literal">true</span>)</span><br><span class="line">    <span class="keyword">return</span> head;</span><br></pre></td></tr></table></figure></li><li><p><strong>缩小递归函数的规模，寻求层与层之间的关系</strong></p><p>为了缩小递归函数的规模，所以要将链表分成了两个部分，由于是每<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>k</mi></mrow><annotation encoding="application/x-tex">k</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span></span></span></span>节点反转，所以将链表分成长度分别为<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>k</mi></mrow><annotation encoding="application/x-tex">k</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span></span></span></span>和<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>n</mi><mo>−</mo><mi>k</mi></mrow><annotation encoding="application/x-tex">n-k</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.66666em;vertical-align:-0.08333em;"></span><span class="mord mathdefault">n</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span></span></span></span>的两个链表，其中<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">n</span></span></span></span>是原链表的长度。两部分链表的头节点分别为<code>head</code>和<code>newHead</code>。当缩小递归函数的范围的时候，即将<code>newHead</code>作为参数传入到<code>reverseKGroup</code>函数中，其中递归函数的作用范围表示成图。</p><p><img src="/" alt="" / class="lazyload" data-src="https://cdn.jsdelivr.net/gh/jackymxp/image-bed/leetcode/20200322121211.png"></p><p>当递归函数<code>reverseKGroup(newHead)</code>执行完成后，根据递归函数的功能，除前<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>k</mi></mrow><annotation encoding="application/x-tex">k</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span></span></span></span>个链表没有符合期望的结构，其余节点都符合期望的结构。整个链表变成如下这个样子。</p><p><img src="/" alt="image-20200322121314111" / class="lazyload" data-src="https://tva1.sinaimg.cn/large/00831rSTly1gd2x4ueqt7j31cm07o75j.jpg"></p><p>写成代码的形式：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//定位到第 k 个节点</span></span><br><span class="line">ListNode* newHead = head;</span><br><span class="line">ListNode* retNode;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; k; i++)&#123;</span><br><span class="line">    retNode = newHead;</span><br><span class="line">    newHead = newHead-&gt;next;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//将链表分成两个部分</span></span><br><span class="line">retNode-&gt;next = <span class="literal">nullptr</span>;</span><br><span class="line"><span class="comment">//递归反转长度为 n - k 的链表部分</span></span><br><span class="line">ListNode* retHead = reverseKGroup(newHead, <span class="number">0</span>);</span><br></pre></td></tr></table></figure><p>最后和预期的结构相对比，只要翻转前<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>k</mi></mrow><annotation encoding="application/x-tex">k</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span></span></span></span>个链表的节点，再改变指针的指向就完成了所有节点按照<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>k</mi></mrow><annotation encoding="application/x-tex">k</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span></span></span></span>个一组翻转链表。写成代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">reverseList(head);</span><br><span class="line">    <span class="comment">//将第一部分和第二部分连接起来</span></span><br><span class="line">    head-&gt;next = retHead;</span><br><span class="line">    <span class="keyword">return</span> retNode;</span><br></pre></td></tr></table></figure></li><li><p><strong>递归代码</strong></p><p><strong>PS:</strong> 这段代码虽然有近<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>50</mn></mrow><annotation encoding="application/x-tex">50</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">5</span><span class="mord">0</span></span></span></span>行，但是抛出递归退出条件的判断和前面遇到的翻转链表的代码，当然还有很多注释之外，核心的代码不到<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>10</mn></mrow><annotation encoding="application/x-tex">10</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span><span class="mord">0</span></span></span></span>行，所以结合前面的图和注释很容易理解。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">NodeNumLessK</span><span class="params">(ListNode* p, <span class="keyword">int</span> k)</span></span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; k; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(p == <span class="literal">nullptr</span>)</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            p = p-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">ListNode* <span class="title">reverseList</span><span class="params">(ListNode* head)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//当只有一个节点或者没有节点，递归退出条件</span></span><br><span class="line">        <span class="keyword">if</span>(!head || !head-&gt;next)</span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line">        <span class="comment">//缩小递归规模</span></span><br><span class="line">        ListNode* newHead = reverseList(head-&gt;next);</span><br><span class="line">        <span class="comment">//改变层与层之间的关系</span></span><br><span class="line">        <span class="comment">//当head-&gt;next部分完成反转后，改变指针指向，完成整个链表的翻转</span></span><br><span class="line">        head-&gt;next-&gt;next = head;</span><br><span class="line">        <span class="comment">//将head-&gt;next置空，否则找不到空节点，递归超时</span></span><br><span class="line">        head-&gt;next = <span class="literal">nullptr</span>;</span><br><span class="line">        <span class="keyword">return</span> newHead;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">ListNode* <span class="title">reverseKGroup</span><span class="params">(ListNode* head, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//当链表节点小于k的时候，直接退出</span></span><br><span class="line">        <span class="keyword">if</span>(NodeNumLessK(head, k))</span><br><span class="line">            <span class="keyword">return</span> head;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//定位到第 k 个节点</span></span><br><span class="line">        ListNode* newHead = head;</span><br><span class="line">        ListNode* retNode;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; k; i++)&#123;</span><br><span class="line">            retNode = newHead;</span><br><span class="line">            newHead = newHead-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//将链表分成两个部分</span></span><br><span class="line">        retNode-&gt;next = <span class="literal">nullptr</span>;</span><br><span class="line">        <span class="comment">//递归反转长度为 n - k 的链表部分</span></span><br><span class="line">        ListNode* retHead = reverseKGroup(newHead, k);</span><br><span class="line"></span><br><span class="line">        reverseList(head);</span><br><span class="line">        <span class="comment">//将第一部分和第二部分连接起来</span></span><br><span class="line">        head-&gt;next = retHead;</span><br><span class="line">        <span class="keyword">return</span> retNode;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ol><hr /><h1 id="合并链表题"><a class="markdownIt-Anchor" href="#合并链表题"></a> 合并链表题</h1><p>翻转链表类型的题目，涉及的都是直接修改链表的指针指向，在合并链表的过程中，涉及的还是修改指针的指向，唯一不同的是，链表翻转是一个链表的，而合并链表的题可能涉及到多个链表，但是也只是单纯的改变指针指。</p><h2 id="21-合并两个有序链表"><a class="markdownIt-Anchor" href="#21-合并两个有序链表"></a> <a href="https://leetcode-cn.com/problems/merge-two-sorted-lists/" target="_blank" rel="noopener">21. 合并两个有序链表</a></h2><p>还是按照递归的三个步骤</p><ol><li><p><strong>定义递归函数<code>ListNode* mergeTwoLists(ListNode* l1, ListNode* l2)</code>功能以及返回值</strong></p><p>合并两个已经排序的链表，并且返回排序后链表的头节点。</p><p>根据这个定义，当传入两个如下所示的链表，应该返回的是这样的链表。</p><p><img src="/" alt="" / class="lazyload" data-src="https://tva1.sinaimg.cn/large/00831rSTly1gcwo90kk3fj31ly0pqmz2.jpg"></p></li><li><p><strong>寻找递归函数退出条件和返回值</strong></p><p>当两个链表中有一个链表为空的时候，不管另外一个链表是否为空，都直接返回另外一个链表。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(!l1 || !l2)</span><br><span class="line">    <span class="keyword">return</span> l1 ? l1 : l2;</span><br></pre></td></tr></table></figure></li><li><p><strong>缩小递归函数的规模，寻求层与层之间的关系</strong></p><p>为了缩小递归函数的规模，所以要将链表分成了两个部分，由于是合并链表，所以将链表分成已排序的和未排序的链表两个部分。合并的过程从两个链表的头节点开始，<code>p1</code>的头节点值小于<code>p2</code>的值，所以<code>p1</code>的头节点就是合并后的链表的头节点。 将<code>p1</code>节点单独拿出来，并且保存<code>p1</code>节点的下一个节点为<code>pn</code>。此时<code>p1</code>节点已经是有序的。</p><p>继续合并链表中的剩余节点，发现<code>pn</code>和<code>p2</code>依然是一个合并有序链表的过程，还是依然比较两个头节点的值，所以这个过程依然可以调用<code>mergeTwoLists(pn, p2)</code>完成链表剩余部分的排序。</p><p><img src="/" alt="" / class="lazyload" data-src="https://tva1.sinaimg.cn/large/00831rSTly1gcwoqo4jfvj312u0k0my8.jpg"></p><p>当递归函数 <code>mergeTwoLists(pn, p2)</code> 执行完成后，根据递归函数的功能，<code>pn</code>和<code>p2</code>链表已经形成一个有序的链表，所以整个链表变成如下这个样子。</p><p>将链表的两部分连接起来，所以将<code>p1-&gt;next</code>指向<code>retNode</code>。</p><p><img src="/" alt="" / class="lazyload" data-src="https://cdn.jsdelivr.net/gh/jackymxp/image-bed/leetcode/20200322203408.png"></p><p>将上述过程写成代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(p1-&gt;val &lt; p2-&gt;val)</span><br><span class="line">&#123;</span><br><span class="line">    ListNode* pn = l1-&gt;next;</span><br><span class="line">    l1-&gt;next = <span class="literal">nullptr</span>;</span><br><span class="line">    ListNode* retNode = mergeTwoLists(pn, p2);</span><br><span class="line">    p1-&gt;next = retNode;</span><br><span class="line">    <span class="keyword">return</span> p1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当<code>p2</code>的值小于<code>p1</code>的值时，合并的过程还是这个样子的。</p><p><img src="/" alt="" / class="lazyload" data-src="https://cdn.jsdelivr.net/gh/jackymxp/image-bed/leetcode/20200322205036.png"></p></li><li><p><strong>完整代码</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">mergeTwoLists</span><span class="params">(ListNode* l1, ListNode* l2)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//当有一个链表为空的时候，直接返回另外一个链表，不管另外一个是否为空</span></span><br><span class="line">        <span class="keyword">if</span>(!l1 || !l2)</span><br><span class="line">            <span class="keyword">return</span> l1 ? l1 : l2;</span><br><span class="line">        <span class="comment">//当l1-&gt;val 小于l2-&gt;val, 直接将l1-&gt;next指向递归的下一层</span></span><br><span class="line">        <span class="keyword">if</span>(l1-&gt;val &lt; l2-&gt;val)</span><br><span class="line">        &#123;</span><br><span class="line">            l1-&gt;next = mergeTwoLists(l1-&gt;next, l2);</span><br><span class="line">            <span class="keyword">return</span> l1;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            l2-&gt;next = mergeTwoLists(l1, l2-&gt;next);</span><br><span class="line">            <span class="keyword">return</span> l2;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ol><h2 id="23-合并k个排序链表"><a class="markdownIt-Anchor" href="#23-合并k个排序链表"></a> <a href="https://leetcode-cn.com/problems/merge-k-sorted-lists/" target="_blank" rel="noopener">23. 合并K个排序链表</a></h2><p>有了<a href="https://leetcode-cn.com/problems/merge-two-sorted-lists/" target="_blank" rel="noopener">合并两个有序链表</a>基础，解决这道题的基本思路还是一样，这次不画图，只是根据定义的递归函数<code>ListNode* mergeKLists(vector&lt;ListNode*&gt;&amp; lists)</code>和上一题的<code>ListNode* mergeTwoLists(ListNode* l1, ListNode* l2)</code>的函数基础，单纯的推导出如何合并<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>k</mi></mrow><annotation encoding="application/x-tex">k</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span></span></span></span>个链表。</p><p>还是按照递归的三个步骤继续走起。</p><ol><li><p><strong>定义递归函数<code>ListNode* mergeKLists(vector&lt;ListNode*&gt;&amp; lists)</code>功能以及返回值</strong></p><p>定义递归函数功能：按照从小达到的顺序合并<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>k</mi></mrow><annotation encoding="application/x-tex">k</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span></span></span></span>个有序链表，并返回排序后链表的头节点。</p></li><li><p><strong>寻找递归函数退出条件和返回值</strong></p><p>想一下，这时候的递归的退出条件是什么？很简单，无非就是讨论<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>k</mi></mrow><annotation encoding="application/x-tex">k</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span></span></span></span>的值。</p><ul><li>当<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>k</mi><mo>=</mo><mn>0</mn></mrow><annotation encoding="application/x-tex">k = 0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">0</span></span></span></span>时，不需要返回任何链表，所以直接返回<code>nullptr</code>。</li><li>当<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>k</mi><mo>=</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">k = 1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span>时，只有一个链表，不需要合并操作，直接返回<code>lists[0]</code>。</li><li>当<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>k</mi><mo>=</mo><mn>2</mn></mrow><annotation encoding="application/x-tex">k = 2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">2</span></span></span></span>时，这个就是合并两个有序链表，直接调用<code>ListNode* mergeTwoLists(lists[0], lists[1])</code>完成合并。</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(k == <span class="number">0</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(k == <span class="number">1</span>)</span><br><span class="line">    <span class="keyword">return</span> lists[<span class="number">0</span>];</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(k == <span class="number">2</span>)</span><br><span class="line">    <span class="keyword">return</span> mergeTwoLists(lists[<span class="number">0</span>], lists[<span class="number">1</span>]);</span><br></pre></td></tr></table></figure></li><li><p><strong>缩小递归函数的规模，寻求层与层之间的关系</strong></p><p>为了缩小递归函数的规模，所以要将<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>k</mi></mrow><annotation encoding="application/x-tex">k</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span></span></span></span>个链表分成了两个部分，但是每个部分有多少个链表，这里可以有不同的分配策略。</p><p><strong>策略1：</strong></p><p>将<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>k</mi></mrow><annotation encoding="application/x-tex">k</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span></span></span></span>个链表拆分成两部分，其中一部分的链表规模是<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>1</mn></mrow><annotation encoding="application/x-tex">1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span>，另外一部分链表的规模时<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>k</mi><mo>−</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">k-1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.77777em;vertical-align:-0.08333em;"></span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span>。当有<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>k</mi></mrow><annotation encoding="application/x-tex">k</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span></span></span></span>个链表的时候，调用的是<code>mergeKLists</code>函数，那么当<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>k</mi><mo>=</mo><mi>k</mi><mo>−</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">k = k-1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.77777em;vertical-align:-0.08333em;"></span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span>时并且<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>k</mi><mo>−</mo><mn>1</mn><mo>&gt;</mo><mn>2</mn></mrow><annotation encoding="application/x-tex">k-1 &gt; 2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.77777em;vertical-align:-0.08333em;"></span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.68354em;vertical-align:-0.0391em;"></span><span class="mord">1</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">&gt;</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">2</span></span></span></span>时，依然可以调用<code>mergeKLists(lists[0...k-2])</code>函数合并<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>k</mi><mo>−</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">k-1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.77777em;vertical-align:-0.08333em;"></span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span>个链表，并返回一个排序的链表头节点<code>node</code>，再和规模为<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>1</mn></mrow><annotation encoding="application/x-tex">1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span>的第<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>k</mi></mrow><annotation encoding="application/x-tex">k</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span></span></span></span>个链表做合并两个排序链表的过程，即调用<code>mergeTwoLists(node, lists[k-1])</code>，再返回。</p><p>对应的代码</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ListNode* node = mergeKLists(<span class="built_in">vector</span>&lt;ListNode*&gt;(lists.begin(), lists.end()<span class="number">-1</span>));</span><br><span class="line"><span class="keyword">return</span> mergeTwoLists(node, lists[lists.size()<span class="number">-1</span>]);</span><br></pre></td></tr></table></figure><p>这样的合并策略由于每次只能合并一条链表，所以递归深度比较深，所以性能开销比较大。</p><p><strong>策略2:</strong></p><p>仿照归并排序，将<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>k</mi></mrow><annotation encoding="application/x-tex">k</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span></span></span></span>个链表分成<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>2</mn></mrow><annotation encoding="application/x-tex">2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">2</span></span></span></span>个部分，每部分有<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>k</mi><mi mathvariant="normal">/</mi><mn>2</mn></mrow><annotation encoding="application/x-tex">k/2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span><span class="mord">/</span><span class="mord">2</span></span></span></span>个链表。当<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>k</mi><mo>=</mo><mi>k</mi><mi mathvariant="normal">/</mi><mn>2</mn></mrow><annotation encoding="application/x-tex">k = k/2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span><span class="mord">/</span><span class="mord">2</span></span></span></span>时并且<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>k</mi><mi mathvariant="normal">/</mi><mn>2</mn><mo>&gt;</mo><mn>2</mn></mrow><annotation encoding="application/x-tex">k/2 &gt; 2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span><span class="mord">/</span><span class="mord">2</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">&gt;</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">2</span></span></span></span>时，依然可以调用<code>mergeKLists(lists[0...k/2))</code>和<code>mergeKLists(lists[k/2...k))</code>函数合并<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>k</mi><mi mathvariant="normal">/</mi><mn>2</mn></mrow><annotation encoding="application/x-tex">k/2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span><span class="mord">/</span><span class="mord">2</span></span></span></span>个链表，每部分都会返回排序<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>k</mi><mi mathvariant="normal">/</mi><mn>2</mn></mrow><annotation encoding="application/x-tex">k/2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span><span class="mord">/</span><span class="mord">2</span></span></span></span>个链表的头节点<code>node1</code>和<code>node2</code>，这时候再调用<code>mergeTwoLists(node1, node2)</code>，再返回。</p><p>对应的代码</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="built_in">vector</span>&lt;ListNode*&gt; <span class="title">front</span><span class="params">(lists.begin(), lists.begin()+len/<span class="number">2</span>)</span></span>;</span><br><span class="line"><span class="function"><span class="built_in">vector</span>&lt;ListNode*&gt; <span class="title">back</span><span class="params">(lists.begin()+len/<span class="number">2</span>, lists.end())</span></span>;</span><br><span class="line"><span class="comment">//合并前k/2个链表</span></span><br><span class="line">ListNode* node1 = mergeKLists(front);</span><br><span class="line"><span class="comment">//合并后k/2个链表</span></span><br><span class="line">ListNode* node2 = mergeKLists(back);</span><br><span class="line"><span class="comment">//将两个链表合并的结果使用合并两个链表函数合并</span></span><br><span class="line"><span class="keyword">return</span> mergeTwoLists(node1, node2);</span><br></pre></td></tr></table></figure></li><li><p><strong>完整代码</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line">    <span class="function">ListNode* <span class="title">mergeTwoLists</span><span class="params">(ListNode* l1, ListNode* l2)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//当有一个链表为空的时候，直接返回另外一个链表，不管另外一个是否为空</span></span><br><span class="line">        <span class="keyword">if</span>(!l1 || !l2)</span><br><span class="line">            <span class="keyword">return</span> l1 ? l1 : l2;</span><br><span class="line">        <span class="comment">//当l1-&gt;val 小于l2-&gt;val, 直接将l1-&gt;next指向递归的下一层</span></span><br><span class="line">        <span class="keyword">if</span>(l1-&gt;val &lt; l2-&gt;val)</span><br><span class="line">        &#123;</span><br><span class="line">            l1-&gt;next = mergeTwoLists(l1-&gt;next, l2);</span><br><span class="line">            <span class="keyword">return</span> l1;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            l2-&gt;next = mergeTwoLists(l1, l2-&gt;next);</span><br><span class="line">            <span class="keyword">return</span> l2;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">mergeKLists</span><span class="params">(<span class="built_in">vector</span>&lt;ListNode*&gt;&amp; lists)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> len = lists.size();</span><br><span class="line">        <span class="keyword">if</span>(len == <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(len == <span class="number">1</span>)</span><br><span class="line">            <span class="keyword">return</span> lists[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(len == <span class="number">2</span>)</span><br><span class="line">            <span class="keyword">return</span> mergeTwoLists(lists[<span class="number">0</span>], lists[<span class="number">1</span>]);</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">vector</span>&lt;ListNode*&gt; front(lists.begin(), lists.begin()+len/<span class="number">2</span>);</span><br><span class="line">            <span class="function"><span class="built_in">vector</span>&lt;ListNode*&gt; <span class="title">back</span><span class="params">(lists.begin()+len/<span class="number">2</span>, lists.end())</span></span>;</span><br><span class="line">            ListNode* node1 = mergeKLists(front);</span><br><span class="line">            ListNode* node2 = mergeKLists(back);</span><br><span class="line">            <span class="keyword">return</span> mergeTwoLists(node1, node2);</span><br><span class="line">        &#125;         </span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ol><h2 id="148-排序链表"><a class="markdownIt-Anchor" href="#148-排序链表"></a> <a href="https://leetcode-cn.com/problems/sort-list/" target="_blank" rel="noopener">148. 排序链表</a></h2><p>这个题要求使用<code>O(nlogn)</code>的时间复杂度，只有快速排序、堆排序、归并排序符合这个时间的复杂度为了复用上面实现的合并两个有序链表的代码， 采用<strong>归并排序</strong>。</p><p>还是原来的套路，分三步继续走。Let’s go。</p><ol><li><p><strong>定义递归函数<code>ListNode* sortList(ListNode* head)</code>功能以及返回值</strong>：</p><p>根据定义的递归函数功能，首先将<code>sortList</code>的作用范围放在整个链表，图中有绿色的阴影部分代表递归函数<code>sortList</code>的作用范围，也就是将<code>head</code>作为参数传递给<code>sortList(head)</code>作用的范围。</p><p><img src="/" alt="" / class="lazyload" data-src="https://cdn.jsdelivr.net/gh/jackymxp/image-bed/leetcode/20200322222549.png"></p><p>当把<code>head</code>作为参数传递给递归函数<code>sortList</code>作用后，根据定义的递归函数功能，这个函数就完成了整个链表的排序，也就是期望的最终答案。</p><p><img src="/" alt="" / class="lazyload" data-src="https://cdn.jsdelivr.net/gh/jackymxp/image-bed/leetcode/20200322222859.png"></p></li><li><p><strong>寻找递归函数退出条件和返回值</strong></p><p>当链表长度为<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>1</mn></mrow><annotation encoding="application/x-tex">1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span>或者<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>0</mn></mrow><annotation encoding="application/x-tex">0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">0</span></span></span></span>时，就不用排序，直接返回就可以。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(!head || !head-&gt;next)</span><br><span class="line">    <span class="keyword">return</span> head;</span><br></pre></td></tr></table></figure></li><li><p><strong>缩小递归函数的规模，寻求层与层之间的关系</strong></p><p>在这里思考，如何缩小递归的规模，也就是让<code>sortList</code>中传入的链表长度减少，那就是将链表分为两个部分，分别对链表的每一个部分进行排序。具体怎么分有不同的策略，也可以仿照上题的策略，但是比较高效的方法是每部分链表长度分别为原来的<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>1</mn><mi mathvariant="normal">/</mi><mn>2</mn></mrow><annotation encoding="application/x-tex">1/2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mord">/</span><span class="mord">2</span></span></span></span>。也就是从中间断开链表。所以涉及到的问题是，如何寻找一个链表的中点？</p><p>这里使用快慢指针，快指针一次走两步，慢指针一次走一步，当快指针到尾部的时候，慢指针刚好走到链表的中点。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">ListNode* fast = head;</span><br><span class="line">ListNode* slow = head;</span><br><span class="line">ListNode* mid = <span class="literal">nullptr</span>;</span><br><span class="line"><span class="keyword">while</span>(fast &amp;&amp; fast-&gt;next)</span><br><span class="line">&#123;</span><br><span class="line">    fast = fast-&gt;next-&gt;next;</span><br><span class="line">    mid = slow;</span><br><span class="line">    slow = slow-&gt;next;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//为了使的链表成为两个独立的部分，将slow的next置空</span></span><br><span class="line">slow-&gt;next = <span class="literal">nullptr</span>;</span><br><span class="line"><span class="comment">//此时[head, slow] 是链表的前一个部分</span></span><br><span class="line"><span class="comment">//[mid, end)是链表的后一个部分。</span></span><br></pre></td></tr></table></figure><p>找到中点后，可以调用<code>p1 = sortList(head)</code> 和<code>p2 = sortList(mid)</code>分别对原链表的两部分进行了排序。</p><p><img src="/" alt="" / class="lazyload" data-src="https://cdn.jsdelivr.net/gh/jackymxp/image-bed/leetcode/20200322223155.png"></p><p>根据定义递归函数的功能，就是排序一个链表，所以当<code>p1 = sortList(head)</code> 和<code>p2 = sortList(mid)</code>执行之后，整个链表变成如下这个样子。</p><p><img src="/" alt="" / class="lazyload" data-src="https://cdn.jsdelivr.net/gh/jackymxp/image-bed/leetcode/20200322223416.png"></p><p>那么接下来的问题时，就是如何合并两个已经排序的链表呢？咦，这不是<a href="https://leetcode-cn.com/problems/merge-two-sorted-lists/" target="_blank" rel="noopener"> 合并两个有序链表</a>这个题嘛。所以直接调用<code>mergeTwoLists(node1, node2)</code>合并两个排序链表。</p><p>最后上一张图来表示一下这一个过程。其中绿色的阴影部分表示的是使用<code>sortList</code>函数，粉色的阴影表示的是<code>mergeTwoLists</code>作用范围。</p><p><img src="/" alt="" / class="lazyload" data-src="https://tva1.sinaimg.cn/large/00831rSTly1gcx9ggnj0dj31r70u07bp.jpg"></p></li><li><p><strong>完整代码</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line">    <span class="function">ListNode* <span class="title">merge</span><span class="params">(ListNode* p1, ListNode* p2)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!p1 || !p2)</span><br><span class="line">            <span class="keyword">return</span> p1 ? p1 : p2;</span><br><span class="line">        <span class="keyword">if</span>(p1-&gt;val &lt; p2-&gt;val)</span><br><span class="line">        &#123;</span><br><span class="line">            p1-&gt;next = merge(p1-&gt;next, p2);</span><br><span class="line">            <span class="keyword">return</span> p1;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> </span><br><span class="line">        &#123;</span><br><span class="line">            p2-&gt;next = merge(p1, p2-&gt;next);</span><br><span class="line">            <span class="keyword">return</span> p2;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">sortList</span><span class="params">(ListNode* head)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!head || !head-&gt;next)</span><br><span class="line">            <span class="keyword">return</span> head;</span><br><span class="line">        <span class="comment">//定位到mid</span></span><br><span class="line">        ListNode* fast = head;</span><br><span class="line">        ListNode* slow = head;</span><br><span class="line">        ListNode* mid = <span class="literal">nullptr</span>;</span><br><span class="line">        <span class="keyword">while</span>(fast &amp;&amp; fast-&gt;next)</span><br><span class="line">        &#123;</span><br><span class="line">            fast = fast-&gt;next-&gt;next;</span><br><span class="line">            mid = slow;</span><br><span class="line">            slow = slow-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        mid-&gt;next = <span class="literal">nullptr</span>;</span><br><span class="line">        <span class="comment">//分别对链表的两个部分进行排序。</span></span><br><span class="line">        ListNode* node1 = sortList(head);</span><br><span class="line">        ListNode* node2 = sortList(slow);</span><br><span class="line">        <span class="comment">//对两个已经排好序的链表进行合并。</span></span><br><span class="line">        <span class="keyword">return</span> merge(node1, node2);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ol><h2 id="2-两数相加"><a class="markdownIt-Anchor" href="#2-两数相加"></a> <a href="https://leetcode-cn.com/problems/add-two-numbers/" target="_blank" rel="noopener">2. 两数相加</a></h2><p>为什么我把这个题归结于合并链表题呢？其实上面三道题可以看作以链表的值的大小进行合并的一种方式，这个题不是根据大小进行合并，而是以“加法”操作对链表进行合并。那么我们看下在链表中如何按照&quot;加法&quot;这种操作对链表进行操作。</p><p>还是按照递归的三个步骤进行。</p><ol><li><p><strong>定义递归函数<code>ListNode* addTwoNumbers(ListNode* l1, ListNode* l2)</code>功能以及返回值</strong>：</p><p>定义递归函数功能：对链表<code>l1</code>和<code>l2</code>按照题目给定的规则进行合并，并返回合并后链表的头节点。</p><p>根据我们定义的递归的函数的功能，首先将<code>addTwoNumbers</code>作用范围放在整个链表，图中有绿色的阴影部分代表递归函数<code>addTwoNumbers</code>的作用范围，也就是将<code>p1</code>和<code>p2</code>作为参数传递给<code>addTwoNumbers(p1, p2)</code>作用的范围。</p><img src="/" style="zoom:50%;" / class="lazyload" data-src="https://cdn.jsdelivr.net/gh/jackymxp/image-bed/leetcode/20200322224858.png"><p>当把 <code>p1</code>和<code>p2</code> 作为参数传递给递归函数 <code>addTwoNumbers</code> 作用后，根据定义的递归函数功能，这个函数就完成了整个链表的相加，也就是期望的最终答案。</p><img src="/" style="zoom:50%;" / class="lazyload" data-src="https://cdn.jsdelivr.net/gh/jackymxp/image-bed/leetcode/20200322224942.png"></li><li><p><strong>寻找递归函数退出条件和返回值</strong></p><p>当有一个链表为空的时候，直接返回另外一个链表，不管另外一个链表是否为空。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(!l1 || !l2)</span><br><span class="line">    <span class="keyword">return</span> l1 ? l1 : l2;</span><br></pre></td></tr></table></figure></li><li><p><strong>缩小递归函数的规模，寻求层与层之间的关系</strong></p><p>如何缩小递归函数的规模呢，在这里只有一种选择，就是每次将<code>p1</code>和<code>p2</code>的指针后移一位，再次调用<code>node = addTwoNumbers(pm, pn)</code>完成剩余部分的加法合并。</p><img src="/" style="zoom:50%;" / class="lazyload" data-src="https://cdn.jsdelivr.net/gh/jackymxp/image-bed/leetcode/20200322225336.png"><p>当执行完<code>addTwoNumbers(pm, pn)</code>后，整个链表变成如下结构：</p><img src="/" style="zoom:50%;" / class="lazyload" data-src="https://tva1.sinaimg.cn/large/00831rSTly1gd33kz06wmj30pw0hi3z4.jpg"><p>为了将已经相加的链表和未相加的链表连接在一起，令<code>sum = p1-&gt;val + p2-&gt;val</code> 。</p><p>这里就需要对<code>sum</code>的值进行考虑，如果<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>s</mi><mi>u</mi><mi>m</mi><mo>&lt;</mo><mn>10</mn></mrow><annotation encoding="application/x-tex">sum &lt; 10</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.5782em;vertical-align:-0.0391em;"></span><span class="mord mathdefault">s</span><span class="mord mathdefault">u</span><span class="mord mathdefault">m</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">&lt;</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span><span class="mord">0</span></span></span></span>，如上图所示，直接重新分配一个值为<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>s</mi><mi>u</mi><mi>m</mi></mrow><annotation encoding="application/x-tex">sum</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">s</span><span class="mord mathdefault">u</span><span class="mord mathdefault">m</span></span></span></span>的节点<code>head</code>，并直接修改指针<code>head-&gt;next = node</code>即可。</p><img src="/" style="zoom:50%;" / class="lazyload" data-src="https://cdn.jsdelivr.net/gh/jackymxp/image-bed/leetcode/20200322230427.png"><p>当<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>s</mi><mi>u</mi><mi>m</mi><mo>&lt;</mo><mn>10</mn></mrow><annotation encoding="application/x-tex">sum &lt; 10</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.5782em;vertical-align:-0.0391em;"></span><span class="mord mathdefault">s</span><span class="mord mathdefault">u</span><span class="mord mathdefault">m</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">&lt;</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span><span class="mord">0</span></span></span></span>的逻辑代码如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(sum &lt; <span class="number">10</span>)</span><br><span class="line">&#123;</span><br><span class="line">    ListNode* node = addTwoNumbers(p1-&gt;next, p2-&gt;next);</span><br><span class="line">    ListNode* head = <span class="keyword">new</span> ListNode(sum);</span><br><span class="line">    head-&gt;next = node;</span><br><span class="line"><span class="keyword">return</span> node;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>但是当<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>s</mi><mi>u</mi><mi>m</mi><mo>&gt;</mo><mo>=</mo><mn>10</mn></mrow><annotation encoding="application/x-tex">sum &gt;= 10</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.5782em;vertical-align:-0.0391em;"></span><span class="mord mathdefault">s</span><span class="mord mathdefault">u</span><span class="mord mathdefault">m</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">&gt;</span></span><span class="base"><span class="strut" style="height:0.36687em;vertical-align:0em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span><span class="mord">0</span></span></span></span>是，要考虑到进位，这才是本题的难点。</p><p>如果<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>s</mi><mi>u</mi><mi>m</mi><mo>&gt;</mo><mo>=</mo><mn>10</mn></mrow><annotation encoding="application/x-tex">sum &gt;= 10</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.5782em;vertical-align:-0.0391em;"></span><span class="mord mathdefault">s</span><span class="mord mathdefault">u</span><span class="mord mathdefault">m</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">&gt;</span></span><span class="base"><span class="strut" style="height:0.36687em;vertical-align:0em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span><span class="mord">0</span></span></span></span>时，新分配一个值为<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>s</mi><mi>u</mi><mi>m</mi><mtext>  </mtext><mi>m</mi><mi>o</mi><mi>d</mi><mtext>  </mtext><mn>10</mn></mrow><annotation encoding="application/x-tex">sum \; mod \; 10</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault">s</span><span class="mord mathdefault">u</span><span class="mord mathdefault">m</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mord mathdefault">m</span><span class="mord mathdefault">o</span><span class="mord mathdefault">d</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mord">1</span><span class="mord">0</span></span></span></span>的节点<code>head</code>是不够的， 还需要分配一个值为<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>1</mn></mrow><annotation encoding="application/x-tex">1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span>的节点<code>flag</code>，在这里我们要如何处理这个进位操作呢？</p><p>其实很简单，只需要让<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>1</mn></mrow><annotation encoding="application/x-tex">1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span>与已经相加的<code>node</code>链表再做一次相加操作，即只需要让调用<code>addTwoNumbers(node, flag)</code>操作即可。</p><img src="/" style="zoom:50%;" / class="lazyload" data-src="https://cdn.jsdelivr.net/gh/jackymxp/image-bed/leetcode/20200322231503.png"><img src="/" style="zoom:50%;" / class="lazyload" data-src="https://tva1.sinaimg.cn/large/00831rSTly1gd3473mmy6j30o00eqdgl.jpg"><p>为了看的更加清楚，我将其画在了一起，其中绿色的部分代表递归已经完成了，其实应该等价于一个链表<code>next</code>，在这里为了看清楚，没有将其化为一个链表。</p><p><img src="/" alt="" / class="lazyload" data-src="https://tva1.sinaimg.cn/large/00831rSTly1gcxb7z847xj31rw0skq54.jpg"></p><p>这样当<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>s</mi><mi>u</mi><mi>m</mi><mo>&gt;</mo><mo>=</mo><mn>10</mn></mrow><annotation encoding="application/x-tex">sum &gt;= 10</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.5782em;vertical-align:-0.0391em;"></span><span class="mord mathdefault">s</span><span class="mord mathdefault">u</span><span class="mord mathdefault">m</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">&gt;</span></span><span class="base"><span class="strut" style="height:0.36687em;vertical-align:0em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span><span class="mord">0</span></span></span></span>大于<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>10</mn></mrow><annotation encoding="application/x-tex">10</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span><span class="mord">0</span></span></span></span>时的逻辑如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(sum &gt;= <span class="number">10</span>)</span><br><span class="line">&#123;</span><br><span class="line">    ListNode* node = addTwoNumbers(p1-&gt;next, p2-&gt;next);</span><br><span class="line">    ListNode* head = <span class="keyword">new</span> ListNode(sum % <span class="number">10</span>);</span><br><span class="line">    head-&gt;next = addTwoNumbers(node, <span class="keyword">new</span> ListNode(<span class="number">1</span>));</span><br><span class="line">    <span class="keyword">return</span> head;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><strong>完整代码</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">addTwoNumbers</span><span class="params">(ListNode* l1, ListNode* l2)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//递归退出条件，当有一个为空或者两个都为空</span></span><br><span class="line">        <span class="keyword">if</span>(!l1 || !l2)</span><br><span class="line">            <span class="keyword">return</span> l1 ? l1 : l2;</span><br><span class="line">        <span class="comment">//这里l1和l2都不为空，所以可以直接访问l1-&gt;val 和 l2-&gt;val</span></span><br><span class="line">        <span class="keyword">int</span> sum = l1-&gt;val + l2-&gt;val;</span><br><span class="line">        ListNode* newNode = <span class="keyword">new</span> ListNode(sum % <span class="number">10</span>);</span><br><span class="line">        <span class="comment">//保存l1-&gt;next和l2-&gt;next的addTwoNumbers结果</span></span><br><span class="line">        ListNode* nextNode = addTwoNumbers(l1-&gt;next, l2-&gt;next);</span><br><span class="line">        <span class="comment">//当sum小于10的时候，不会产生进位，所以直接赋值给next就可以</span></span><br><span class="line">        <span class="keyword">if</span>(sum &lt; <span class="number">10</span>)</span><br><span class="line">            newNode-&gt;next = nextNode;</span><br><span class="line">        <span class="keyword">else</span><span class="comment">//sum &gt;= 10,则需要将产生的结果和1做加法的结果赋值给next</span></span><br><span class="line">            newNode-&gt;next = addTwoNumbers(nextNode, <span class="keyword">new</span> ListNode(<span class="number">1</span>));</span><br><span class="line">        <span class="keyword">return</span> newNode;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><hr /></li></ol><h1 id="在链表中移除元素"><a class="markdownIt-Anchor" href="#在链表中移除元素"></a> 在链表中移除元素</h1><p>上面的一些题，都是通过递归修改链表内部的指针，从而得到期望的链表结构。其实这些题目用普通方法都是可以解答的，但是使用普通的方法很容易出错，修改修改指针就乱了，或者产生内存泄漏。</p><p>但是如果理解递归的基本思路，就可以编写出更简单的代码，也更容易理解。下面就继续通过递归的方式，去完成几个在链表中删除元素的题。继续理解上面说的递归的三个步骤。</p><h2 id="203-移除链表元素"><a class="markdownIt-Anchor" href="#203-移除链表元素"></a> <a href="https://leetcode-cn.com/problems/remove-linked-list-elements/" target="_blank" rel="noopener">203. 移除链表元素</a></h2><ol><li><p><strong>定义递归函数<code>ListNode* removeElements(ListNode* head, int val)</code>功能以及返回值</strong>：</p><p>定义递归函数功能：删除链表中值等于<code>val</code>的节点，并返回新的头节点。</p><p>根据定义的递归函数功能，首先将<code>removeElements</code>的作用范围放在整个链表，图中有绿色的阴影部分代表递归函数<code>reverseKGroup</code>的作用范围，也就是将<code>head</code>作为参数传递给<code>reverseKGroup(head, val)</code>作用的范围。</p><p><img src="/" alt="" / class="lazyload" data-src="https://tva1.sinaimg.cn/large/00831rSTly1gcw39mcqbnj31k606kgm1.jpg"></p><p>在这里设定<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>k</mi><mo>=</mo><mn>6</mn></mrow><annotation encoding="application/x-tex">k = 6</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">6</span></span></span></span>，当把<code>head</code>作为参数传递给递归函数作<code>removeElements</code>用后，根据定义的递归函数功能，这个函数就完成删除链表中所有值为<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>6</mn></mrow><annotation encoding="application/x-tex">6</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">6</span></span></span></span>的节点，并返回删除值为<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>6</mn></mrow><annotation encoding="application/x-tex">6</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">6</span></span></span></span>的链表后的链表头节点。</p><img src="/" style="zoom: 50%;" / class="lazyload" data-src="https://tva1.sinaimg.cn/large/00831rSTly1gcw3ecip1mj314k052wer.jpg"></li><li><p><strong>寻找递归函数退出条件和返回值</strong></p><p>当链表中不存在节点的时候，不需要删除任何节点，就直接返回。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(!head)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br></pre></td></tr></table></figure></li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line">    </span><br><span class="line">3.  **缩小递归函数的规模，寻求层与层之间的关系**</span><br><span class="line"></span><br><span class="line">    为了缩减递归函数的规模，所以要将链表拆分为两个部分，由于要判断链表中的每个值是否等于&#96;val&#96;，所以要将链表分成长度分别为$1$和长度为$k-1$的两个链表，其中$k$是原链表的长度。假设两部分链表的头节点分别是&#96;head&#96;和&#96;newHead&#96;。当函数缩减规模的时候，即将&#96;newHead&#96;作为参数传递给&#96;removeElements&#96;，其中用图表示如下：</span><br><span class="line"></span><br><span class="line">    ![](https:&#x2F;&#x2F;cdn.jsdelivr.net&#x2F;gh&#x2F;jackymxp&#x2F;image-bed&#x2F;leetcode&#x2F;20200323063910.png)</span><br><span class="line"></span><br><span class="line">    当&#96;removeElements(newHead, val)&#96;执行完后，根据我们定义的递归的功能，即删除了上图绿色阴影中值为&#96;val&#96;的节点，整个链表变成如下图。</span><br><span class="line"></span><br><span class="line">    ![](https:&#x2F;&#x2F;cdn.jsdelivr.net&#x2F;gh&#x2F;jackymxp&#x2F;image-bed&#x2F;leetcode&#x2F;20200323064820.png)</span><br><span class="line"></span><br><span class="line">    这时要判断当前节点&#96;head-&gt;val&#96;的值是否等于&#96;val&#96;，在这里就要分情况讨论了：</span><br><span class="line"></span><br><span class="line">    -   如果&#96;head-&gt;val !&#x3D; val&#96;，表示的是不需要删除当前节点。为了将&#96;head&#96;与&#96;retNode&#96;串联起来，直接&#96;head-&gt;next &#x3D; retNode&#96;即可。并且返回&#96;head&#96;。具体逻辑如上图所示。</span><br><span class="line"></span><br><span class="line">    -   如果&#96;head-&gt;val &#x3D;&#x3D; val&#96;，表示的是需要删除当前节点，并且直接返回&#96;retNode&#96;。</span><br><span class="line"></span><br><span class="line">        用图形表示，当&#96;head-&gt;val &#x3D;&#x3D; 6&#96;时，递归的情况如下：</span><br><span class="line"></span><br><span class="line">        ![](https:&#x2F;&#x2F;cdn.jsdelivr.net&#x2F;gh&#x2F;jackymxp&#x2F;image-bed&#x2F;leetcode&#x2F;20200323120659.png)</span><br><span class="line"></span><br><span class="line">        当执行完&#96;removeElements(newHead, val)&#96;后，根据定义的递归功能，应该删除&#96;newHead&#96;后所有值为$6$的节点，当执行完&#96;removeElements(newHead, val)&#96;后，整体的链表结构如下。</span><br><span class="line"></span><br><span class="line">        ![](https:&#x2F;&#x2F;cdn.jsdelivr.net&#x2F;gh&#x2F;jackymxp&#x2F;image-bed&#x2F;leetcode&#x2F;20200323120443.png)</span><br><span class="line"></span><br><span class="line">        为了删除值为$6$的节点，所以使用&#96;delete head&#96;即可，并且直接返回&#96;retNode&#96;即可。</span><br><span class="line"></span><br><span class="line">    整体的代码逻辑如下：</span><br><span class="line"></span><br><span class="line">    &#96;&#96;&#96; cpp</span><br><span class="line">    ListNode* newHead &#x3D; head-&gt;next;</span><br><span class="line">    &#x2F;&#x2F;将链表分割成两个部分</span><br><span class="line">    head-&gt;next &#x3D; nullptr;</span><br><span class="line">    ListNode* retNode &#x3D; removeElements(newHead, val);</span><br><span class="line">    if(head-&gt;val &#x3D;&#x3D; val)</span><br><span class="line">    &#123;</span><br><span class="line">        delete head;</span><br><span class="line">        return retNode;</span><br><span class="line">    &#125;</span><br><span class="line">    else</span><br><span class="line">    &#123;</span><br><span class="line">        head-&gt;next &#x3D; retNode;</span><br><span class="line">        return head;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><ol start="4"><li><p><strong>完整代码</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">removeElements</span><span class="params">(ListNode* head, <span class="keyword">int</span> val)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!head)</span><br><span class="line">            <span class="keyword">return</span> head;</span><br><span class="line">        ListNode* newHead = head-&gt;next;</span><br><span class="line">        <span class="comment">//断开为两个链表</span></span><br><span class="line">        head-&gt;next = <span class="literal">nullptr</span>;</span><br><span class="line">        <span class="comment">//newHead 链表部分已经删除值为val的节点</span></span><br><span class="line">        ListNode* retNode = removeElements(newHead, val);</span><br><span class="line">        <span class="keyword">if</span>(head-&gt;val == val)&#123;</span><br><span class="line">            <span class="keyword">delete</span> head;</span><br><span class="line">            <span class="keyword">return</span> retNode;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            head-&gt;next = retNode;</span><br><span class="line">            <span class="keyword">return</span> head;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ol><h2 id="83-删除排序链表中的重复元素"><a class="markdownIt-Anchor" href="#83-删除排序链表中的重复元素"></a> <a href="https://leetcode-cn.com/problems/remove-duplicates-from-sorted-list/" target="_blank" rel="noopener">83. 删除排序链表中的重复元素</a></h2><blockquote><p>给定一个排序链表，删除所有重复的元素，使得每个元素只出现一次。</p><p>示例 1:</p><p>输入: 1-&gt;1-&gt;2<br />输出: 1-&gt;2<br />示例 2:</p><p>输入: 1-&gt;1-&gt;2-&gt;3-&gt;3<br />输出: 1-&gt;2-&gt;3</p></blockquote><ol><li><p><strong>定义递归函数<code>ListNode* deleteDuplicates(ListNode* head)</code>功能以及返回值</strong></p><p>首先定义递归函数的功能是删除链表中值重复的元素，使重复的元素只出现一次。根据定义的递归函数功能，首先将<code>deleteDuplicates</code>的作用范围放在整个链表，图中有绿色的阴影部分代表递归函数<code>deleteDuplicates</code>的作用范围，也就是将<code>head</code>作为参数传递给<code>deleteDuplicates(head)</code>作用的范围。</p><p><img src="/" alt="" / class="lazyload" data-src="/Users/mengxiangpeng/Documents/blog/HexoBlog-Butterfly-BackUp/source/_posts/fucking-leetcode/01-%E9%93%BE%E8%A1%A8%E9%80%92%E5%BD%92%E4%B8%93%E9%A2%98.assets/00831rSTly1gd3r6br4tlj311u05maa9.jpg"></p><p>当把<code>head</code>作为参数传递给递归函数<code>deleteDuplicates</code>作用后，根据定义的递归函数功能，这个函数就完成了整个链表的翻转，也就是期望的最终答案。</p><img src="/" style="zoom:50%;" / class="lazyload" data-src="https://cdn.jsdelivr.net/gh/jackymxp/image-bed/leetcode/20200323122819.png"></li><li><p><strong>寻找递归函数退出条件和返回值</strong></p><p>当链表中不存在节点或者只有一个节点的时候，直接退出，因为一个节点不存在重复的节点。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(!head || !head-&gt;next)</span><br><span class="line">    <span class="keyword">return</span> head;</span><br></pre></td></tr></table></figure></li><li><p><strong>缩小递归函数的规模，寻求层与层之间的关系</strong></p><p>为了缩减递归函数的规模，所以要将链表拆分为两个部分，具体怎么拆分呢？这直接影响递归函数的编写。在这里我们将所有重复的节点看成是一部分，剩下的所有节点是另外一部分。具体解释一下。</p><p>这里将重复的节点看成是一组，重复节点的个数可能是<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>1</mn></mrow><annotation encoding="application/x-tex">1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span>或者更多。这里将原链表按照如下的方式进行划分为两个链表。也就是找到第一个和<code>head-&gt;val</code>值不同的节点，作为<code>newHead</code>。当缩小递归函数的范围的时候，即将<code>newHead</code>作为参数传入到<code>deleteDuplicates</code>函数中，其中递归函数的作用范围表示成图。</p><p><img src="/" alt="" / class="lazyload" data-src="https://cdn.jsdelivr.net/gh/jackymxp/image-bed/leetcode/20200323130416.png"></p><p>当递归函数<code>ListNode* retNode = deleteDuplicates(newHead)</code>执行完成后，根据递归函数的功能，这样就完成图中绿色阴影部分删除重复的节点。这样除前面重复的节点没有删除，后其余部分都符合题目要求，整个链表变成如下这个样子。</p><img src="/" style="zoom:50%;" / class="lazyload" data-src="https://tva1.sinaimg.cn/large/00831rSTly1gd3znjd91ej30uc07yjrv.jpg"><p>这时只要将重复的节点删除，<strong>只保留一个重复的节点</strong>。为了和已经完成的部分<code>retNode</code>连接起来，所以删除后的节点的<code>next</code>指针指向<code>retNode</code>。</p><p>将上述过程翻译成代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">ListNode* newHead = head-&gt;next;</span><br><span class="line"><span class="keyword">while</span>(newHead &amp;&amp; newHead-&gt;val == head-&gt;val)</span><br><span class="line">&#123;</span><br><span class="line">    ListNode* next = newHead-&gt;next;</span><br><span class="line">    <span class="keyword">delete</span> newHead;</span><br><span class="line">    newHead = next;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//将链表分为两个部分。·</span></span><br><span class="line">head-&gt;next = <span class="literal">nullptr</span>;</span><br><span class="line">ListNode* retNode = deleteDuplicates(newHead);</span><br><span class="line"></span><br><span class="line">head-&gt;next = retNode;</span><br></pre></td></tr></table></figure></li><li><p><strong>递归代码</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">deleteDuplicates</span><span class="params">(ListNode* head)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//递归退出条件</span></span><br><span class="line">        <span class="keyword">if</span>(!head || !head-&gt;next)</span><br><span class="line">            <span class="keyword">return</span> head;</span><br><span class="line"></span><br><span class="line">        ListNode* newHead = head-&gt;next;</span><br><span class="line">        <span class="keyword">while</span>(newHead &amp;&amp; newHead-&gt;val == head-&gt;val)</span><br><span class="line">        &#123;</span><br><span class="line">            ListNode* next = newHead-&gt;next;</span><br><span class="line">            <span class="keyword">delete</span> newHead;</span><br><span class="line">            newHead = next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//将链表分为两个部分。</span></span><br><span class="line">        head-&gt;next = <span class="literal">nullptr</span>;</span><br><span class="line">        <span class="comment">//对 newHead部分按照递归函数定义的功能删除重复节点，且只保留一个</span></span><br><span class="line">        ListNode* retNode = deleteDuplicates(newHead);</span><br><span class="line">        <span class="comment">//链接链表的两个部分</span></span><br><span class="line">        head-&gt;next = retNode;</span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ol><h2 id="82-删除排序链表中的重复元素-ii"><a class="markdownIt-Anchor" href="#82-删除排序链表中的重复元素-ii"></a> <a href="https://leetcode-cn.com/problems/remove-duplicates-from-sorted-list-ii/" target="_blank" rel="noopener">82. 删除排序链表中的重复元素 II</a></h2><blockquote><p>给定一个排序链表，删除所有含有重复数字的节点，只保留原始链表中 没有重复出现 的数字。</p><p>示例 1:</p><p>输入: 1-&gt;2-&gt;3-&gt;3-&gt;4-&gt;4-&gt;5<br />输出: 1-&gt;2-&gt;5<br />示例 2:</p><p>输入: 1-&gt;1-&gt;1-&gt;2-&gt;3<br />输出: 2-&gt;3</p></blockquote><ol><li><p><strong>定义递归函数<code>ListNode* deleteDuplicates(ListNode* head)</code>功能以及返回值</strong></p><p>首先定义递归函数的功能是删除链表中值重复的所有元素，也就是不保留任何值重复的元素。根据定义的递归函数功能，首先将<code>deleteDuplicates</code>的作用范围放在整个链表，图中有绿色的阴影部分代表递归函数<code>deleteDuplicates</code>的作用范围，也就是将<code>head</code>作为参数传递给<code>deleteDuplicates(head)</code>作用的范围。</p><p><img src="/" alt="" / class="lazyload" data-src="https://cdn.jsdelivr.net/gh/jackymxp/image-bed/leetcode/20200323184315.png"></p><p>当把<code>head</code>作为参数传递给递归函数<code>deleteDuplicates</code>作用后，根据定义的递归函数功能，这个函数就完成了整个链表的翻转，也就是期望的最终答案。</p><img src="/" style="zoom:50%;" / class="lazyload" data-src="https://cdn.jsdelivr.net/gh/jackymxp/image-bed/leetcode/20200323184654.png"></li><li><p><strong>寻找递归函数退出条件和返回值</strong></p><p>当链表中不存在节点或者只有一个节点的时候，直接退出，因为一个节点不存在重复的节点。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(!head || !head-&gt;next)</span><br><span class="line">    <span class="keyword">return</span> head;</span><br></pre></td></tr></table></figure></li><li><p><strong>缩小递归函数的规模，寻求层与层之间的关系</strong></p><p>在这里还是要思考如何减少递归函数的作用范围呢，仿照上面题的策略，将链表中的节点的值分成两组讨论，一组是只出现一次的节点的值；另外一组是链表中值重复的一组。</p><ul><li><p>如果值没有重复，则不用删除，链表的剩下部分头节点为<code>newHead</code>，删除从<code>newHead</code>开始链表的重复节点仍然是一个删除链表中重复节点的过程，依然可以直接使用<code>deleteDuplicates(newHead)</code>完成剩余的部分，使用图表示如下图所示。</p><p><img src="/" alt="" / class="lazyload" data-src="https://cdn.jsdelivr.net/gh/jackymxp/image-bed/leetcode/20200323190109.png"></p><p>当执行完<code>deleteDuplicates(newHead)</code>后，整个链表变成如下结构，再将两个部分连接起来。</p><img src="/" style="zoom:50%;" / class="lazyload" data-src="https://cdn.jsdelivr.net/gh/jackymxp/image-bed/leetcode/20200323191339.png"><p>当不存在重复节点时的代码逻辑如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(head-&gt;val != head-&gt;next-&gt;val)&#123;<span class="comment">//链表中至少存在两个节点，所以可以直接访问head-&gt;next并不为空</span></span><br><span class="line">    head-&gt;next = deleteDuplicates(head-&gt;next);</span><br><span class="line">    <span class="keyword">return</span> head;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>如果出现重复的节点就需要将<code>newHead</code>定位到下一个大于待删除的节点，再将所有值相同的节点全部释放掉。链表<code>newHead</code>部分仍然可以看作是删除值重复节点的过程，可以调用<code>deleteDuplicates(newHead)</code>完成剩下部分的操作。</p><p><img src="/" alt="" / class="lazyload" data-src="https://cdn.jsdelivr.net/gh/jackymxp/image-bed/leetcode/20200323195350.png"></p><p>存在重复节点时的代码逻辑如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(head-&gt;val == head-&gt;next-&gt;val)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//定位到newHead节点</span></span><br><span class="line">    ListNode* newHead = head;</span><br><span class="line">    <span class="keyword">int</span> val = head-&gt;val;</span><br><span class="line">   <span class="keyword">while</span>(newHead &amp;&amp; newHead-&gt;val == val)</span><br><span class="line">    &#123;</span><br><span class="line">        ListNode* next = newHead-&gt;next;</span><br><span class="line">        <span class="keyword">delete</span> newHead;</span><br><span class="line">        newHead = next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//将 newHead 后的链表删除重复节点，并将删除后的头节点返回</span></span><br><span class="line">    <span class="keyword">return</span> deleteDuplicates(newHead);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li><li><p><strong>递归代码</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">deleteDuplicates</span><span class="params">(ListNode* head)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//递归退出条件，当链表长度小于2的时候</span></span><br><span class="line">        <span class="keyword">if</span>(!head || !head-&gt;next)</span><br><span class="line">            <span class="keyword">return</span> head;</span><br><span class="line">        <span class="keyword">if</span>(head-&gt;val != head-&gt;next-&gt;val)&#123;</span><br><span class="line">            head-&gt;next = deleteDuplicates(head-&gt;next);</span><br><span class="line">            <span class="keyword">return</span> head;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            ListNode* newHead = head;</span><br><span class="line">            <span class="keyword">int</span> val = head-&gt;val;</span><br><span class="line">            <span class="keyword">while</span>(newHead &amp;&amp; newHead-&gt;val == val)</span><br><span class="line">            &#123;</span><br><span class="line">                ListNode* next = newHead-&gt;next;</span><br><span class="line">                <span class="keyword">delete</span> newHead;</span><br><span class="line">                newHead = next;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> deleteDuplicates(newHead);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ol><h2 id="19-删除链表的倒数第n个节点"><a class="markdownIt-Anchor" href="#19-删除链表的倒数第n个节点"></a> <a href="https://leetcode-cn.com/problems/remove-nth-node-from-end-of-list/" target="_blank" rel="noopener">19. 删除链表的倒数第N个节点</a></h2><blockquote><p>给定一个链表，删除链表的倒数第 n 个节点，并且返回链表的头结点。</p><p>示例：</p><p>给定一个链表: 1-&gt;2-&gt;3-&gt;4-&gt;5, 和 n = 2.</p><p>当删除了倒数第二个节点后，链表变为 1-&gt;2-&gt;3-&gt;5.</p></blockquote><p>对于这道题，拿到手里来，是不是没有任何思路。但是只要记得上面的套路，这道题依然可以用递归解决。问题的难点是如何使用递归定位到倒数第<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">n</span></span></span></span>个节点。以倒数第<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">n</span></span></span></span>个节点作为分隔节点，将链表分成两个部分。接下来还是三步走。</p><ol><li><p><strong>定义递归函数<code>ListNode* removeNthFromEnd(ListNode* head, int n)</code>功能以及返回值</strong></p><p>根据定义的递归函数功能，首先将<code>removeNthFromEnd</code>的作用范围放在整个链表，图中有绿色的阴影部分代表递归函数<code>reverseList</code>的作用范围，也就是将<code>head</code>作为参数传递给<code>removeNthFromEnd(head, n)</code>作用的范围。</p><p><img src="/" alt="" / class="lazyload" data-src="https://tva1.sinaimg.cn/large/00831rSTly1gd2x4tff4nj318e0620u7.jpg"></p><p>当把<code>head</code>作为参数传递给递归函数<code>removeNthFromEnd</code>作用后，根据定义的递归函数功能，这个函数就完成了删除倒数第n个节点，也就是期望的最终答案。</p><img src="/" style="zoom:50%;" / class="lazyload" data-src="https://cdn.jsdelivr.net/gh/jackymxp/image-bed/leetcode/20200323210439.png"></li><li><p><strong>寻找递归函数退出条件和返回值</strong></p><p>当链表中没有节点的时候，不能进行删除操作，就可以直接返回。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(!head)</span><br><span class="line">    <span class="keyword">return</span> head;</span><br></pre></td></tr></table></figure></li><li><p><strong>缩小递归函数的规模，寻求层与层之间的关系</strong></p><p>这里我们似乎找不到任何递归函数如何缩减规模的策略，因为这个题，很难通过递归找到倒数第<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">n</span></span></span></span>个节点。在这里我选择通过介绍递归的原理，来讲解这个题。</p><p>我们定义整个链表的尾节点为第<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>0</mn></mrow><annotation encoding="application/x-tex">0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">0</span></span></span></span>个节点，倒数第一个为<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>1</mn></mrow><annotation encoding="application/x-tex">1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span>个节点，那么问题来了，我们如何通过递归定位到最后一个节点呢？</p><p>因为最后一个节点有特殊标记<code>nullptr</code>，所以通过递归遍历整个链表，直到定位到<code>nullptr</code>节点，标记此时的标志为<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>t</mi><mi>h</mi><mtext>  </mtext><mo>=</mo><mtext>  </mtext><mn>0</mn></mrow><annotation encoding="application/x-tex">th \;= \;0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault">t</span><span class="mord mathdefault">h</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">0</span></span></span></span>。那么在递归到<code>nullptr</code>的过程中，这个过程叫做递。</p><p>当在归的时候，每次归的时候将<code>th++</code>，这样当<code>th == n</code>时候，就可以删除该节点了。</p><p>无图无真相：</p><p><img src="/" alt="" / class="lazyload" data-src="https://cdn.jsdelivr.net/gh/jackymxp/image-bed/leetcode/20200323213633.png"></p></li><li><p><strong>完成代码</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> th;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">removeNthFromEnd</span><span class="params">(ListNode* head, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(head == <span class="literal">nullptr</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            th = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//递的过程</span></span><br><span class="line">        head-&gt;next = removeNthFromEnd(head-&gt;next, n);</span><br><span class="line">        <span class="comment">//每次归的过程，都将标识位做一次加加操作</span></span><br><span class="line">        th++;</span><br><span class="line">        <span class="keyword">if</span>(th == n)</span><br><span class="line">        &#123;</span><br><span class="line">            ListNode* next = head-&gt;next;</span><br><span class="line">            <span class="keyword">delete</span> head;</span><br><span class="line">            <span class="keyword">return</span> next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ol><h1 id="总结"><a class="markdownIt-Anchor" href="#总结"></a> 总结</h1><p>这一篇博客中，都是使用递归解决和链表相关的问题。我们可以总结出使用递归解决链表相关问题的套路。</p><ol><li>首先定义递归函数<code>fun(ListNode* head, ...)</code>的具体功能。</li><li>根据具体的语境，找到递归函数的出口。</li><li>将一个链表分成两个部分，假设链表两部分的头节点分别是<code>head</code>和<code>newHead</code>，其中在<code>newHead</code>部分的链表操作和整个链表的结构是相同的，只是规模更小。也就是说当执行完<code>fun(newHead, …)</code>后，根据我们定义的递归函数的功能，链表变成了什么样子。</li><li>将<code>fun(newHead, …)</code>执行后的链表的返回值与<code>head</code>部分联系起来，找到如何变换<code>head</code>部分，才能让其达到我们期望的结构。这不基本是递归函数的难点。</li></ol><p>在上面解题的过程中，为了将递归函数的功能表示的明确些。刻意将链表分成两个部分，其实有很多题是不需要明确的分成两个部分，而直接改变指针的指向会简化很多代码，但是递归的逻辑就会稍微模糊一点。</p><p>在<a href="https://leetcode-cn.com/problems/remove-nth-node-from-end-of-list/" target="_blank" rel="noopener">删除链表的倒数第N个节点</a>题中，讨论了递归函数的原理，什么时候递，什么时候归，通过上面一些题的例子，我们应该知道那里是递的过程，哪里是归的过程，理解了递和归的过程，对于理解递归的原理还是会有很多帮助的。</p>]]></content>
      
      
      <categories>
          
          <category> leetcode </category>
          
          <category> 编程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 链表 </tag>
            
            <tag> 递归 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>如何计算最大公约数</title>
      <link href="/2020/03/13/%E6%9C%80%E5%A4%A7%E5%85%AC%E7%BA%A6%E6%95%B0/"/>
      <url>/2020/03/13/%E6%9C%80%E5%A4%A7%E5%85%AC%E7%BA%A6%E6%95%B0/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><h1 id="如何求最大公约数"><a class="markdownIt-Anchor" href="#如何求最大公约数"></a> 如何求最大公约数</h1><p>最大公约数指能够<strong>整除多个整数</strong>的最大正整数。而多个整数不能都为零。</p><p>本文将从暴力法开始一步步地求解最大公约数，从理论推导到计算机代码实现的的一个递进过程。</p><h2 id="暴力法"><a class="markdownIt-Anchor" href="#暴力法"></a> 暴力法</h2><p>没有什么是暴力法解决不了的，如果有，那就是我们不能把有限的时间内投入到无限的找bug中。</p><img src="/" style="zoom:50%;" / class="lazyload" data-src="https://tva1.sinaimg.cn/large/00831rSTly1gcud1ue072j30im0j21bc.jpg"><h3 id="暴力法的原理"><a class="markdownIt-Anchor" href="#暴力法的原理"></a> 暴力法的原理</h3><p>暴力法的原理很简答，就是从2开始，枚举每一个数字，直到最小的数字。</p><h3 id="暴力法的代码实现"><a class="markdownIt-Anchor" href="#暴力法的代码实现"></a> 暴力法的代码实现</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">gcd</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> smaller = a &lt; b ? a : b;</span><br><span class="line">    <span class="keyword">int</span> bigger = a &gt; b ? a : b;</span><br><span class="line">    <span class="keyword">int</span> res = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= smaller; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>((bigger % i == <span class="number">0</span>) &amp;&amp; (smaller % i == <span class="number">0</span>))</span><br><span class="line">            res = i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="辗转相除法"><a class="markdownIt-Anchor" href="#辗转相除法"></a> 辗转相除法</h2><h3 id="辗转相除法的历史"><a class="markdownIt-Anchor" href="#辗转相除法的历史"></a> 辗转相除法的历史</h3><p>辗转相除法， 又名欧几里得算法（Euclidean algorithm），其历史可以追溯到公元前300多年。</p><blockquote><p>“欧几里得算法是所有算法的鼻祖，因为它是现存最古老的非凡算法。”- 高德纳</p></blockquote><img src="/" alt="image-20200313213018498" style="zoom:50%;" / class="lazyload" data-src="https://tva1.sinaimg.cn/large/00831rSTly1gcsmhlv6cqj30n40n6b29.jpg"><h3 id="辗转相除法原理"><a class="markdownIt-Anchor" href="#辗转相除法原理"></a> 辗转相除法原理</h3><p><strong>两个正整数<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>a</mi></mrow><annotation encoding="application/x-tex">a</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">a</span></span></span></span>和<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>b</mi></mrow><annotation encoding="application/x-tex">b</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault">b</span></span></span></span>，<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo stretchy="false">(</mo><mi>a</mi><mo>&gt;</mo><mi>b</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">(a &gt; b)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathdefault">a</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">&gt;</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">b</span><span class="mclose">)</span></span></span></span>，它们的最大公约数等于<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>a</mi></mrow><annotation encoding="application/x-tex">a</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">a</span></span></span></span>除以<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>b</mi></mrow><annotation encoding="application/x-tex">b</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault">b</span></span></span></span>的余数<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>c</mi></mrow><annotation encoding="application/x-tex">c</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">c</span></span></span></span>和<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>b</mi></mrow><annotation encoding="application/x-tex">b</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault">b</span></span></span></span>之间的最大公约数。</strong></p><p><strong>翻译成人话，举个例子</strong></p><p>利用辗转相除法计算 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>a</mi><mo>=</mo><mn>25</mn></mrow><annotation encoding="application/x-tex">a = 25</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">a</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">2</span><span class="mord">5</span></span></span></span>和<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>b</mi><mo>=</mo><mn>10</mn></mrow><annotation encoding="application/x-tex">b = 10</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault">b</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span><span class="mord">0</span></span></span></span>的最大公约数的过程如下：</p><blockquote><ol><li>从<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>25</mn></mrow><annotation encoding="application/x-tex">25</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">2</span><span class="mord">5</span></span></span></span>中不断减去<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>10</mn></mrow><annotation encoding="application/x-tex">10</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span><span class="mord">0</span></span></span></span>，直到小于10，(可以减去2次，商为2)，余数为5</li><li>从10中不断的5，直到结果小于5，(可以减去2次，商为2)，余数为0</li><li>当余数为0的时候，算法终止，否则继续回到1.2。</li></ol></blockquote><table><thead><tr><th style="text-align:center">步骤数</th><th style="text-align:center">算式</th><th style="text-align:center">商和余数</th></tr></thead><tbody><tr><td style="text-align:center">0</td><td style="text-align:center">25 = 10 <em>q</em>0 + <em>r</em>0</td><td style="text-align:center"><em>q</em>0 = 2、<em>r</em>0 = 5</td></tr><tr><td style="text-align:center">1</td><td style="text-align:center">10 = 5 <em>q</em>1 + <em>r</em>1</td><td style="text-align:center"><em>q</em>1 = 2、<em>r</em>1 = 0 （算法终止）</td></tr></tbody></table><p>写成连续的等式形式如下：</p><p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>g</mi><mi>c</mi><mi>d</mi><mo stretchy="false">(</mo><mn>25</mn><mo separator="true">,</mo><mn>10</mn><mo stretchy="false">)</mo><mo>=</mo><mi>g</mi><mi>c</mi><mi>d</mi><mo stretchy="false">(</mo><mn>10</mn><mo separator="true">,</mo><mn>5</mn><mo stretchy="false">)</mo><mo>=</mo><mi>g</mi><mi>c</mi><mi>d</mi><mo stretchy="false">(</mo><mn>5</mn><mo separator="true">,</mo><mn>0</mn><mo stretchy="false">)</mo><mo>=</mo><mn>5</mn></mrow><annotation encoding="application/x-tex">gcd(25, 10) = gcd(10, 5) = gcd(5, 0) = 5</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.03588em;">g</span><span class="mord mathdefault">c</span><span class="mord mathdefault">d</span><span class="mopen">(</span><span class="mord">2</span><span class="mord">5</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">1</span><span class="mord">0</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.03588em;">g</span><span class="mord mathdefault">c</span><span class="mord mathdefault">d</span><span class="mopen">(</span><span class="mord">1</span><span class="mord">0</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">5</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.03588em;">g</span><span class="mord mathdefault">c</span><span class="mord mathdefault">d</span><span class="mopen">(</span><span class="mord">5</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">0</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">5</span></span></span></span></span></p><p>将例子升华一下，形成通用的方程：</p><p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>g</mi><mi>c</mi><mi>d</mi><mo stretchy="false">(</mo><mi>a</mi><mo separator="true">,</mo><mn>0</mn><mo stretchy="false">)</mo><mo>=</mo><mi>a</mi></mrow><annotation encoding="application/x-tex">gcd(a, 0) = a</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.03588em;">g</span><span class="mord mathdefault">c</span><span class="mord mathdefault">d</span><span class="mopen">(</span><span class="mord mathdefault">a</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">0</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">a</span></span></span></span></span></p><ul><li>对应递归或者循环退出条件</li></ul><p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>g</mi><mi>c</mi><mi>d</mi><mo stretchy="false">(</mo><mi>a</mi><mo separator="true">,</mo><mi>b</mi><mo stretchy="false">)</mo><mo>=</mo><mi>g</mi><mi>c</mi><mi>d</mi><mo stretchy="false">(</mo><mi>b</mi><mo separator="true">,</mo><mi>a</mi><mtext>  </mtext><mi>m</mi><mi>o</mi><mi>d</mi><mtext>  </mtext><mi>b</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">gcd(a, b) = gcd(b, a\;mod\; b)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.03588em;">g</span><span class="mord mathdefault">c</span><span class="mord mathdefault">d</span><span class="mopen">(</span><span class="mord mathdefault">a</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">b</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.03588em;">g</span><span class="mord mathdefault">c</span><span class="mord mathdefault">d</span><span class="mopen">(</span><span class="mord mathdefault">b</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">a</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mord mathdefault">m</span><span class="mord mathdefault">o</span><span class="mord mathdefault">d</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mord mathdefault">b</span><span class="mclose">)</span></span></span></span></span></p><ul><li>对应递归关系，层与层之间的关系。</li></ul><p>对于验证辗转相除法的正确性的证明，这里就不讲了。</p><h3 id="辗转相除法的代码实现"><a class="markdownIt-Anchor" href="#辗转相除法的代码实现"></a> 辗转相除法的代码实现</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">gcd</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(a == <span class="number">0</span> || b == <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> a ? a : b;</span><br><span class="line">    <span class="keyword">int</span> smaller = a &lt; b ? a : b;</span><br><span class="line">    <span class="keyword">int</span> bigger = a &gt; b ? a : b;</span><br><span class="line">    <span class="keyword">return</span> gcd(smaller, bigger % smaller);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="辗转相除法存在的问题"><a class="markdownIt-Anchor" href="#辗转相除法存在的问题"></a> 辗转相除法存在的问题</h3><p><strong>当两个正整数</strong><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>a</mi></mrow><annotation encoding="application/x-tex">a</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">a</span></span></span></span>和<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>b</mi></mrow><annotation encoding="application/x-tex">b</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault">b</span></span></span></span>都特别大的时候，做<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>a</mi><mtext>  </mtext><mi>m</mi><mi>o</mi><mi>d</mi><mtext>  </mtext><mi>b</mi></mrow><annotation encoding="application/x-tex">a\;mod\; b</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault">a</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mord mathdefault">m</span><span class="mord mathdefault">o</span><span class="mord mathdefault">d</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mord mathdefault">b</span></span></span></span>的性能开销比较大。所以要将取模的操作进行替换。</p><h2 id="更相减损术"><a class="markdownIt-Anchor" href="#更相减损术"></a> 更相减损术</h2><h3 id="更相减损术的历史"><a class="markdownIt-Anchor" href="#更相减损术的历史"></a> 更相减损术的历史</h3><p>古希腊人很聪明，但是我们的祖先也不差，更相减损术，出自于中国古代的《九章算术》。</p><p><img src="/" alt="" / class="lazyload" data-src="https://tva1.sinaimg.cn/large/00831rSTgy1gct8xlddmmg30bn0f6q8f.gif"></p><h3 id="更相减损术原理"><a class="markdownIt-Anchor" href="#更相减损术原理"></a> 更相减损术原理</h3><p><strong>两个正整数<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>a</mi></mrow><annotation encoding="application/x-tex">a</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">a</span></span></span></span>和<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>b</mi></mrow><annotation encoding="application/x-tex">b</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault">b</span></span></span></span>（<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>a</mi><mo>&gt;</mo><mi>b</mi></mrow><annotation encoding="application/x-tex">a&gt;b</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.5782em;vertical-align:-0.0391em;"></span><span class="mord mathdefault">a</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">&gt;</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault">b</span></span></span></span>），它们的最大公约数等于<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>a</mi><mo>−</mo><mi>b</mi></mrow><annotation encoding="application/x-tex">a-b</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.66666em;vertical-align:-0.08333em;"></span><span class="mord mathdefault">a</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault">b</span></span></span></span>的差值<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>c</mi></mrow><annotation encoding="application/x-tex">c</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">c</span></span></span></span>和较小数<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>b</mi></mrow><annotation encoding="application/x-tex">b</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault">b</span></span></span></span>的最大公约数。</strong></p><p>这个就不用翻译成人话了，直接给出理论推倒。</p><p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>g</mi><mi>c</mi><mi>d</mi><mo stretchy="false">(</mo><mi>a</mi><mo separator="true">,</mo><mn>0</mn><mo stretchy="false">)</mo><mo>=</mo><mi>a</mi></mrow><annotation encoding="application/x-tex">gcd(a, 0) = a</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.03588em;">g</span><span class="mord mathdefault">c</span><span class="mord mathdefault">d</span><span class="mopen">(</span><span class="mord mathdefault">a</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">0</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">a</span></span></span></span></span></p><ul><li>对应递归或者循环退出条件</li></ul><p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>g</mi><mi>c</mi><mi>d</mi><mo stretchy="false">(</mo><mi>a</mi><mo separator="true">,</mo><mi>b</mi><mo stretchy="false">)</mo><mo>=</mo><mi>g</mi><mi>c</mi><mi>d</mi><mo stretchy="false">(</mo><mi>b</mi><mo separator="true">,</mo><mtext>  </mtext><mi>a</mi><mtext>  </mtext><mo>−</mo><mtext>  </mtext><mi>b</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">gcd(a, b) = gcd(b, \;a\;-\; b)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.03588em;">g</span><span class="mord mathdefault">c</span><span class="mord mathdefault">d</span><span class="mopen">(</span><span class="mord mathdefault">a</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">b</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.03588em;">g</span><span class="mord mathdefault">c</span><span class="mord mathdefault">d</span><span class="mopen">(</span><span class="mord mathdefault">b</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mord mathdefault">a</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">b</span><span class="mclose">)</span></span></span></span></span></p><ul><li>对应递归关系，层与层之间的关系。</li></ul><p>最后直接上代码。</p><h3 id="更相减损术的代码实现"><a class="markdownIt-Anchor" href="#更相减损术的代码实现"></a> 更相减损术的代码实现</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">gcd</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(a == <span class="number">0</span> || b == <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> a ? a : b;</span><br><span class="line">    <span class="keyword">int</span> smaller = a &lt; b ? a : b;</span><br><span class="line">    <span class="keyword">int</span> bigger = a &gt; b ? a : b;</span><br><span class="line">    <span class="keyword">return</span> gcd(bigger - smaller, smaller);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="更相减损术存在的问题"><a class="markdownIt-Anchor" href="#更相减损术存在的问题"></a> 更相减损术存在的问题</h3><p>虽然这里用减法代替了取模操作，但是由于每次都做的是<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>a</mi><mo>−</mo><mi>b</mi></mrow><annotation encoding="application/x-tex">a - b</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.66666em;vertical-align:-0.08333em;"></span><span class="mord mathdefault">a</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault">b</span></span></span></span>操作，所以收敛速度是一个问题。举个极端的例子，当<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>a</mi><mo>=</mo><mn>9999</mn><mo separator="true">,</mo><mi>b</mi><mo>=</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">a = 9999, b = 1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">a</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord">9</span><span class="mord">9</span><span class="mord">9</span><span class="mord">9</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">b</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span>时，这个收敛速度就很慢，在计算机中就要<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>9998</mn></mrow><annotation encoding="application/x-tex">9998</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">9</span><span class="mord">9</span><span class="mord">9</span><span class="mord">8</span></span></span></span>次递归。时间和空间性能都存在很大问题。</p><h2 id="中西结合"><a class="markdownIt-Anchor" href="#中西结合"></a> 中西结合</h2><img src="/" alt="image-20200315093823406" style="zoom:50%;" / class="lazyload" data-src="https://tva1.sinaimg.cn/large/00831rSTly1gcud5di2vdj315w0q61kx.jpg"><p>求最大公约数的问题，可以看成纯粹的数学计算。在计算机中有关有关于计算优化的问题，总结了以下几点：</p><blockquote><ol><li>能用加减解决的，尽量不要用乘除法搞定。</li><li>能用移位运算搞定的，不要用乘除法搞定。<ol><li>比如<code>a /= 2</code> 写成 <code>a &gt;&gt;= 1</code></li><li><code>a *= 6</code> 写成 <code>a = a &lt;&lt; 2 + a &lt;&lt; 1</code></li></ol></li><li>尽量避免一些取模操作，一些特殊的取模操作可以用<code>&amp;</code>运算符代替。<ol><li>判断奇偶<code>a % 2</code> 写成 <code>a &amp; 0x1</code> 形式。</li><li>对<code>a % (2^n)</code>这种数字求模写成<code>a &amp; (2^n - 1)</code>。</li></ol></li><li>优化计算方法，减少计算迭代的次数。</li></ol></blockquote><p>在这里，对暴力法的改进成辗转相除法或更相减损术对应最后一点，是最难的一点，性能提升的很高，数学家一般干这个。</p><p>而大多数人还是通过1、2、3、4条进行改进就可以了。</p><p>最后对辗转相除法和更相减损术进行一些计算上的优化，首先应该明确以下一些原理：</p><blockquote><ol><li>当正整数a和b（a&gt;b）都是偶数时，<code>gcd(a, b) = gcd(a/2, b/2) * 2</code></li><li>当正整数a为奇数时，b（a&gt;b）是偶数时，<code>gcd(a, b) = gcd(a, b/2)</code></li><li>当正整数a为偶数时，b（a&gt;b）是奇数时，<code>gcd(a, b) = gcd(a/2, b)</code></li><li>当正整数a为奇数时，b（a&gt;b）是奇数时，<code>gcd(a, b) = gcd(b, a-b)</code>，此时的<code>a-b</code>是一个整数，又回到了一奇一偶的情况。</li></ol></blockquote><p>注意到其中存在除以2这种特殊的数字，所以直接使用移位运算代替。</p><h3 id="结合位运算的辗转相除法和更相减损术的代码实现"><a class="markdownIt-Anchor" href="#结合位运算的辗转相除法和更相减损术的代码实现"></a> 结合位运算的辗转相除法和更相减损术的代码实现</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">gcd</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(a == <span class="number">0</span> || b == <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> a ? a : b;</span><br><span class="line">    <span class="keyword">int</span> smaller = a &lt; b ? a : b;</span><br><span class="line">    <span class="keyword">int</span> bigger = a &gt; b ? a : b;</span><br><span class="line">    <span class="comment">/*a 偶数  b 偶数*/</span></span><br><span class="line">    <span class="keyword">if</span>(!(smaller &amp; <span class="number">0x1</span>) &amp;&amp; !(bigger &amp; <span class="number">0x1</span>))</span><br><span class="line">        <span class="keyword">return</span> gcd(bigger &gt;&gt; <span class="number">1</span>, smaller &gt;&gt; <span class="number">1</span>) &lt;&lt; <span class="number">1</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/*a 偶数  b 奇数*/</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(!(smaller &amp; <span class="number">0x1</span>) &amp;&amp; (bigger &amp; <span class="number">0x1</span>))</span><br><span class="line">        <span class="keyword">return</span> gcd(bigger, smaller &gt;&gt; <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*a 奇数  b 偶数*/</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>((smaller &amp; <span class="number">0x1</span>) &amp;&amp; !(bigger &amp; <span class="number">0x1</span>))</span><br><span class="line">        <span class="keyword">return</span> gcd(bigger &gt;&gt; <span class="number">1</span>, smaller);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*a 奇数  b 奇数*/</span></span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> gcd(bigger - smaller, smaller);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="总结"><a class="markdownIt-Anchor" href="#总结"></a> 总结</h2><p>其实，有很多东西都是原理或者理论简单，但是实际实现起来还是会有很多细节需要注意的，比如甚至是一个看起来不成问题的求最大公约数的问题，还有这么多门道。</p><p>为了尽快给出一个能用可行的方案，使用了暴力法，但是对于效率和性能的优化是我们必须追求的目标。所以引入了两个求最大公约数的算法。辗转相除法要求两个数的模，但是在计算机中的计算又要尽量避免大数的取模操作。采用更相减损术将取模操作改成了加减法，但是收敛速度又成为了一个大问题。继而将两种方案结合起来，形成一个相对高效的求两个数的最大公约数算法和代码。</p><blockquote><p>这里不得不说，数学才是真正的生产力，是优化的正道。</p><p>而对于一些位运算优化或者代码层面的优化，相对于数学方法的优化，只能说是旁门左道。</p></blockquote><h2 id="测试代码"><a class="markdownIt-Anchor" href="#测试代码"></a> 测试代码</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;ctime&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/time.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> bf&#123;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">gcd</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(a == <span class="number">0</span> || b == <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> a ? a : b;</span><br><span class="line">    <span class="keyword">int</span> smaller = a &lt; b ? a : b;</span><br><span class="line">    <span class="keyword">int</span> bigger = a &gt; b ? a : b;</span><br><span class="line">    <span class="keyword">int</span> res = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= smaller; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>((bigger % i == <span class="number">0</span>) &amp;&amp; (smaller % i == <span class="number">0</span>))</span><br><span class="line">            res = i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> div&#123;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">gcd</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(a == <span class="number">0</span> || b == <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> a ? a : b;</span><br><span class="line">    <span class="keyword">int</span> smaller = a &lt; b ? a : b;</span><br><span class="line">    <span class="keyword">int</span> bigger = a &gt; b ? a : b;</span><br><span class="line">    <span class="keyword">return</span> gcd(smaller, bigger % smaller);</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> gx&#123;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">gcd</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(a == <span class="number">0</span> || b == <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> a ? a : b;</span><br><span class="line">    <span class="keyword">int</span> smaller = a &lt; b ? a : b;</span><br><span class="line">    <span class="keyword">int</span> bigger = a &gt; b ? a : b;</span><br><span class="line">    <span class="keyword">return</span> gcd(bigger - smaller, smaller);</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> divandgx&#123;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">gcd</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(a == <span class="number">0</span> || b == <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> a ? a : b;</span><br><span class="line">    <span class="keyword">int</span> smaller = a &lt; b ? a : b;</span><br><span class="line">    <span class="keyword">int</span> bigger = a &gt; b ? a : b;</span><br><span class="line">    <span class="comment">/*a 偶数  b 偶数*/</span></span><br><span class="line">    <span class="keyword">if</span>(!(smaller &amp; <span class="number">0x1</span>) &amp;&amp; !(bigger &amp; <span class="number">0x1</span>))</span><br><span class="line">        <span class="keyword">return</span> gcd(bigger &gt;&gt; <span class="number">1</span>, smaller &gt;&gt; <span class="number">1</span>) &lt;&lt; <span class="number">1</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/*a 偶数  b 奇数*/</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(!(smaller &amp; <span class="number">0x1</span>) &amp;&amp; (bigger &amp; <span class="number">0x1</span>))</span><br><span class="line">        <span class="keyword">return</span> gcd(bigger, smaller &gt;&gt; <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*a 奇数  b 偶数*/</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>((smaller &amp; <span class="number">0x1</span>) &amp;&amp; !(bigger &amp; <span class="number">0x1</span>))</span><br><span class="line">        <span class="keyword">return</span> gcd(bigger &gt;&gt; <span class="number">1</span>, smaller);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*a 奇数  b 奇数*/</span></span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> gcd(bigger - smaller, smaller);</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">testgcd</span><span class="params">(<span class="built_in">string</span> testname, <span class="keyword">int</span>(*gcd)(<span class="keyword">int</span>, <span class="keyword">int</span>), <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; a, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">timeval</span> <span class="title">start</span>, <span class="title">end</span>;</span></span><br><span class="line">    gettimeofday(&amp;start, <span class="literal">NULL</span>);</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; res;</span><br><span class="line">    <span class="keyword">int</span> len = a.size();</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        res.push_back(gcd(a[i], b[i]));</span><br><span class="line">    &#125;</span><br><span class="line">    gettimeofday(&amp;end, <span class="literal">NULL</span>);</span><br><span class="line">    <span class="keyword">double</span> duration = ((end.tv_sec - start.tv_sec) * <span class="built_in">pow</span>(<span class="number">10</span>, <span class="number">6</span>) + (end.tv_usec - start.tv_usec));</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"test %s has findished, it spent %f us\n"</span>, testname.c_str(), duration);</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> testNum = <span class="number">1000000</span>;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; avec, bvec;</span><br><span class="line">    <span class="keyword">int</span> left = <span class="number">0</span>, right = <span class="number">10000</span>;</span><br><span class="line">    srand(time(<span class="literal">NULL</span>));</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; testNum; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> a  = random() % (right - left + <span class="number">1</span>) + left;</span><br><span class="line">        avec.push_back(a);</span><br><span class="line">        <span class="keyword">int</span> b  = random() % (right - left + <span class="number">1</span>) + left;</span><br><span class="line">        bvec.push_back(b);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">auto</span> res1 = testgcd(<span class="string">"暴力求解法"</span>, bf::gcd, avec, bvec);</span><br><span class="line">    <span class="keyword">auto</span> res2 = testgcd(<span class="string">"辗转相除法"</span>, div::gcd, avec, bvec);</span><br><span class="line">    <span class="keyword">auto</span> res3 = testgcd(<span class="string">"更相减损术"</span>, gx::gcd, avec, bvec);</span><br><span class="line">    <span class="keyword">auto</span> res4 = testgcd(<span class="string">"位运算优化"</span>, divandgx::gcd, avec, bvec);    </span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(res1 != res2 || res1 != res3 || res1 != res4)</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"Error "</span> &lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>运行结果</li></ul><blockquote><p>test 暴力求解法 has findished, it spent 7127775.000000 us<br />test 辗转相除法 has findished, it spent 75551.000000 us<br />test 更相减损术 has findished, it spent 66527.000000 us<br />test 位运算优化 has findished, it spent 112157.000000 us</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 数学 </category>
          
          <category> 编程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 最大公约数 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
